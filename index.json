[{"content":"遇到一些事情的时候，分心，因为总想要以一个好的状态来办事，所以当有一些坏感觉出现的时候，就分心去想办法解决坏感觉。最终一事无成。\n目前自己想到并接受的方法：不管这些坏感觉，出现就出现吧，难受就难受吧，办事情更重要。一边难受一边办事也不是办不了。\n绝对不要拖延，越拖遗憾越多，要勇敢的去验证，去实践。不能错失良机。不能害怕。\n","permalink":"https://sucicada.github.io/blog/posts/role/","summary":"遇到一些事情的时候，分心，因为总想要以一个好的状态来办事，所以当有一些坏感觉出现的时候，就分心去想办法解决坏感觉。最终一事无成。\n目前自己想到并接受的方法：不管这些坏感觉，出现就出现吧，难受就难受吧，办事情更重要。一边难受一边办事也不是办不了。\n绝对不要拖延，越拖遗憾越多，要勇敢的去验证，去实践。不能错失良机。不能害怕。","title":"role"},{"content":"有很多诱惑，比如晚上睡前看视频，虽然这个能带来力量，就是学习的时候或者白天想到晚上可以放松，就会给精神加分，但是成瘾性很难解决。\n关于多巴胺。多巴胺和成瘾。奖赏机制。多巴胺是一种对快乐的渴望，而不是快乐本身。\n多巴胺欲望回路。脑回路会被多巴胺重塑。多巴胺喜欢意外。\n要警惕会导致多巴胺大起大落的一切行为。\n多巴胺带来的是想象，对美好的想象。想象和现实的偏差，是让人痛苦的。\n多巴胺，成瘾是有规律的。\n用享受当下来代替美好幻想。追求和拥有。\n比如刷视频，刷图片，刷帖子。这是因为多巴胺制作了对未来的美好想象，多巴胺想要更多，如果不被及时满足，就会继续幻想并追求下一个。\n因为当前的多巴胺应对的事物结束时，多巴胺跌落，人会十分难受，所以便会立马带动多巴胺，激发想象，追求下一段“美好”。\n解决方法：在当前的美好进行中时，及时满足，在进行到一半的时候察觉，在即将结束时降低多巴胺，进行满足。并尝试找代替。\n比如：从刷视频，刷文字 -\u0026gt; 听音乐，看书\n引申思考：利用多巴胺来激励深层研究、学习、考究、收集、思考。\n","permalink":"https://sucicada.github.io/blog/posts/%E6%97%A5%E8%A8%98/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%B7%B4%E8%83%BA%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E5%B9%B6%E8%A7%A3%E5%86%B3%E6%88%90%E7%98%BE%E6%80%A7%E8%A1%8C%E4%B8%BA/","summary":"有很多诱惑，比如晚上睡前看视频，虽然这个能带来力量，就是学习的时候或者白天想到晚上可以放松，就会给精神加分，但是成瘾性很难解决。\n关于多巴胺。多巴胺和成瘾。奖赏机制。多巴胺是一种对快乐的渴望，而不是快乐本身。\n多巴胺欲望回路。脑回路会被多巴胺重塑。多巴胺喜欢意外。\n要警惕会导致多巴胺大起大落的一切行为。\n多巴胺带来的是想象，对美好的想象。想象和现实的偏差，是让人痛苦的。\n多巴胺，成瘾是有规律的。\n用享受当下来代替美好幻想。追求和拥有。\n比如刷视频，刷图片，刷帖子。这是因为多巴胺制作了对未来的美好想象，多巴胺想要更多，如果不被及时满足，就会继续幻想并追求下一个。\n因为当前的多巴胺应对的事物结束时，多巴胺跌落，人会十分难受，所以便会立马带动多巴胺，激发想象，追求下一段“美好”。\n解决方法：在当前的美好进行中时，及时满足，在进行到一半的时候察觉，在即将结束时降低多巴胺，进行满足。并尝试找代替。\n比如：从刷视频，刷文字 -\u0026gt; 听音乐，看书\n引申思考：利用多巴胺来激励深层研究、学习、考究、收集、思考。","title":"使用多巴胺原理解释并解决成瘾性行为，并利用多巴胺追求爱好使之成为信仰"},{"content":"初次尝试使用hugo建站，已经管不了那么多了，不能再继续耽误下去了。\n然后\n","permalink":"https://sucicada.github.io/blog/posts/%E6%97%A5%E8%A8%98/hugo%E5%BB%BA%E7%AB%99%E6%84%9F%E6%83%B3/","summary":"初次尝试使用hugo建站，已经管不了那么多了，不能再继续耽误下去了。\n然后","title":"hugo建站感想"},{"content":" 本题的目的是识别3000年前古埃及用到的6种象形文字，如图6-10所示。\n图6-10 古代象形符号\n每组数据包含一个H行W列的字符矩阵（H≤200，W≤50），每个字符为4个相邻像素点的\n十六进制（例如，10011100对应的字符就是9c）。转化为二进制后1表示黑点，0表示白点。\n输入满足：\n不会出现上述6种符号之外的其他符号。\n输入至少包含一个符号，且每个黑像素都属于一个符号。\n每个符号都是一个四连块，并且不同符号不会相互接触，也不会相互包含。\n如果两个黑像素有公共顶点，则它们一定有一个相同的相邻黑像素（有公共边）。\n符号的形状一定和表6-9中的图形拓扑等价（可以随意拉伸但不能拉断）。\n要求按照字典序输出所有符号。例如，图6-11中的输出应为AKW。\n样例参见 https://www.udebug.com/UVa/1103\n本家连接\n分为以下几个步骤：\n关键在于辨识每个图形中的空白四连块的数量。就是UVA 572 - Oil Deposits (油田) By SuCicada的升级版。\n好就好在每个图形的白块数量不同，然而如何区分图形内的空白和图形外的空白是个问题。所以我在一开始就把外面的空白都涂黑了。\n然后遍历，遍历到文字就将其当作油田求内部连通白块。\n（最后的排序是手动实现的插入（:P）\n/*\n1. 16进制 转 2进制\n2. 从最外围开始融化 白纸\n3. 遍历到文字黑色边缘,\n4. 向内遍历找\u0026quot;油田\u0026quot;, 即4连块\n5. 计算每个文字的4连块数量\n6. 结束文字们, 根据4连块数量映射文字, 排序\n*/\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; /* 1. 16进制 转 2进制 2. 从最外围开始融化 白纸 3. 遍历到文字黑色边缘, 4. 向内遍历找\u0026#34;油田\u0026#34;, 即4连块 5. 计算每个文字的4连块数量 6. 结束文字们, 根据4连块数量映射文字, 排序 */ char paper[209][209]; int h,w; char res[2222]; int resIndex = 0; /* 文字映射, 下标即文字的空白块数量 */ char wordMap[8] = {\u0026#39;W\u0026#39;,\u0026#39;A\u0026#39;,\u0026#39;K\u0026#39;,\u0026#39;J\u0026#39;,\u0026#39;S\u0026#39;,\u0026#39;D\u0026#39;}; void hex2bin(char c,char res[]){ int n=0; if(c\u0026lt;=\u0026#39;9\u0026#39; \u0026amp;\u0026amp; c \u0026gt;=\u0026#39;0\u0026#39;){ n = c+\u0026#39;0\u0026#39;; }else if(c\u0026gt;=\u0026#39;a\u0026#39; \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;f\u0026#39;){ n = c-\u0026#39;a\u0026#39; + 10; } // int res[4] = {0,0,0,0}; int index = 3; while(index\u0026gt;=0 \u0026amp;\u0026amp; n){ res[index--] = n%2 + \u0026#39;0\u0026#39;; n /= 2; } } void show(){ for(int i=0;i\u0026lt;h;i++){ for(int j=0;j\u0026lt;w;j++){ cout\u0026lt;\u0026lt;paper[i][j]; } cout\u0026lt;\u0026lt;endl; } } /* 文字外围空空 */ void bargin(int x,int y){ char look=\u0026#39;-\u0026#39;; if(x\u0026lt;0 || x\u0026gt;=h || y\u0026lt;0 || y \u0026gt;=w || paper[x][y]!=\u0026#39;0\u0026#39;){ return; } paper[x][y]=look; for(int i=-1;i\u0026lt;=1;i++){ for(int j=-1;j\u0026lt;=1;j++){ if((!i || !j) \u0026amp;\u0026amp; (i || j)){ bargin(x+i,y+j); } } } } void block(int x,int y); /* 黑色文字 */ int black(int x,int y,int sum){ char need=\u0026#39;1\u0026#39;; char look=\u0026#39;x\u0026#39;; if(x\u0026lt;0 || x\u0026gt;=h || y\u0026lt;0 || y \u0026gt;=w){ return sum; } if(paper[x][y] == \u0026#39;0\u0026#39;){ // cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;paper[x][y]\u0026lt;\u0026lt;endl; sum ++; block(x,y); // show(); }else if(paper[x][y] == need){ paper[x][y]=look; for(int i=-1;i\u0026lt;=1;i++){ for(int j=-1;j\u0026lt;=1;j++){ if((!i || !j) \u0026amp;\u0026amp; (i || j)){ sum = black(x+i,y+j,sum); } } } } return sum; } /* 文字中间空空 */ void block(int x,int y){ char need = \u0026#39;0\u0026#39;; char bloc = \u0026#39;+\u0026#39;; if(x\u0026lt;0 || x\u0026gt;=h || y\u0026lt;0 || y \u0026gt;=w || paper[x][y]!=need){ return; } paper[x][y]=bloc; block(x+1,y); block(x-1,y); block(x,y+1); block(x,y-1); } void insert(char ch){ int sureIndex = resIndex; int beforeIndex = sureIndex - 1; while(beforeIndex\u0026gt;=0 \u0026amp;\u0026amp; res[beforeIndex] \u0026gt; ch){ res[sureIndex] = res[beforeIndex]; sureIndex --; beforeIndex --; } resIndex ++; res[sureIndex] = ch; } int main(){ int a,b; int T=1; while(1){ h=w=0; resIndex=0; memset(paper,0,sizeof(paper)); memset(res,0,sizeof(res)); cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(!a \u0026amp;\u0026amp; !b){ break; } h=a,w=b*4; /* init */ for(int i=0;i\u0026lt;a;i++){ for(int j=0;j\u0026lt;b;j++){ char c; cin\u0026gt;\u0026gt;c; char num[4] ={\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;0\u0026#39;}; hex2bin(c,num); for(int k=0;k\u0026lt;4;k++){ paper[i][j*4+k] = num[k]; } } } /* 减去背景空白部分 */ for(int i=0;i\u0026lt;h;i++){ bargin(i,0); bargin(i,w-1); } for(int j=0;j\u0026lt;w;j++){ bargin(0,j); bargin(h-1,j); } // show(); for(int i=0;i\u0026lt;h;i++){ for(int j=0;j\u0026lt;w;j++){ if(paper[i][j] == \u0026#39;1\u0026#39;){ int sum=0; sum = black(i,j,0); insert(wordMap[sum]); // cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } } } cout\u0026lt;\u0026lt;\u0026#34;Case \u0026#34;\u0026lt;\u0026lt;T++\u0026lt;\u0026lt;\u0026#34;: \u0026#34;; for(int i=0;i\u0026lt;resIndex;i++){ cout\u0026lt;\u0026lt;res[i]; } cout\u0026lt;\u0026lt;endl; } return 0; } // AC at 2020/08/01 ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1103-ancient-messages%E5%8F%A4%E4%BB%A3%E8%B1%A1%E5%BD%A2%E7%AC%A6%E5%8F%B7-by-sucicada/","summary":"本题的目的是识别3000年前古埃及用到的6种象形文字，如图6-10所示。\n图6-10 古代象形符号\n每组数据包含一个H行W列的字符矩阵（H≤200，W≤50），每个字符为4个相邻像素点的\n十六进制（例如，10011100对应的字符就是9c）。转化为二进制后1表示黑点，0表示白点。\n输入满足：\n不会出现上述6种符号之外的其他符号。\n输入至少包含一个符号，且每个黑像素都属于一个符号。\n每个符号都是一个四连块，并且不同符号不会相互接触，也不会相互包含。\n如果两个黑像素有公共顶点，则它们一定有一个相同的相邻黑像素（有公共边）。\n符号的形状一定和表6-9中的图形拓扑等价（可以随意拉伸但不能拉断）。\n要求按照字典序输出所有符号。例如，图6-11中的输出应为AKW。\n样例参见 https://www.udebug.com/UVa/1103\n本家连接\n分为以下几个步骤：\n关键在于辨识每个图形中的空白四连块的数量。就是UVA 572 - Oil Deposits (油田) By SuCicada的升级版。\n好就好在每个图形的白块数量不同，然而如何区分图形内的空白和图形外的空白是个问题。所以我在一开始就把外面的空白都涂黑了。\n然后遍历，遍历到文字就将其当作油田求内部连通白块。\n（最后的排序是手动实现的插入（:P）\n/*\n1. 16进制 转 2进制\n2. 从最外围开始融化 白纸\n3. 遍历到文字黑色边缘,\n4. 向内遍历找\u0026quot;油田\u0026quot;, 即4连块\n5. 计算每个文字的4连块数量\n6. 结束文字们, 根据4连块数量映射文字, 排序\n*/\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; /* 1. 16进制 转 2进制 2. 从最外围开始融化 白纸 3. 遍历到文字黑色边缘, 4. 向内遍历找\u0026#34;油田\u0026#34;, 即4连块 5. 计算每个文字的4连块数量 6.","title":"UVA 1103 - Ancient Messages（古代象形符号） By SuCicada"},{"content":"asdfasdfa\n","permalink":"https://sucicada.github.io/blog/about/","summary":"asdfasdfa","title":"About"},{"content":" 例题6-21 系统依赖（System Dependencies, ACM/ICPC World Finals 1997, UVa506）\n软件组件之间可能会有依赖关系，例如，TELNET和FTP都依赖于TCP/IP。你的任务是\n模拟安装和卸载软件组件的过程。首先是一些DEPEND指令，说明软件之间的依赖关系（保\n证不存在循环依赖），然后是一些INSTALL、REMOVE和LIST指令，如表6-1所示。\n表6-1 指令说明\n指令 说明 DEPEND item1 item2 [item3 …] item1依赖组件item2, item3, … INSTALL item1 安装item1和它的依赖（已安装过的不用重新安装） REMOVE item1 卸载item1和它的依赖（如果某组件还被其他显式安装的组件所依赖，则不能卸载这个组件） LIST 输出所有已安装组件 在INSTALL指令中提到的组件称为显式安装，这些组件必须用REMOVE指令显式删除。\n同样地，被这些显式安装组件所直接或间接依赖的其他组件也不能在REMOVE指令中删除。\n每行指令包含不超过80个字符，所有组件名称都是大小写敏感的。指令名称均为大写字母。\nSample Input\nDEPEND TELNET TCPIP NETCARD\nDEPEND TCPIP NETCARD\nDEPEND DNS TCPIP NETCARD\nDEPEND BROWSER TCPIP HTML\nINSTALL NETCARD\nINSTALL TELNET\nINSTALL foo\nREMOVE NETCARD\nINSTALL BROWSER\nINSTALL DNS\nLIST\nREMOVE TELNET\nREMOVE NETCARD\nREMOVE DNS\nREMOVE NETCARD\nINSTALL NETCARD\nREMOVE TCPIP\nREMOVE BROWSER\nREMOVE TCPIP\nEND\nSample Output\nDEPEND TELNET TCPIP NETCARD\nDEPEND TCPIP NETCARD\nDEPEND DNS TCPIP NETCARD\nDEPEND BROWSER TCPIP HTML\nINSTALL NETCARD\nInstalling NETCARD\nINSTALL TELNET\nInstalling TCPIP\nInstalling TELNET\nINSTALL foo\nInstalling foo\nREMOVE NETCARD\nNETCARD is still needed.\nINSTALL BROWSER\nInstalling HTML\nInstalling BROWSER\nINSTALL DNS\nInstalling DNS\nLIST\nNETCARD\nTCPIP\nTELNET\nfoo\nHTML\nBROWSER\nDNS\nREMOVE TELNET\nRemoving TELNET\nREMOVE NETCARD\nNETCARD is still needed.\nREMOVE DNS\nRemoving DNS\nREMOVE NETCARD\nNETCARD is still needed.\nINSTALL NETCARD\nNETCARD is already installed.\nREMOVE TCPIP\nTCPIP is still needed.\nREMOVE BROWSER\nRemoving BROWSER\nRemoving HTML\nRemoving TCPIP\nREMOVE TCPIP\nTCPIP is not installed.\nEND\n本家地址\n这道题挺好玩的，（主要是不难）。\nDAG什么的就行。具体设计都在注释里。\n果然这类工程性设计才适合我吗，（哭，我才不要（仅限于此）\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;sstream\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;set\u0026gt; #include\u0026lt;deque\u0026gt; using namespace std; /* app -\u0026gt; List(app) map\u0026lt; string, vector\u0026lt;string\u0026gt;\u0026gt; install : 根据依赖关系, 递归找父节点, 从父节点开始依次安装, 父节点设置为被依赖 remove : 根据依赖关系, 先删自己, 在找父节点, 父节点若没有依赖-\u0026gt; 删,递归找父节点 list : */ class App{ public: int install; // 1: 隐式安装 2:显式安装 set\u0026lt;string\u0026gt; depended; // 被依赖 int id; // 安装id, 按照安装顺序递增 vector\u0026lt;string\u0026gt; depend; // 依赖项 }; // 存储所有app name -\u0026gt; App map\u0026lt;string,App\u0026gt; table; // 安装的 map\u0026lt;int,string\u0026gt; installed; /* 依赖关系 k -dep-\u0026gt; list(v) */ map\u0026lt;string,vector\u0026lt;string\u0026gt; \u0026gt; dep_table; // 被依赖 k \u0026lt;-dep- list(v) map\u0026lt;string,vector\u0026lt;string\u0026gt; \u0026gt; deped_table; int installed_now_id = 0; // 用于记录最新app 的id void list(); void newapp(string app); // 存在未提及的app // 循环依赖app: 设置其为被依赖 // 若父app 已安装: 不管 // 若父app 未安装: 递归,参数中依赖为1 void install(string app, int depended){ App \u0026amp;aaa = table[app]; if(aaa.install){ if(!depended){ cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;app\u0026lt;\u0026lt;\u0026#34; is already installed.\u0026#34;\u0026lt;\u0026lt;endl; } return; } int size = aaa.depend.size(); for(int i=0;i\u0026lt;size;i++){ string father_app = aaa.depend[i]; if(table[father_app].install == 0){ install(father_app, 1); } // table[father_app].depended += 1; table[father_app].depended.insert(app); } // 循环走完父app们就应该都好了.(安装以及设置依赖项) // 安装自己 cout\u0026lt;\u0026lt;\u0026#34; Installing \u0026#34;\u0026lt;\u0026lt;app\u0026lt;\u0026lt;endl; if(!depended) aaa.install = 2; else aaa.install = 1; // aaa.depended += depended; // 记录在安装列表, id==-1 代表之前未安装过. if(aaa.id==-1){ aaa.id = installed_now_id++; installed[aaa.id] = app; } } // 先判断有没有被依赖, 有则退出, 没有则 // 先删自己, 再对父app减一个依赖, 然后判断父app 若没有依赖就 递归remove int remove(string app, int depended){ App \u0026amp;aaa = table[app]; if(!aaa.install){ cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;app\u0026lt;\u0026lt;\u0026#34; is not installed.\u0026#34;\u0026lt;\u0026lt;endl; return 0; } int size = aaa.depend.size(); if(!aaa.depended.empty()){ cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;app\u0026lt;\u0026lt;\u0026#34; is still needed.\u0026#34;\u0026lt;\u0026lt;endl; return 0; // no } if(depended \u0026amp;\u0026amp; aaa.install==2){ /* 某app依赖删除 and 显式安装 -\u0026gt; 不删 */ return 0; } cout\u0026lt;\u0026lt;\u0026#34; Removing \u0026#34;\u0026lt;\u0026lt;app\u0026lt;\u0026lt;endl; aaa.install = 0; for(int i=0;i\u0026lt;size;i++){ string father_app = aaa.depend[i]; App \u0026amp;faaa = table[father_app]; faaa.depended.erase(app) ; if(faaa.depended.empty()){ remove(father_app,1); // faaa.install = 0; } } // 清除在安装列表, id==-1 代表之前未安装过. installed.erase(aaa.id); aaa.id = -1; return 1; } void list(){ for(map\u0026lt;int,string\u0026gt;::iterator i=installed.begin();i!=installed.end();i++){ cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;(i-\u0026gt;second)\u0026lt;\u0026lt;endl; } } void show(){ cout\u0026lt;\u0026lt;\u0026#34;===========================\u0026#34;\u0026lt;\u0026lt;endl; for(map\u0026lt;string,App\u0026gt;::iterator i=table.begin();i!=table.end();i++){ cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;i-\u0026gt;first\u0026lt;\u0026lt;\u0026#34;]\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;(i-\u0026gt;second).install\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;(i-\u0026gt;second).id\u0026lt;\u0026lt;endl; for(int ii=0;ii\u0026lt;(i-\u0026gt;second).depend.size();ii++){ cout\u0026lt;\u0026lt;(i-\u0026gt;second).depend[ii]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; for(set\u0026lt;string\u0026gt;::iterator ii=(i-\u0026gt;second).depended.begin();ii!=(i-\u0026gt;second).depended.end();ii++){ cout\u0026lt;\u0026lt;*ii\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;\u0026#34;--------------------\u0026#34;\u0026lt;\u0026lt;endl; } void newapp(string app){ if(!table.count(app)){ App a; a.install=0; // a.depended=0; a.id=-1; table[app] = a; } } int main(){ string str; stringstream ss; while(getline(cin,str)){ do{ ss.clear(); ss\u0026lt;\u0026lt;str; cout\u0026lt;\u0026lt; str \u0026lt;\u0026lt;endl;; string head; ss\u0026gt;\u0026gt;head; string s; if(head == \u0026#34;DEPEND\u0026#34;){ string app; ss\u0026gt;\u0026gt;app; newapp(app); while(ss\u0026gt;\u0026gt;s){ table[app].depend.push_back(s); newapp(s); } }else if(head == \u0026#34;INSTALL\u0026#34;){ // show(); ss\u0026gt;\u0026gt;s; if(!table.count(s)){ newapp(s); } install(s,0); }else if(head == \u0026#34;REMOVE\u0026#34;){ ss\u0026gt;\u0026gt;s; remove(s,0); }else if(head == \u0026#34;LIST\u0026#34;){ list(); }else if(head == \u0026#34;END\u0026#34;){ break; } // show(); getline(cin,str); }while(1); } return 0; } // AC at 2020/09/20 ps：没什么好说的，好几天才一道题，简直没救\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uua-506-system-dependencies%E7%B3%BB%E7%BB%9F%E4%BE%9D%E8%B5%96-by-sucicada/","summary":"例题6-21 系统依赖（System Dependencies, ACM/ICPC World Finals 1997, UVa506）\n软件组件之间可能会有依赖关系，例如，TELNET和FTP都依赖于TCP/IP。你的任务是\n模拟安装和卸载软件组件的过程。首先是一些DEPEND指令，说明软件之间的依赖关系（保\n证不存在循环依赖），然后是一些INSTALL、REMOVE和LIST指令，如表6-1所示。\n表6-1 指令说明\n指令 说明 DEPEND item1 item2 [item3 …] item1依赖组件item2, item3, … INSTALL item1 安装item1和它的依赖（已安装过的不用重新安装） REMOVE item1 卸载item1和它的依赖（如果某组件还被其他显式安装的组件所依赖，则不能卸载这个组件） LIST 输出所有已安装组件 在INSTALL指令中提到的组件称为显式安装，这些组件必须用REMOVE指令显式删除。\n同样地，被这些显式安装组件所直接或间接依赖的其他组件也不能在REMOVE指令中删除。\n每行指令包含不超过80个字符，所有组件名称都是大小写敏感的。指令名称均为大写字母。\nSample Input\nDEPEND TELNET TCPIP NETCARD\nDEPEND TCPIP NETCARD\nDEPEND DNS TCPIP NETCARD\nDEPEND BROWSER TCPIP HTML\nINSTALL NETCARD\nINSTALL TELNET\nINSTALL foo\nREMOVE NETCARD\nINSTALL BROWSER\nINSTALL DNS\nLIST\nREMOVE TELNET\nREMOVE NETCARD\nREMOVE DNS","title":"UUA 506 - System Dependencies(系统依赖) By SuCicada"},{"content":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=829\u0026amp;problem=1023\u0026amp;mosmsg=Submission+received+with+ID+20388214\nA common typing error is to place the\nhands on the keyboard one row to the\nright of the correct position. So ‘Q’ is\ntyped as ‘W’ and ‘J’ is typed as ‘K’ and\nso on. You are to decode a message typed in this manner.\nInput\nInput consists of several lines of text. Each line may contain digits, spaces, upper case letters (except\nQ, A, Z), or punctuation shown above [except back-quote (‘)]. Keys labelled with words [Tab, BackSp,\nControl, etc.] are not represented in the input.\nOutput\nYou are to replace each letter or punction symbol by the one immediately to its left on the ‘QWERTY’\nkeyboard shown above. Spaces in the input should be echoed in the output.\nSample Input\nO S, GOMR YPFSU/\nSample Output\nI AM FINE TODAY.\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;iostream\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; int main() { char *s=\u0026#34;`1234567890-=QWERTYUIOP[]\\\\ASDFGHJKL;\u0026#39;ZXCVBNM,./\u0026#34;; char c; while((int)(c=getchar())!=EOF) { char *p; if(p=strchr(s,c)) cout\u0026lt;\u0026lt;*(p-1); else cout\u0026lt;\u0026lt;c; } return 0; } 书上的例题看的书写了一个晚上，堪忧\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-10082-wertyu%E9%94%99%E4%BD%8D%E9%94%AE/","summary":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=829\u0026amp;problem=1023\u0026amp;mosmsg=Submission+received+with+ID+20388214\nA common typing error is to place the\nhands on the keyboard one row to the\nright of the correct position. So ‘Q’ is\ntyped as ‘W’ and ‘J’ is typed as ‘K’ and\nso on. You are to decode a message typed in this manner.\nInput\nInput consists of several lines of text. Each line may contain digits, spaces, upper case letters (except\nQ, A, Z), or punctuation shown above [except back-quote (‘)].","title":"uva 10082 WERTYU（错位键）"},{"content":" 例题6-16 单词（Play On Words, UVa 10129）\n输入n（n≤100000）个单词，是否可以把所有这些单词排成一个序列，使得每个单词的\n第一个字母和上一个单词的最后一个字母相同（例如acm、malform、mouse）。每个单词最多包含1000个小写字母。输入中可以有重复单词。\nSample Input\n3\n2\nacm\nibm\n3\nacm\nmalform\nmouse\n2\nok\nok\nSample Output\nThe door cannot be opened.\nOrdering is possible.\nThe door cannot be opened.\n本家链接\n将一个单词看做是首字母到尾字母的一条路，所以这条路我们只关心头尾，即首尾两个字母，不关心中间字母。\n所以我们可以构造一个图，26*26的图，有向的。其中的边即是一个单词。由此我们便无需关心重复以及首尾字母相同的具体单词了，只关心具有同样首尾的单词的数量。\n所以这道题就成为了：构造了一个图，是否存在欧拉回路。\n存在欧拉回路条件：\n图连通 除了起点和终点，其余每个点的出入度都必须一样。 起点和终点的出入度之差为0或各为1。 用dfs判断连通，用数组记录各个点的出入度。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; /* x --\u0026gt; y */ int dict[33][33]; int inDegree[33]; int outDegree[33]; int N; int SUM = 26; int dfs(int w){ /* start at w */ int road = 0; for(int i=0;i\u0026lt;SUM;i++){ /* 找到了对应的尾字母，即存在一个单词，一条路 */ if(dict[w][i]==1){ dict[w][i] = 2; /* 走过了 */ road = 1; /* 路标记 */ dfs(i); /* 找下一个 */ } return road; } int main(){ int T; cin\u0026gt;\u0026gt;T; while(T--){ cin\u0026gt;\u0026gt;N; int n=N; memset(dict,0,sizeof(dict)); memset(inDegree,0,sizeof(inDegree)); memset(outDegree,0,sizeof(outDegree)); string s; while(n--){ cin\u0026gt;\u0026gt;s; int x = s[0]-\u0026#39;a\u0026#39;; int y = s[s.size()-1]-\u0026#39;a\u0026#39;; dict[x][y] = dict[y][x] = 1; outDegree[x] ++; inDegree[y] ++; } int res = 0; int odd = 0; int inOdd = 0; int outOdd = 0; int ok = 1; for(int i=0;i\u0026lt;SUM;i++){ res += dfs(\u0026#39;a\u0026#39;+i-\u0026#39;a\u0026#39;); if(outDegree[i]!=inDegree[i]){ if((outDegree[i] - inDegree[i])==1){ outOdd ++; }else if((outDegree[i] - inDegree[i])==-1){ inOdd ++; }else{ ok = 0; } } } if(res == 1 \u0026amp;\u0026amp; ok == 1 \u0026amp;\u0026amp; ((inOdd+outOdd==0) || (inOdd==1 \u0026amp;\u0026amp; outOdd==1))){ cout\u0026lt;\u0026lt;\u0026#34;Ordering is possible.\u0026#34;\u0026lt;\u0026lt;endl; }else{ cout\u0026lt;\u0026lt;\u0026#34;The door cannot be opened.\u0026#34;\u0026lt;\u0026lt;endl; } } return 0; } // AC at 2020/08/12 （ps：拖了实在太久了）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-10129-play-on-words-%E5%8D%95%E8%AF%8D-by-sucicada/","summary":"例题6-16 单词（Play On Words, UVa 10129）\n输入n（n≤100000）个单词，是否可以把所有这些单词排成一个序列，使得每个单词的\n第一个字母和上一个单词的最后一个字母相同（例如acm、malform、mouse）。每个单词最多包含1000个小写字母。输入中可以有重复单词。\nSample Input\n3\n2\nacm\nibm\n3\nacm\nmalform\nmouse\n2\nok\nok\nSample Output\nThe door cannot be opened.\nOrdering is possible.\nThe door cannot be opened.\n本家链接\n将一个单词看做是首字母到尾字母的一条路，所以这条路我们只关心头尾，即首尾两个字母，不关心中间字母。\n所以我们可以构造一个图，26*26的图，有向的。其中的边即是一个单词。由此我们便无需关心重复以及首尾字母相同的具体单词了，只关心具有同样首尾的单词的数量。\n所以这道题就成为了：构造了一个图，是否存在欧拉回路。\n存在欧拉回路条件：\n图连通 除了起点和终点，其余每个点的出入度都必须一样。 起点和终点的出入度之差为0或各为1。 用dfs判断连通，用数组记录各个点的出入度。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; /* x --\u0026gt; y */ int dict[33][33]; int inDegree[33]; int outDegree[33]; int N; int SUM = 26; int dfs(int w){ /* start at w */ int road = 0; for(int i=0;i\u0026lt;SUM;i++){ /* 找到了对应的尾字母，即存在一个单词，一条路 */ if(dict[w][i]==1){ dict[w][i] = 2; /* 走过了 */ road = 1; /* 路标记 */ dfs(i); /* 找下一个 */ } return road; } int main(){ int T; cin\u0026gt;\u0026gt;T; while(T--){ cin\u0026gt;\u0026gt;N; int n=N; memset(dict,0,sizeof(dict)); memset(inDegree,0,sizeof(inDegree)); memset(outDegree,0,sizeof(outDegree)); string s; while(n--){ cin\u0026gt;\u0026gt;s; int x = s[0]-\u0026#39;a\u0026#39;; int y = s[s.","title":"UVA 10129 - Play on Words (单词) By SuCicada"},{"content":" 两格子之间的距离\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1030\n走一步判断一下 下一步走哪里\n是走下面呢（前提要能走）\n还是走左边\n还是走右边\n设定一个格子，代表当前走到的地方\n如果能直接向下走，就向下走\n不能的话：\n如果终点在当前格子的哪一边（只看左右方向，不看上下），就走哪一边\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; // 同一行 相邻的能通过 // 上下行 上行的第奇数个能和下行中第偶数个过 //1 3 5 7 //1 2*1-1 2*n-1 //(1+ 2*n-1)*n/2 = int(a) //第 sqrt(a) +1 行 //第 a - sqrt(a)^2 个 // 向左走，向右走？ int which(int a){ int n = sqrt(a-1); int ge = a-n*n; n ++; return n; } int getmid(int a){ int n = which(a); return pow(n-1,2) + n; } int main(){ int a,b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b){ if(a\u0026gt;b) a^=b^=a^=b; int go = a; int b_n = which(b);// 行 int b_mid = getmid(b); int go_mid; int go_n; int sum = 0; while(go != b){ go_n = which(go); if(go_n == b_n){ sum += abs(go - b); break; } else if((go_n+go) % 2 == 0){ // 直接下去 go = go + go_n*2; sum++; continue; } go_mid = getmid(go); int go_distance = go - go_mid; //go距离行中线的距离 int b_distance = b - b_mid; // b 距离中线的距离 int hang_distance = go_distance - b_distance; // go 到 b的距离 if(hang_distance\u0026lt;0){ // b 在 go 的右边 // right go ++; }else // b 在 go 右边 或 b和go在同一列 go--; } // else{ //// if(b - b_mid \u0026lt; 0) // go--; //// else //// go++; // } sum++; } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; } // AC at 2019/3/9 23:09 我只能想到这个笨办法\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1030-delta-wave/","summary":"两格子之间的距离\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1030\n走一步判断一下 下一步走哪里\n是走下面呢（前提要能走）\n还是走左边\n还是走右边\n设定一个格子，代表当前走到的地方\n如果能直接向下走，就向下走\n不能的话：\n如果终点在当前格子的哪一边（只看左右方向，不看上下），就走哪一边\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; // 同一行 相邻的能通过 // 上下行 上行的第奇数个能和下行中第偶数个过 //1 3 5 7 //1 2*1-1 2*n-1 //(1+ 2*n-1)*n/2 = int(a) //第 sqrt(a) +1 行 //第 a - sqrt(a)^2 个 // 向左走，向右走？ int which(int a){ int n = sqrt(a-1); int ge = a-n*n; n ++; return n; } int getmid(int a){ int n = which(a); return pow(n-1,2) + n; } int main(){ int a,b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b){ if(a\u0026gt;b) a^=b^=a^=b; int go = a; int b_n = which(b);// 行 int b_mid = getmid(b); int go_mid; int go_n; int sum = 0; while(go !","title":"UVA 1030  Delta-wave"},{"content":" 例题6-15 给任务排序（Ordering Tasks, UVa 10305）\n假设有n个变量，还有m个二元组(u, v)，分别表示变量u小于v。那么，所有变量从小到\n大排列起来应该是什么样子的呢？例如，有4个变量a, b, c, d，若已知a \u0026lt; b，c \u0026lt; b，d \u0026lt; c，则\n这4个变量的排序可能是a \u0026lt; d \u0026lt; c \u0026lt; b。尽管还有其他可能（如d \u0026lt; a \u0026lt; c \u0026lt; b），你只需找出其\n中一个即可。\nSample Input\n5 4\n1 2\n2 3\n1 3\n1 5\n0 0\nSample Output\n1 4 2 5 3\n本家连接\ndfs(n) 从n开始找上级\n循环找上级\n如果没有上级，break\n如果有上级，\nif 上级 is execute: continue\nelse if 上级 not execute. then dfs(上级),\nend loop\nexec n\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; /* x --\u0026gt; y */ int table[111][111]; int book[111]; int N,M; int space; int loop(int n){ // cout\u0026lt;\u0026lt;\u0026#34;loop \u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;book[n]\u0026lt;\u0026lt;endl; if(!book[n]){ /* n has not executed */ for(int i=1;i\u0026lt;=N;i++){ /* 循环找上级 */ if(table[i][n]){ /* 有上级 */ if(book[i]){ /* 上级运行过了 */ continue; }else{ /*　上级没过　*/ loop(i); } } } if(space){ cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } space = 1; cout\u0026lt;\u0026lt;n; book[n] = 1; } return 0; } int main(){ while(1){ // if(scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b) cin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;M; space = 0; if(N==0 \u0026amp;\u0026amp; M==0){ break; } memset(table,0,sizeof(table)); memset(book,0,sizeof(book)); while(M--){ int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; table[a][b] = 1; } // for(int i=1;i\u0026lt;=N;i++){ // for(int j=1;j\u0026lt;=N;j++){ // cout\u0026lt;\u0026lt;table[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; // } // cout\u0026lt;\u0026lt;endl; // } for(int i=1;i\u0026lt;=N;i++){ loop(i); } cout\u0026lt;\u0026lt;endl; } return 0; } // AC at 2020/08/10 ps：想记一点日记，就来写道题吧。\n周日去参加miku线下应援，太(｡･∀･)ﾉﾞ嗨，太感动了，这等经历定会回味良久。当晚与同行之人会餐，上海的学生，大城市的还是不一样的。\n积攒半月之久的压力与烦恼一扫而光。非常非常非常感动。谢谢谢谢谢谢谢谢。\n想组装一台台式机。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-10305-ordering-tasks-%E7%BB%99%E4%BB%BB%E5%8A%A1%E6%8E%92%E5%BA%8F-by-sucicada/","summary":"例题6-15 给任务排序（Ordering Tasks, UVa 10305）\n假设有n个变量，还有m个二元组(u, v)，分别表示变量u小于v。那么，所有变量从小到\n大排列起来应该是什么样子的呢？例如，有4个变量a, b, c, d，若已知a \u0026lt; b，c \u0026lt; b，d \u0026lt; c，则\n这4个变量的排序可能是a \u0026lt; d \u0026lt; c \u0026lt; b。尽管还有其他可能（如d \u0026lt; a \u0026lt; c \u0026lt; b），你只需找出其\n中一个即可。\nSample Input\n5 4\n1 2\n2 3\n1 3\n1 5\n0 0\nSample Output\n1 4 2 5 3\n本家连接\ndfs(n) 从n开始找上级\n循环找上级\n如果没有上级，break\n如果有上级，\nif 上级 is execute: continue\nelse if 上级 not execute. then dfs(上级),","title":"UVA 10305 - Ordering Tasks (给任务排序) By SuCicada"},{"content":" 习题3-9 子序列（All in All, UVa 10340）\n输入两个字符串s和t，判断是否可以从t中删除0个或多个字符（其他字符顺序不变），\n得到字符串s。例如，abcde可以得到bce，但无法得到dc。\nSample Input\nsequence subsequence\nperson compression\nVERDI vivaVittorioEmanueleReDiItalia\ncaseDoesMatter CaseDoesMatter\nSample Output\nYes\nNo\nYes\nNo\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=1281\u0026amp;mosmsg=Submission+received+with+ID+20551262\n循环大的 从第一位小的开始 判断是否匹配，若是小的下标+1，若非大的+1，继续循环。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s,a; while(cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;a) { int sn=0; for(int i=0;i\u0026lt;a.size()\u0026amp;\u0026amp;sn\u0026lt;s.size();i++) { if(a[i]==s[sn]) { sn++; //cout\u0026lt;\u0026lt;sn\u0026lt;\u0026lt;\u0026#34;!!\u0026#34;\u0026lt;\u0026lt;endl; } } if(sn==s.size()) cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/30 （没想到居然一下就过了，总共十分钟？这还是在同一天的）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-10340-all-in-all%E5%AD%90%E5%BA%8F%E5%88%97/","summary":"习题3-9 子序列（All in All, UVa 10340）\n输入两个字符串s和t，判断是否可以从t中删除0个或多个字符（其他字符顺序不变），\n得到字符串s。例如，abcde可以得到bce，但无法得到dc。\nSample Input\nsequence subsequence\nperson compression\nVERDI vivaVittorioEmanueleReDiItalia\ncaseDoesMatter CaseDoesMatter\nSample Output\nYes\nNo\nYes\nNo\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=1281\u0026amp;mosmsg=Submission+received+with+ID+20551262\n循环大的 从第一位小的开始 判断是否匹配，若是小的下标+1，若非大的+1，继续循环。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s,a; while(cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;a) { int sn=0; for(int i=0;i\u0026lt;a.size()\u0026amp;\u0026amp;sn\u0026lt;s.size();i++) { if(a[i]==s[sn]) { sn++; //cout\u0026lt;\u0026lt;sn\u0026lt;\u0026lt;\u0026#34;!!\u0026#34;\u0026lt;\u0026lt;endl; } } if(sn==s.size()) cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/30 （没想到居然一下就过了，总共十分钟？这还是在同一天的）","title":"uva 10340 - All in All（子序列）"},{"content":" 例题6-17 看图写树（Undraw the Trees, UVa 10562）\n你的任务是将多叉树转化为括号表示法。如图6-16所示，每个结点用除了“-”、“|”和空格\n的其他字符表示，每个非叶结点的正下方总会有一个“|”字符，然后下方是一排“-”字符，恰\n好覆盖所有子结点的上方。单独的一行“#”为数据结束标记。\nSample Input\n2 A | -------- B C D | | ----- - E F G # e | ---- f g # Sample Output\n(A(B()C(E()F())D(G())))\n(e(f()g()))\n本家地址\n先记录树，然后从头开始递归遍历树，并且构造先序遍历字串。\n非叶子结点字母下方必有竖线。竖线下方必有若干横线，横线下方必有若干字母，即子节点。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; char tree[222][222]; int isRightChar(char c){ return c \u0026amp;\u0026amp; c!=\u0026#39;-\u0026#39; \u0026amp;\u0026amp; c!=\u0026#39;|\u0026#39; \u0026amp;\u0026amp; c!=\u0026#39; \u0026#39; \u0026amp;\u0026amp; c!=\u0026#39;#\u0026#39;; } int loop(int x,int y){ cout\u0026lt;\u0026lt;tree[x][y]; cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;; if(tree[x+1][y]!=\u0026#39;|\u0026#39;){ return 0; }else{ int a; for(a=y;tree[x+2][a]==\u0026#39;-\u0026#39;;a--){} a++; int b; for(b=y;tree[x+2][b]==\u0026#39;-\u0026#39;;b++){} b--; for(int i=a;i\u0026lt;=b;i++){ if(isRightChar(tree[x+3][i])){ loop(x+3,i); cout\u0026lt;\u0026lt;\u0026#34;)\u0026#34;; } } } return 1; } int main(){ int T; cin\u0026gt;\u0026gt;T; getchar(); while(T--){ memset(tree,0,sizeof(tree)); int line=0; int row=0; while(1){ string s; getline(cin,s); row=0; if(s.size()==1 \u0026amp;\u0026amp; s[0]==\u0026#39;#\u0026#39;){ break; }else{ for(int i=0;i\u0026lt;s.size();i++){ tree[line][row++] = s[i]; } line++; } } cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;; for(int i=0;i\u0026lt;200;i++){ if(isRightChar(tree[0][i])){ loop(0,i); cout\u0026lt;\u0026lt;\u0026#34;)\u0026#34;; break; } } cout\u0026lt;\u0026lt;\u0026#34;)\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } // AC at 2020/08/16 ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-10562-undraw-the-trees%E7%9C%8B%E5%9B%BE%E5%86%99%E6%A0%91-by-sucicada/","summary":"例题6-17 看图写树（Undraw the Trees, UVa 10562）\n你的任务是将多叉树转化为括号表示法。如图6-16所示，每个结点用除了“-”、“|”和空格\n的其他字符表示，每个非叶结点的正下方总会有一个“|”字符，然后下方是一排“-”字符，恰\n好覆盖所有子结点的上方。单独的一行“#”为数据结束标记。\nSample Input\n2 A | -------- B C D | | ----- - E F G # e | ---- f g # Sample Output\n(A(B()C(E()F())D(G())))\n(e(f()g()))\n本家地址\n先记录树，然后从头开始递归遍历树，并且构造先序遍历字串。\n非叶子结点字母下方必有竖线。竖线下方必有若干横线，横线下方必有若干字母，即子节点。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; char tree[222][222]; int isRightChar(char c){ return c \u0026amp;\u0026amp; c!=\u0026#39;-\u0026#39; \u0026amp;\u0026amp; c!=\u0026#39;|\u0026#39; \u0026amp;\u0026amp; c!=\u0026#39; \u0026#39; \u0026amp;\u0026amp; c!=\u0026#39;#\u0026#39;; } int loop(int x,int y){ cout\u0026lt;\u0026lt;tree[x][y]; cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;; if(tree[x+1][y]!","title":"UVA 10562 - Undraw the Trees(看图写树) By SuCicada"},{"content":" 习题3-12 浮点数（Floating-Point Numbers, UVa11809）\n计算机常用阶码-尾数的方法保存浮点数。如图3-9所示，如果阶码有6位，尾数有8位，可以表达的最大浮点数为0.1111111112×2\n1111112。注意小数点后第一位必须为1，所以一共有9位小数。\n图3-9 阶码-尾数保存浮点数\n这个数换算成十进制之后就是0.9980468752^63=9.20535763834529410^18。你的任务是根据这个最大浮点数，求出阶码的位数E和尾数的位数M。输入格式为AeB，表示最大浮点数为A*10B。0\u0026lt; A\u0026lt;10，并且恰好包含15位有效数字。输 入结束标志为0e0。对于每组数据，输\n出M和E。输入保证有唯一解，且0≤M≤9，1≤E≤30。在本题中，M+E+2不必为8的整数倍。\nSample Input\n5.699141892149156e76\n9.205357638345294e18\n0e0\nSample Output\n5 8\n8 6\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=2909\u0026amp;mosmsg=Submission+received+with+ID+20702100\n我们只要算：m*2^(2^n-1)=f *10^t (m是浮点数位，n是阶码位数，求f和t；) 而f=10^log10(f)：即左边=10^t1=10^(t+log10(f)); t1=log10(m*2^(2^n-1))=log10(m)+(2^n-1) *log10(2) t=(int)t1; f=10^(t1-t);\n感谢参考来自http://blog.csdn.net/crazysillynerd/article/details/43339157 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; double flo[10][30]; int expstr[10][30]; int main() { int twoe; double twom; double temp; for(int i=0;i\u0026lt;10;i++) { twom=1-pow(2,-i-1); for(int j=0;j\u0026lt;30;j++) { twoe = pow(2,j+1)-1; temp = log10(twom)+twoe*log10(2); expstr[i][j]=temp; flo[i][j]=pow(10,(temp-expstr[i][j])); } } while(1) { double flo1; int exp1; char str[25]={0};//存输入的浮点数字符串 int iff=0; //输入浮点数 char c; for(int i=0;(c=getchar())!=\u0026#39;e\u0026#39;;i++) { str[i]=c;//scanf(\u0026#34;%c\u0026#34;,\u0026amp;str[i]); } sscanf(str,\u0026#34;%lf\u0026#34;,\u0026amp;flo1); scanf(\u0026#34;%d\u0026#34;,\u0026amp;exp1); if(flo1==0\u0026amp;\u0026amp;exp1==0)//结束标志 break; //从表中找最接近的小数 for(int i=0;i\u0026lt;10;i++) { for(int j=0;j\u0026lt;30;j++) { //cout\u0026lt;\u0026lt;flo[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;expstr[i][j]\u0026lt;\u0026lt;endl; if(abs(flo[i][j]-flo1)\u0026lt;10e-6\u0026amp;\u0026amp; exp1==expstr[i][j]) { cout\u0026lt;\u0026lt;i; cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j+1\u0026lt;\u0026lt;endl; iff=1; break; } } if(iff==1)break; } } return 0; } //AC at 2018/2/1 （另外提供几个样例\nin\n6.741349255732847e307\n1.937500000000000e0\n8.970910077290883e307\n2.734479740168092e20201780\n5.443088840828674e2465\n7.100722886226033e80807123\n7.499999999999997e0\n4.461493107584252e4931\n7.930743765436021e78912\n1.638399999999996e4\n6.284909967160199e153\n5.794969071594055e40403561\n7.874999999999996e0\n7.049550013794259e78912\n5.205075292180178e4931\n2.094479696316021e323228496\n5.999999999999998e0\n7.513237239003285e19727\n2.065788087458129e323228496\n5.112881885711930e2465\n0e0\nout\n1 10\n4 1\n8 10\n0 26\n8 13\n6 28\n3 2\n1 14\n5 18\n0 4\n3 9\n4 27\n5 2\n2 18\n2 14\n8 30\n1 2\n1 16\n5 30\n3 13\n）\n说来心酸：第一个思路：将输入的以十为底的小数化为以二为底的，是直接一位一位冥次死算出的。并且转换后，运用到十进制小数转二进制，先不论麻烦至极和时间耗费太久，最重要的是这样精度的问题会很大。（失败）\n第二思路：网上查询后，要打表，好。费尽脑筋思考怎么将十为底的小数化为以二为底的数，看网上说用10=1.25*2^3来推，是的这样可以，但是表打出来就要花9s，绝对的超时。\n（题外话：这道题一开始做还是在去年，当时写好了第一种思路以为很快就可以通过，于是之后考试复习就没有再管。就这样断断续续一个多月才终于把这道题做出来。）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-11809-floating-point-numbers%E6%B5%AE%E7%82%B9%E6%95%B0/","summary":"习题3-12 浮点数（Floating-Point Numbers, UVa11809）\n计算机常用阶码-尾数的方法保存浮点数。如图3-9所示，如果阶码有6位，尾数有8位，可以表达的最大浮点数为0.1111111112×2\n1111112。注意小数点后第一位必须为1，所以一共有9位小数。\n图3-9 阶码-尾数保存浮点数\n这个数换算成十进制之后就是0.9980468752^63=9.20535763834529410^18。你的任务是根据这个最大浮点数，求出阶码的位数E和尾数的位数M。输入格式为AeB，表示最大浮点数为A*10B。0\u0026lt; A\u0026lt;10，并且恰好包含15位有效数字。输 入结束标志为0e0。对于每组数据，输\n出M和E。输入保证有唯一解，且0≤M≤9，1≤E≤30。在本题中，M+E+2不必为8的整数倍。\nSample Input\n5.699141892149156e76\n9.205357638345294e18\n0e0\nSample Output\n5 8\n8 6\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=2909\u0026amp;mosmsg=Submission+received+with+ID+20702100\n我们只要算：m*2^(2^n-1)=f *10^t (m是浮点数位，n是阶码位数，求f和t；) 而f=10^log10(f)：即左边=10^t1=10^(t+log10(f)); t1=log10(m*2^(2^n-1))=log10(m)+(2^n-1) *log10(2) t=(int)t1; f=10^(t1-t);\n感谢参考来自http://blog.csdn.net/crazysillynerd/article/details/43339157 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; double flo[10][30]; int expstr[10][30]; int main() { int twoe; double twom; double temp; for(int i=0;i\u0026lt;10;i++) { twom=1-pow(2,-i-1); for(int j=0;j\u0026lt;30;j++) { twoe = pow(2,j+1)-1; temp = log10(twom)+twoe*log10(2); expstr[i][j]=temp; flo[i][j]=pow(10,(temp-expstr[i][j])); } } while(1) { double flo1; int exp1; char str[25]={0};//存输入的浮点数字符串 int iff=0; //输入浮点数 char c; for(int i=0;(c=getchar())!","title":"uva 11809 - Floating-Point Numbers（浮点数）"},{"content":" 例题6-22 战场（Paintball, UVa 11853）\n有一个1000×1000的正方形战场，战场西南角的坐标为(0,0)，西北角的坐标为(0,1000)。\n战场上有n（0≤n≤1000）个敌人，第i个敌人的坐标为(xi\n,yi\n)，攻击范围为ri。为了避开敌人的\n攻击，在任意时刻，你与每个敌人的距离都必须严格大于它的攻击范围。你的任务是从战场\n的西边（x=0的某个点）进入，东边（x=1000的某个点）离开。如果有多个位置可以进/出，\n你应当求出最靠北的位置。输入每个敌人的xi、yi、ri，输出进入战场和离开战场的坐标。\nSample Input\n3\n500 500 499\n0 0 999\n1000 1000 200\nSample Output\n0.00 1000.00 1000.00 800.00\n本家地址\n关键在于抓住问题的本质，即问题的核心，即问题去除了表面保护层之下的那个最纯粹的那个命脉。\n初看，我们发现，这是要在坐标图上画圆啊。过分可怕。\n但是我们鼓起勇气再细看问题：\n求最靠上的进入战场和离开战场的坐标。\n解剖一下：\n能否离开 若能，最上 最左边进，最后边出。 然后我们随便画几个图来看看。\n怎么样就不能离开：\n当有一条敌人从最上一直连通到最下。\n若能，最靠上的地方是哪里：\n如果我们最左边进入的地方的下方有一条敌线一直连通到最上边。\n那么这条敌线就把我们包住了。\n所以 敌线（从上方延伸 and 延伸到左边），就不能被我们在其上方进入。\n所以我们只要求敌线的连通性和敌线范围（从上方开始的）在最左边和最右边的最下方坐标即可。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; /* 关键在于抓住问题的本质，即问题的核心，即问题去除了表面保护层之下的那个最纯粹的那个命脉。 初看，我们发现，这是要在坐标图上画圆啊。过分可怕。 但是我们鼓起勇气再细看问题： 求最靠上的进入战场和离开战场的坐标。 解剖一下： 1. 能否离开 2. 若能，最上 3. 最左边进，最后边出。 然后我们随便画几个图来看看。 怎么样就不能离开： 当有一条敌人从最上一直连通到最下。 若能，最靠上的地方是哪里： 如果我们最左边进入的地方的下方有一条敌线一直连通到最上边。 那么这条敌线就把我们包住了。 所以 敌线（从上方延伸 and 延伸到左边），就不能被我们在其上方进入。 所以我们只要求敌线的连通性和敌线范围（从上方开始的）在最左边和最右边的最下方坐标即可。 */ /* 地图 */ int site[1003][1003]; /* 下标就是这个敌人的标号 */ vector\u0026lt;int\u0026gt; xList; vector\u0026lt;int\u0026gt; yList; vector\u0026lt;int\u0026gt; range; /* 走过的标记 */ int book[1003]; /* 敌人的关系图 */ int table[1003][1003]; /* map[x][y] 记录 敌人标号 table[x][y] 标号对应 从上边找起, bfs, 若能达到最下边 -\u0026gt; 不可达, break; 若不能达到最下边 -\u0026gt; continue -\u0026gt; 若全部不能到下边 -\u0026gt; 左可达右 -\u0026gt; 在bfs中记录达到的左边的最下部, 以及右边的最下部, 获取走 */ int N; int cover(int a, int b){ return pow(xList[a]-xList[b],2) + pow(yList[a]-yList[b],2) \u0026lt;= pow(range[a]+range[b],2); } double getlen(int index,int lr){ int x; if(lr==0){ x = xList[index]; }else if(lr == 1){ x = 1000-xList[index]; } return sqrt(pow(range[index],2) - pow(x,2)); } /* 左边最低 */ double left_lowest = 1000; /* 右边最低 */ double right_lowest = 1000; int bfs(int index){ /* 到下边 */ int pass = 1; queue\u0026lt;int\u0026gt; temp; temp.push(index); while(!temp.empty()){ int n = temp.front();temp.pop(); book[n] = 1; for(int i=0;i\u0026lt;N;i++){ /* 圆接触的 , 同时没走过的 */ if(table[n][i] \u0026amp;\u0026amp; book[i]==0){ temp.push(i); } } /* if 接触下边 */ if(yList[n]-range[n]\u0026lt;=0){ pass = 0; break; } /* if 接触左边 */ if(xList[n]-range[n]\u0026lt;=0){ left_lowest = min(left_lowest, yList[n]-getlen(n,0)); } /* if 接触右边 */ if(xList[n]+range[n]\u0026gt;=1000){ right_lowest = min(right_lowest, yList[n]-getlen(n,1)); } } return pass; } int main(){ int T; while(cin\u0026gt;\u0026gt;T){ memset(site,-1,sizeof(site)); memset(book,0,sizeof(book)); memset(table,0,sizeof(table)); xList.clear(); yList.clear(); range.clear(); /* 左边最低 */ left_lowest = 1000; /* 右边最低 */ right_lowest = 1000; N = T; while(T--){ int a,b,c; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; int index = xList.size(); xList.push_back(a); yList.push_back(b); range.push_back(c); site[a][b] = index; } for(int i=0;i\u0026lt;N;i++){ for(int j=i+1;j\u0026lt;N;j++){ if(cover(i,j)){ table[i][j] = 1; table[j][i] = 1; } } } /* 从最上面开始, (0,1000) -- (1000,1000) */ int pass = 1; for(int i=0;i\u0026lt;N;i++){ if(yList[i]+range[i]\u0026gt;=1000){ pass = bfs(i); if(pass==0){ break; } } } if(pass==0){ cout\u0026lt;\u0026lt;\u0026#34;IMPOSSIBLE\u0026#34;\u0026lt;\u0026lt;endl; }else{ printf(\u0026#34;0.00 %.2lf 1000.00 %.2lf\\n\u0026#34;,left_lowest,right_lowest); } return 0; } // AC at 2020/09/26 ps：当然，这篇也求助了刘汝佳，我真是没用。\n至此第六章的例题就结束了（终于）。可以开始下一章的例题了（苦笑）\n暴力求解，应该能简单屑吧（并不）。\n只要够暴力就行了。\n至此拖更了足足40多天的题目blog就都更完了。皆大欢喜。然而今天已经10.11了。拖延症已经到了如此地步。\n这两天状态很不好，喜怒无常。难以调动自己的积极情绪。\n我想我应该换一个平台来记。我应该制定规划。\n感觉不经意之间又被现实裹挟了。我应该充分拥抱我所喜爱之物，我应该充满活力。\n室友不在的几天，在黄昏，在夜晚，感到了空廖。就像许久之前。\n但我翻开那时的记录，泥泞之至让现在的我感到窒息。所以我就在想，我好不容易脱离那泥潭，我又为何要再入，亦或是说我此刻又陷入了另一个泥潭。\n人的本质还是想要群居的。一个人久就会开始恐慌。所以我们需要陪伴之物，不会抛弃不会背叛我们之物。之前我选择的是算法和程序。除此之外还需要一些其他的，但是我一直抓不住这其他的是什么。\n有人说，这最好的陪伴之物是人。但那是最终极的成就，我等尚仅可奢望。\n`\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-11853-paintbal%E6%88%98%E5%9C%BA-by-sucicada/","summary":"例题6-22 战场（Paintball, UVa 11853）\n有一个1000×1000的正方形战场，战场西南角的坐标为(0,0)，西北角的坐标为(0,1000)。\n战场上有n（0≤n≤1000）个敌人，第i个敌人的坐标为(xi\n,yi\n)，攻击范围为ri。为了避开敌人的\n攻击，在任意时刻，你与每个敌人的距离都必须严格大于它的攻击范围。你的任务是从战场\n的西边（x=0的某个点）进入，东边（x=1000的某个点）离开。如果有多个位置可以进/出，\n你应当求出最靠北的位置。输入每个敌人的xi、yi、ri，输出进入战场和离开战场的坐标。\nSample Input\n3\n500 500 499\n0 0 999\n1000 1000 200\nSample Output\n0.00 1000.00 1000.00 800.00\n本家地址\n关键在于抓住问题的本质，即问题的核心，即问题去除了表面保护层之下的那个最纯粹的那个命脉。\n初看，我们发现，这是要在坐标图上画圆啊。过分可怕。\n但是我们鼓起勇气再细看问题：\n求最靠上的进入战场和离开战场的坐标。\n解剖一下：\n能否离开 若能，最上 最左边进，最后边出。 然后我们随便画几个图来看看。\n怎么样就不能离开：\n当有一条敌人从最上一直连通到最下。\n若能，最靠上的地方是哪里：\n如果我们最左边进入的地方的下方有一条敌线一直连通到最上边。\n那么这条敌线就把我们包住了。\n所以 敌线（从上方延伸 and 延伸到左边），就不能被我们在其上方进入。\n所以我们只要求敌线的连通性和敌线范围（从上方开始的）在最左边和最右边的最下方坐标即可。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; /* 关键在于抓住问题的本质，即问题的核心，即问题去除了表面保护层之下的那个最纯粹的那个命脉。 初看，我们发现，这是要在坐标图上画圆啊。过分可怕。 但是我们鼓起勇气再细看问题： 求最靠上的进入战场和离开战场的坐标。 解剖一下： 1. 能否离开 2. 若能，最上 3.","title":"UVA 11853 - Paintbal(战场) By SuCicada"},{"content":" 例题5-5\n集合栈计算机(The\nSet\nStack\nComputer,ACM/ICPC\nNWERC\n2006,UVa12096)\n有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈,并且\n支持以下操作。\nPUSH:空集“{}”入栈。\nDUP:把当前栈顶元素复制一份后再入栈。\nUNION:出栈两个集合,然后把二者的并集入栈。\nINTERSECT:出栈两个集合,然后把二者的交集入栈。ADD:出栈两个集合,然后把先出栈的集合加入到后出栈的集合中,把结果入栈。\n每次操作后,输出栈顶集合的大小(即元素个数)。例如,栈顶元素是A={{},\n{{}}},下一个元素是B={{},{{{}}}},则:\nUNION操作将得到{{},{{}},{{{}}}},输出3。\nINTERSECT操作将得到{{}},输出1。\nADD操作将得到{{},{{{}}},{{},{{}}}},输出3。\n输入不超过2000个操作,并且保证操作均能顺利进行(不需要对空栈执行出栈操作)。\nSample Input\n2\n9\nPUSH\nDUP\nADD\nPUSH\nADD\nDUP\nADD\nDUP\nUNION\n5\nPUSH\nPUSH\nADD\nPUSH\nINTERSECT\nSample Output\n0\n0\n1\n0\n1\n1\n2\n2\n2\n***\n0\n0\n1\n0\n0\n***\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=835\u0026amp;problem=3248\u0026amp;mosmsg=Submission+received+with+ID+21273791\n性质：\n１、set\u0026lt; int \u0026gt;　代表是集合\n２、idcache 是集合与其编号的映射，每一个集合都有唯一的编号。\n３、setcache是向量，即下标与其存的是集合的元素相映射。\n４、每一个集合都只在以上容器中存在一个。\n５、栈里存的只是集合的编号。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; map\u0026lt; set\u0026lt;int\u0026gt; ,int\u0026gt; idcache; //每一个集合对应一个编号 vector\u0026lt; set\u0026lt;int\u0026gt; \u0026gt; setcache; //每一个编号对应一个集合 int getid(set\u0026lt;int\u0026gt; s) { if(idcache.count(s)) return idcache[s]; else setcache.push_back(s); //将集合存入vector idcache[s]=setcache.size()-1; //将集合存入map，从0开始，为了让map中的键与值与vector元素与下标相对应 return idcache[s]; } int main() { int T;\tcin\u0026gt;\u0026gt;T; while(T--) { stack\u0026lt;int\u0026gt; s;\t//只是存的集合的编号 idcache.clear(); setcache.clear(); int n; cin\u0026gt;\u0026gt;n; while(n--) { // cout\u0026lt;\u0026lt;\u0026#34;n\u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; string str; cin\u0026gt;\u0026gt;str; if(str==\u0026#34;PUSH\u0026#34;) { set\u0026lt;int\u0026gt; temps; int temp=getid(temps); s.push(temp); } else if(str==\u0026#34;DUP\u0026#34;) { s.push(s.top()); } else { set\u0026lt;int\u0026gt; first =setcache[s.top()]; //这时要取的是vetor中的元素，是set\u0026lt;int\u0026gt;类型，而s里元素是int类型 s.pop(); set\u0026lt;int\u0026gt; second=setcache[s.top()]; s.pop(); set\u0026lt;int\u0026gt; ans; if(str==\u0026#34;INTERSECT\u0026#34;) { set\u0026lt;int\u0026gt;::iterator i=first.begin(); for(;i!=first.end();i++) { set\u0026lt;int\u0026gt;::iterator j=second.begin(); for(;j!=second.end();j++) { if(*i==*j) ans.insert(*i); } } } if(str==\u0026#34;UNION\u0026#34;) { ans=second; //直接赋值set\u0026lt;int\u0026gt; set\u0026lt;int\u0026gt;::iterator i=first.begin(); for(;i!=first.end();i++)\t{ ans.insert(*i); } } if(str==\u0026#34;ADD\u0026#34;) { ans=second; //直接赋值set\u0026lt;int\u0026gt; ans.insert(getid(first)); //插入int型，是first对应的编号，将first作为了ans的一个元素 } s.push(getid(ans)); }\tcout\u0026lt;\u0026lt;setcache[s.top()].size()\u0026lt;\u0026lt;endl; // cout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;endl; // stack\u0026lt;int\u0026gt; t=s; // for(int i=0;i\u0026lt;s.size();i++) // {\tint ii=t.top(); // t.pop(); // set\u0026lt;int\u0026gt;::iterator it=setcache[ii].begin(); // for(;it!=setcache[ii].end();it++) // cout\u0026lt;\u0026lt; *it\u0026lt;\u0026lt;\u0026#34; \u0026#34;; // cout\u0026lt;\u0026lt;\u0026#34;|\u0026#34;\u0026lt;\u0026lt;endl; // } // cout\u0026lt;\u0026lt;endl; }\tcout\u0026lt;\u0026lt;\u0026#34;***\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } //AC at 2018/5/7 ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-12096-the-setstack-computer%E9%9B%86%E5%90%88%E6%A0%88/","summary":"例题5-5\n集合栈计算机(The\nSet\nStack\nComputer,ACM/ICPC\nNWERC\n2006,UVa12096)\n有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈,并且\n支持以下操作。\nPUSH:空集“{}”入栈。\nDUP:把当前栈顶元素复制一份后再入栈。\nUNION:出栈两个集合,然后把二者的并集入栈。\nINTERSECT:出栈两个集合,然后把二者的交集入栈。ADD:出栈两个集合,然后把先出栈的集合加入到后出栈的集合中,把结果入栈。\n每次操作后,输出栈顶集合的大小(即元素个数)。例如,栈顶元素是A={{},\n{{}}},下一个元素是B={{},{{{}}}},则:\nUNION操作将得到{{},{{}},{{{}}}},输出3。\nINTERSECT操作将得到{{}},输出1。\nADD操作将得到{{},{{{}}},{{},{{}}}},输出3。\n输入不超过2000个操作,并且保证操作均能顺利进行(不需要对空栈执行出栈操作)。\nSample Input\n2\n9\nPUSH\nDUP\nADD\nPUSH\nADD\nDUP\nADD\nDUP\nUNION\n5\nPUSH\nPUSH\nADD\nPUSH\nINTERSECT\nSample Output\n0\n0\n1\n0\n1\n1\n2\n2\n2\n***\n0\n0\n1\n0\n0\n***\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=835\u0026amp;problem=3248\u0026amp;mosmsg=Submission+received+with+ID+21273791\n性质：\n１、set\u0026lt; int \u0026gt;　代表是集合\n２、idcache 是集合与其编号的映射，每一个集合都有唯一的编号。\n３、setcache是向量，即下标与其存的是集合的元素相映射。\n４、每一个集合都只在以上容器中存在一个。\n５、栈里存的只是集合的编号。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; map\u0026lt; set\u0026lt;int\u0026gt; ,int\u0026gt; idcache; //每一个集合对应一个编号 vector\u0026lt; set\u0026lt;int\u0026gt; \u0026gt; setcache; //每一个编号对应一个集合 int getid(set\u0026lt;int\u0026gt; s) { if(idcache.","title":"uva 12096 - The SetStack Computer（集合栈）"},{"content":" 例题6-18 雕塑（Sculpture, ACM/ICPC NWERC 2008, UVa12171）\n某雕塑由n（n≤50）个边平行于坐标轴的长方体组成。每个长方体用6个整\n数x0，y0，z0，x，y，z表示（均为1～500的整数），其中x0为长方体的顶点中x坐标的最小\n值，x表示长方体在x方向的总长度。其他4个值类似定义。你的任务是统计这个雕像的体积\n和表面积。注意，雕塑内部可能会有密闭的空间，其体积应计算在总体积中，但从“外部”看\n不见的面不应计入表面积。雕塑可能会由多个连通块组成。\nSample Input\n2\n2\n1 2 3 3 4 5\n6 2 3 3 4 5\n7\n1 1 1 5 5 1\n1 1 10 5 5 1\n1 1 2 1 4 8\n2 1 2 4 1 8\n5 2 2 1 4 8\n1 5 2 4 1 8\n3 3 4 1 1 1\nSample Output\n188 120\n250 250\n本家地址\n关键点：\n构造三维数组space来模拟雕像涂色。 我们只从空白处开始遍历联通部分，最后使用总体积和面积减去空白部分的。 但是不能使用500*500*500的数组，太大。采用离散化。即将雕像分组，因为最多只有50个方块，所以每个方向最多只会有100个分组。 使用map来存储坐标值与space中的方位的对应关系。、 之后使用常规bfs方式进行方块遍历。不要用dfs，栈溢出。 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;set\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; class Cube{ public: int xyz[3]; int sss[3]; }; vector\u0026lt;Cube\u0026gt; cubeList; /* site[0] =\u0026gt; x site[1] =\u0026gt; y site[2] =\u0026gt; z 每个map键为坐标原始值，对应的值为space中的坐标值对应的单元格的下标 map\u0026lt;value, index\u0026gt; 通过 对应的坐标点的值去map里得到 space的位置 */ map\u0026lt;int,int\u0026gt; site[3]; /* 每个方向上的原始坐标值,用vector存是为了更快的遍历 */ vector\u0026lt;int\u0026gt; value[3]; /* 因为最多只有50个方块，即每个方向100个边，即最多每个方向会分为100个不定大小的单元格 按照单元格（不定大小）进行分组，存储单元格信息（染色与否） */ int space[105][105][105]; queue\u0026lt;Cube\u0026gt; temp; int getSetIndex(int xyz, int value){ return site[xyz][value]; } long V; // 空白的体积 long S; // 空白的表面积(带外围) int XX,YY,ZZ; // 单元格的每个方向上的数量,即space尺寸 int check(int x,int y,int z){ if(x\u0026gt;=0\u0026amp;\u0026amp;x\u0026lt;XX \u0026amp;\u0026amp; y\u0026gt;=0\u0026amp;\u0026amp;y\u0026lt;YY \u0026amp;\u0026amp; z\u0026gt;=0\u0026amp;\u0026amp;z\u0026lt;ZZ){ if(space[x][y][z]==1){ return 1; }else if(space[x][y][z]==0){ Cube c; c.xyz[0]=x; c.xyz[1]=y; c.xyz[2]=z; temp.push(c); } return 0; }else{ return -1; } } int bfs(int x,int y,int z){ Cube c; c.xyz[0]=x; c.xyz[1]=y; c.xyz[2]=z; temp.push(c); while(!temp.empty()){ c = temp.front();temp.pop(); x = c.xyz[0]; y = c.xyz[1]; z = c.xyz[2]; if(x\u0026gt;=0\u0026amp;\u0026amp;x\u0026lt;XX \u0026amp;\u0026amp; y\u0026gt;=0\u0026amp;\u0026amp;y\u0026lt;YY \u0026amp;\u0026amp; z\u0026gt;=0\u0026amp;\u0026amp;z\u0026lt;ZZ){ if(space[x][y][z]==0){ space[x][y][z] = 2; /* 走过了 */ int xs = value[0][x+1] - value[0][x]; int ys = value[1][y+1] - value[1][y]; int zs = value[2][z+1] - value[2][z]; V += xs * ys * zs; int res; res = check(x-1,y,z); S = S + res * ys*zs; // cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;V\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;S\u0026lt;\u0026lt;endl; res = check(x+1,y,z); S = S + res * ys*zs; // cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;V\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;S\u0026lt;\u0026lt;endl; res = check(x,y-1,z); S = S + res * xs*zs; // cout\u0026lt;\u0026lt;3\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;V\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;S\u0026lt;\u0026lt;endl; res = check(x,y+1,z); S = S + res * xs*zs; // cout\u0026lt;\u0026lt;4\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;V\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;S\u0026lt;\u0026lt;endl; res = check(x,y,z-1); S = S + res * xs*ys; // cout\u0026lt;\u0026lt;5\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;V\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;S\u0026lt;\u0026lt;endl; res = check(x,y,z+1); S = S + res * xs*ys; // cout\u0026lt;\u0026lt;6\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;V\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;S\u0026lt;\u0026lt;endl; } } } return 0; } int run(int x,int y,int z){ return bfs(x,y,z); } void clac(){ /* 从六个面开始过 */ for(int i=0;i\u0026lt;XX;i++){ for(int j=0;j\u0026lt;YY;j++){ run(i,j,0); run(i,j,ZZ-1); } } for(int i=0;i\u0026lt;XX;i++){ for(int k=0;k\u0026lt;ZZ;k++){ run(i,0,k); run(i,YY-1,k); } } for(int j=0;j\u0026lt;YY;j++){ for(int k=0;k\u0026lt;ZZ;k++){ run(0,j,k); run(XX-1,j,k); } } int sumX,sumY,sumZ; if(XX\u0026lt;0) sumX = 0; else sumX = value[0][XX]-value[0][0]; if(YY\u0026lt;0) sumY = 0; else sumY = value[1][YY]-value[1][0]; if(ZZ\u0026lt;0) sumZ = 0; else sumZ = value[2][ZZ]-value[2][0]; int sumS = (sumX * sumY + sumX * sumZ + sumY * sumZ) * 2; int sumV = sumX * sumY * sumZ; cout\u0026lt;\u0026lt;sumS + S\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;sumV-V\u0026lt;\u0026lt;endl; } void init(){ V=S=XX=YY=ZZ=0; cubeList.clear(); for(int i=0;i\u0026lt;3;i++){ site[i].clear(); value[i].clear(); } memset(space,0,sizeof(space)); } int main(){ int T; cin\u0026gt;\u0026gt;T; while(T--){ init(); int N; cin\u0026gt;\u0026gt;N; while(N-- \u0026gt; 0){ Cube b; int x,y,z,xs,ys,zs; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z\u0026gt;\u0026gt;xs\u0026gt;\u0026gt;ys\u0026gt;\u0026gt;zs; b.xyz[0] = x; b.xyz[1] = y; b.xyz[2] = z; b.sss[0] = xs; b.sss[1] = ys; b.sss[2] = zs; /* 存map */ site[0][x] = 0; site[1][y] = 0; site[2][z] = 0; site[0][x+xs] = 0; site[1][y+ys] = 0; site[2][z+zs] = 0; /* 存cube list */ cubeList.push_back(b); } /* map 赋下标, 因为先存到了map中,所以作为键的坐标值就已经是排好序的了 */ for(int i=0;i\u0026lt;3;i++){ map\u0026lt;int,int\u0026gt;::iterator iter; /* 第一面的方块用空白预先填充, 即用空白包裹雕塑一半 */ int n = 0; for(iter=site[i].begin(); iter!=site[i].end(); iter++){ /* index -\u0026gt; value */ value[i].push_back(iter-\u0026gt;first); /* value -\u0026gt; index */ iter-\u0026gt;second = n; n++; } } /* 单元格数, 比点数少一 */ XX = value[0].size()-1; YY = value[1].size()-1; ZZ = value[2].size()-1; /* space 涂色*/ for(int i=0;i\u0026lt;cubeList.size();i++){ /* 记录xyz 的开始和结束 的下标 */ int start[3]; int end[3]; for(int ii=0;ii\u0026lt;3;ii++){ start[ii] = getSetIndex(ii, cubeList[i].xyz[ii]); end[ii] = getSetIndex(ii, cubeList[i].xyz[ii] + cubeList[i].sss[ii]); } /* 涂色 */ for(int xi=start[0]; xi\u0026lt;end[0]; xi++){ for(int yi=start[1]; yi\u0026lt;end[1]; yi++){ for(int zi=start[2]; zi\u0026lt;end[2]; zi++){ space[xi][yi][zi] = 1; } } } } clac(); } return 0; } // AC at 2020/09/12 ps：这道题十分美妙。辗转波折，所幸做出，十分感谢。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-12171-sculpture%E9%9B%95%E5%A1%91-by-sucicada/","summary":"例题6-18 雕塑（Sculpture, ACM/ICPC NWERC 2008, UVa12171）\n某雕塑由n（n≤50）个边平行于坐标轴的长方体组成。每个长方体用6个整\n数x0，y0，z0，x，y，z表示（均为1～500的整数），其中x0为长方体的顶点中x坐标的最小\n值，x表示长方体在x方向的总长度。其他4个值类似定义。你的任务是统计这个雕像的体积\n和表面积。注意，雕塑内部可能会有密闭的空间，其体积应计算在总体积中，但从“外部”看\n不见的面不应计入表面积。雕塑可能会由多个连通块组成。\nSample Input\n2\n2\n1 2 3 3 4 5\n6 2 3 3 4 5\n7\n1 1 1 5 5 1\n1 1 10 5 5 1\n1 1 2 1 4 8\n2 1 2 4 1 8\n5 2 2 1 4 8\n1 5 2 4 1 8\n3 3 4 1 1 1","title":"UVA 12171 - Sculpture(雕塑) By SuCicada"},{"content":" 例题6-7 树的层次遍历（Trees on the level, Duke 1993, UVa 122）\n输入一棵二叉树，你的任务是按从上到下、从左到右的顺序输出各个结点的值。每个结\n点都按照从根结点到它的移动序列给出（L表示左，R表示右）。在输入中，每个结点的左\n括号和右括号之间没有空格，相邻结点之间用一个空格隔开。每棵树的输入用一对空括\n号“()”结束（这对括号本身不代表一个结点），如图6-3所示。\n图6-3 一棵二叉树\n注意，如果从根到某个叶结点的路径上有的结点没有在输入中给出，或者给出超过一\n次，应当输出-1。结点个数不超过256。\n样例输入：\n(11,LL) (7,LLL) (8,R)\n(5,) (4,L) (13,RL) (2,LLR) (1,RRR) (4,RR) ()\n(3,L) (4,R) ()\n样例输出：\n5 4 8 11 13 4 7 2 1\nnot complete\n本家地址\n祭出对象大法\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;sstream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; using namespace std; class Node{ public: int value; Node* left; Node* right; }; Node* queue[256]; void show(Node* root){ memset(queue,0,sizeof(queue)); int qbegin=0; int qend=0; int qlen = sizeof(queue)/sizeof(Node*); stringstream out; queue[qend] = root; qend = (qend+1) % qlen; while(qbegin!=qend){ Node* nownode = queue[qbegin]; // cout\u0026lt;\u0026lt;nownode-\u0026gt;value\u0026lt;\u0026lt;endl; if(nownode!=root) out\u0026lt;\u0026lt;\u0026#34; \u0026#34;; if(nownode-\u0026gt;value){ out\u0026lt;\u0026lt;nownode-\u0026gt;value; }else{ out.str(\u0026#34;not complete\u0026#34;); // cout\u0026lt;\u0026lt;\u0026#34;not complete\u0026#34;; break; } qbegin = (qbegin+1) % qlen; if(nownode-\u0026gt;left){ queue[qend] = nownode-\u0026gt;left; qend = (qend+1) % qlen; } if(nownode-\u0026gt;right){ queue[qend] = nownode-\u0026gt;right; qend = (qend+1) % qlen; } } cout\u0026lt;\u0026lt;out.str()\u0026lt;\u0026lt;endl; } int main() { string nodestr; int newtree = 1; Node* root; int badtree = 0; while (cin\u0026gt;\u0026gt;nodestr){ if(newtree == 1){ /* 新的树 */ newtree = 0; root = new Node(); // nownode = root; badtree = 0; } int comma = nodestr.find(\u0026#39;,\u0026#39;); if(comma == nodestr.npos){ /* 树木结束了,该输出结果了 */ if(badtree){ cout\u0026lt;\u0026lt;\u0026#34;not complete\u0026#34;\u0026lt;\u0026lt;endl; }else{ show(root); } newtree = 1; }else{ Node* nownode = root; if(!badtree){ int size = nodestr.size(); int n = atoi(nodestr.substr(1,comma-1).c_str()); for(int i=comma+1;i\u0026lt;size-1;i++){ Node** nextstep; if(nodestr[i] == \u0026#39;L\u0026#39;){ nextstep = \u0026amp;(nownode-\u0026gt;left); }else if(nodestr[i] == \u0026#39;R\u0026#39;){ nextstep = \u0026amp;(nownode-\u0026gt;right); } if(!(*nextstep)){ *nextstep = new Node(); } nownode = *nextstep; } // cout\u0026lt;\u0026lt;nodestr\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;comma\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;size\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;\u0026#34; \u0026#34;; // cout\u0026lt;\u0026lt;nownode\u0026lt;\u0026lt;\u0026#34; nownode-\u0026gt;value \u0026#34;\u0026lt;\u0026lt;nownode-\u0026gt;value\u0026lt;\u0026lt;\u0026#34; n \u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; if(nownode-\u0026gt;value){ badtree = 1; }else{ nownode-\u0026gt;value = n; } } } } return 0; } // AC at 2020/3/17 开始还债\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-122-trees-on-the-level-duke-1993-%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/","summary":"例题6-7 树的层次遍历（Trees on the level, Duke 1993, UVa 122）\n输入一棵二叉树，你的任务是按从上到下、从左到右的顺序输出各个结点的值。每个结\n点都按照从根结点到它的移动序列给出（L表示左，R表示右）。在输入中，每个结点的左\n括号和右括号之间没有空格，相邻结点之间用一个空格隔开。每棵树的输入用一对空括\n号“()”结束（这对括号本身不代表一个结点），如图6-3所示。\n图6-3 一棵二叉树\n注意，如果从根到某个叶结点的路径上有的结点没有在输入中给出，或者给出超过一\n次，应当输出-1。结点个数不超过256。\n样例输入：\n(11,LL) (7,LLL) (8,R)\n(5,) (4,L) (13,RL) (2,LLR) (1,RRR) (4,RR) ()\n(3,L) (4,R) ()\n样例输出：\n5 4 8 11 13 4 7 2 1\nnot complete\n本家地址\n祭出对象大法\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;sstream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; using namespace std; class Node{ public: int value; Node* left; Node* right; }; Node* queue[256]; void show(Node* root){ memset(queue,0,sizeof(queue)); int qbegin=0; int qend=0; int qlen = sizeof(queue)/sizeof(Node*); stringstream out; queue[qend] = root; qend = (qend+1) % qlen; while(qbegin!","title":"UVA 122 - Trees on the level, Duke 1993 (树的层次遍历)"},{"content":" 把前n（n≤10000）个整数顺次写在一起：123456789101112…数一数0～9各出现多少次\n（输出10个整数，分别是0，1，…，9出现的次数）。\nSample Input\n2\n3\n13\nSample Output\n0 1 1 1 0 0 0 0 0 0\n1 6 2 2 1 1 1 1 1 1\n（注：输出的最后一个数后面没有空格）\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=3666\u0026amp;mosmsg=Submission+received+with+ID+20469369\n//判断一个数各个位的数字，存于一个数组中，倒的来循环也无妨 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { int T; cin\u0026gt;\u0026gt;T; getchar(); while(T--) { int num[10]={0}; int N; cin\u0026gt;\u0026gt;N; getchar(); while(N--) { int ni=N+1; while(ni) { num[ni%10]++; ni/=10; } } for(int i=0;i\u0026lt;9;i++) cout\u0026lt;\u0026lt;num[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;num[9]\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/10 ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1225-digit-counting%E6%95%B0%E6%95%B0/","summary":" 把前n（n≤10000）个整数顺次写在一起：123456789101112…数一数0～9各出现多少次\n（输出10个整数，分别是0，1，…，9出现的次数）。\nSample Input\n2\n3\n13\nSample Output\n0 1 1 1 0 0 0 0 0 0\n1 6 2 2 1 1 1 1 1 1\n（注：输出的最后一个数后面没有空格）\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=3666\u0026amp;mosmsg=Submission+received+with+ID+20469369\n//判断一个数各个位的数字，存于一个数组中，倒的来循环也无妨 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { int T; cin\u0026gt;\u0026gt;T; getchar(); while(T--) { int num[10]={0}; int N; cin\u0026gt;\u0026gt;N; getchar(); while(N--) { int ni=N+1; while(ni) { num[ni%10]++; ni/=10; } } for(int i=0;i\u0026lt;9;i++) cout\u0026lt;\u0026lt;num[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;num[9]\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/10 ","title":"uva 1225 - Digit Counting（数数）"},{"content":" 正篇以及正确解题思路和代码参见 UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) by SuCicada 此篇为后日谈 要说为什么专门开一篇来记录想法呢，主要是因为想说的太多了。首先从UVA的提交记录上来看，上一次答题是在足足1年之前了。\n这么久以来都没有再好好做算法，感觉快要忘本了。而且出来之后脑子也不是那么灵光了，虽然更理性，但是却少了些抽象的想象力。\n再说这道题，一开始我根本不知道什么字典序，完全是打表暴力比对的。把前40位算出来那里都是没错的。\n但是之后我想的是：用map排个序，然后二分查找。但是这样会有问题，因为二分找到的可能并不是最小的，所以找到之后还需要分别找到同样匹配前缀的那一区域的数字，因为是map排过序的，所以他们都是挨着的。\n但是之后在极端痛苦了两个晚上之后，我放弃了这种做法，经过测试计算，发现我电脑中g++在一秒钟可以进行4亿次运算，假设有5万个40位数字需要比对，4亿除以5万除以40 有20万呢，或者保险点我们取个1000。（一直到当时我都以为这道题的时间限制是1秒）\n然后我就在死灰复燃的状态下在下2天晚上把位数比对写出了（暴力）。为了减少比对量，我打表了前3位，也就是记录下前三位的数字第一次出现的序数，而且这个序数是map中的序数，map中的序数和fibo的序数可是不同的。\n而且map不能随机读取，怎么办，我又创造了两个数组专门存放键和值。\n后来我还发现个位数的搜索起来比较慢，因为他们要暴力比对的数是最多的，所以我又用一个map来记录已经查找过的结果。\n我真的是要疯，一直到昨天晚上我把这套模型整通。本地一跑，通过，time测下来 1.2秒，我巨喜。提交，time limit exceeded。把udebug上的样例全部跑了一遍，没有超过1.5秒的。我随机生成各种5万个数的组合，2秒之内绝对能过。\n但是 time limit exceeded， time limit exceeded，time limit exceeded，time limit exceeded，time limit exceeded。\n”难道是表打的太小了？“我又将打表位数升到4，升到5。然而为什么更慢了。\n那会已经3点钟了，我感到生命力的衰减，在极度无望的情况下，我打开百度，UVA 12333，我真特么被这道题23333了，\n这道题考大数+字典树\n我惊住，一个新的窗子仿佛打开了，一查，全懂了，完全懂了。我缩在床上颤抖不已，脑子瞬间就明白了我该怎么做，但是身体已经无法支撑下去，为了能保持住自己的生命力。我艰难的进入睡眠。\n第二天我写，真的很快，因为我已经知道了，虽然遇到了oj离奇而严厉的 runtime error错误。但是我很冷静，因为我知道这个方法肯定是没错的，这条路一定是对的。就是这种知道目的的坚定。\n当Accepted出现在屏幕上，我想哭了。太痛苦了，太刺激了，太疯狂了。再加上17个小时没有进食带来的虚弱感让我恍惚，感觉我活下来了。\n劫后余生的感激之情。\n而现在已经5点怅然若失感时不时在席卷我，跨时两个星期，4个夜晚的崩溃，20余小时的挣扎，20多次的错误。我太弱了，我为我的弱小感到伤心，但是我又为我的成功感到高兴。\n算法拯救我，算法伤害我，算法摧残我，算法安慰我。\n我时尝为我的自艾感到痛苦。\n但是我害怕痛苦吗，不如说我正喜欢痛苦。\n附赠更快的却更错的代码：\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;iterator\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;iomanip\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; fibonacci(100005); map\u0026lt;string,int\u0026gt; fiboSorted; vector\u0026lt;string\u0026gt; fiboName(100005); vector\u0026lt;int\u0026gt; fiboIndex(100005); int limitSite = 52; string add(string a,string b){ int aLen = a.size()-1; int bLen = b.size()-1; int aSiteNum = a[limitSite\u0026gt;aLen?aLen:limitSite]; int bSiteNum = b[limitSite\u0026gt;bLen?bLen:limitSite]; int ten = 0; int newLen = bLen+1; // 新数长度,一位放头放0 int i = aLen-1; int j = bLen-1; if(aLen == bLen \u0026amp;\u0026amp; aSiteNum!=bSiteNum){ // 位数不等,并且数字已经取了部分了 i--; // 小的数扔一位 } string res(newLen+1,\u0026#39;0\u0026#39;); // 最后一位放位数(奇偶) int resSite = newLen-1; // 记录结果的当前位数 for(; j\u0026gt;=0; i--,j--){ int aa=\u0026#39;0\u0026#39;; if(i\u0026gt;=0){ aa = a[i]; } int r = aa-\u0026#39;0\u0026#39; + b[j]-\u0026#39;0\u0026#39; + ten; ten = r/10; res[resSite--] = r%10+\u0026#39;0\u0026#39;; // cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ten\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } // if(plusSite){ res[0] = ten+\u0026#39;0\u0026#39;; // } if(ten==0){ //不会进位 string result = res.substr(1,limitSite+1); result[result.size()-1] = bSiteNum; return result; }else{ // if(aSiteNum!=bSiteNum){ // 位数不等 string result = res.substr(0,limitSite+1); result[result.size()-1] = !(bSiteNum-\u0026#39;0\u0026#39;) +\u0026#39;0\u0026#39;; return result; } } vector\u0026lt;string\u0026gt; fibo(100005); // int find(string str,int fbegin,int fend); // map\u0026lt;int,map\u0026lt;int,map\u0026lt;int,int\u0026gt; \u0026gt; \u0026gt; dict; int dict[1004]; int presitename = 3; int find(string str){ int presitenum10 = pow(10,presitename); int threenum = 0;// = (name[0]-\u0026#39;0\u0026#39;)*100 + (name[1]-\u0026#39;0\u0026#39;)*10 + (name[2]-\u0026#39;0\u0026#39;); int len = str.size(); // 这个长度很重要 int nowSiteName = presitename; // min(len,presitename); // 考虑数字要更小的情况, 比如12 我们要存12的位置, 不能是120 for(int j=0;j\u0026lt;nowSiteName;j++){ if(len \u0026gt;= j+1){ // 加1是因为要比对数字字符长度 threenum += (str[j]-\u0026#39;0\u0026#39;) * pow(10,nowSiteName-1-j); } } int newSite = pow(10,presitename-min(len,presitename)); // 这个是为了确定查找的区间, 要使用的数量级和长度相关 // cout\u0026lt;\u0026lt;threenum\u0026lt;\u0026lt;endl; int index = dict[threenum]; int end = -1; int nextSite = threenum+newSite; if(dict[nextSite] == -1){ nextSite += 5* newSite; } // while((end == -1) \u0026amp;\u0026amp; (nextSite \u0026lt;= presitenum10)){ // 防止 dict下一位没有东西 // end = dict[nextSite]; // cout\u0026lt;\u0026lt;nextSite\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;dict[nextSite]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;end\u0026lt;\u0026lt;endl; // nextSite += newSite; // } if(nextSite \u0026gt; presitenum10){ end = 100001; }else{ end = dict[nextSite]; } // cout\u0026lt;\u0026lt;index\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;end\u0026lt;\u0026lt;endl; // 要找合适的,先从index开始一个一个数比较, // 一位一位的比,如果相同,就记录fibo序数,取小,一直比到不相等,跳出 int startSame = 0; int minFiboIndex = 100001; for(int i=index;i\u0026lt;end;i++){ if( str.size() \u0026lt;= fiboName[i].size()){ string fs = fiboName[i].substr(0,str.size()); // cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;str\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;fs\u0026lt;\u0026lt;endl; if(str == fs){ minFiboIndex = min(fiboIndex[i],minFiboIndex); startSame = 1; }else{ if(startSame == 1){ break; } } } } if(minFiboIndex == 100001){ minFiboIndex = -1; } return minFiboIndex; } map\u0026lt;string,int\u0026gt; answer; int run(){ fibonacci[0] = fibonacci[1] = \u0026#34;11\u0026#34;; fiboSorted[\u0026#34;1\u0026#34;] = 0; for(int i=2;i\u0026lt;=100000;i++){ fibonacci[i] = add(fibonacci[i-2],fibonacci[i-1]); string s = fibonacci[i].substr(0,fibonacci[i].size()-1); fiboSorted[s] = i; // cout\u0026lt;\u0026lt;fibonacci[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;fiboSorted[fibonacci[i]]\u0026lt;\u0026lt;endl; // cout\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; // cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;setw(limitSite+1)\u0026lt;\u0026lt;fibonacci[i].substr(0,fibonacci[i].size()-1)\u0026lt;\u0026lt;\u0026#34; \u0026#34;; // cout\u0026lt;\u0026lt;setw(4)\u0026lt;\u0026lt;fibonacci[i].substr(fibonacci[i].size()-1); // cout\u0026lt;\u0026lt;endl; // stirng aa = // cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;setw(4)\u0026lt;\u0026lt; // cin.get(); } // copy(fibonacci.begin(),fibonacci.end(),ostream_iterator\u0026lt;string\u0026gt;(cout,\u0026#34; |\\n\u0026#34;)); // cout\u0026lt;\u0026lt;fibonacci[99999]\u0026lt;\u0026lt;endl; // cout\u0026lt;\u0026lt;endl; memset(dict,-1,sizeof(dict)); int i=0; for(map\u0026lt;string,int\u0026gt;::iterator m = fiboSorted.begin();m!=fiboSorted.end();m++,i++){ // cout\u0026lt;\u0026lt;m-\u0026gt;first\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;m-\u0026gt;second\u0026lt;\u0026lt;endl; fiboName[i] = m-\u0026gt;first; fiboIndex[i] = m-\u0026gt;second; string name = m-\u0026gt;first; int index = i; int threenum = 0;// = (name[0]-\u0026#39;0\u0026#39;)*100 + (name[1]-\u0026#39;0\u0026#39;)*10 + (name[2]-\u0026#39;0\u0026#39;); int len = name.size(); // 这个长度很重要 int nowSiteName = presitename; // min(len,presitename); // 考虑数字要更小的情况, 比如12 我们要存12的位置, 不能是120 for(int j=0;j\u0026lt;nowSiteName;j++){ if(len \u0026gt;= j+1){ // 加1是因为要比对数字字符长度 threenum += (name[j]-\u0026#39;0\u0026#39;) * pow(10,nowSiteName-1-j); } } // cout\u0026lt;\u0026lt;threenum\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;dict[threenum]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;index\u0026lt;\u0026lt;endl; if(dict[threenum] == -1){ // 未记录 dict[threenum] = index; // 因为递增遍历 map 数列, 所以第一次填入的 map 序号肯定是最小的 } } // for(int i=0;i\u0026lt;sizeof(dict)/sizeof(int);i++){ // printf(\u0026#34;%03d %6d %s\\n \u0026#34;,i,dict[i],fiboName[dict[i]].c_str()); // // cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;dict[i]\u0026lt;\u0026lt;endl; // } // makedict(); // return 0; // int mapLen = i; int T; cin\u0026gt;\u0026gt;T; for(int i=0;i\u0026lt;T;i++){ string n; cin\u0026gt;\u0026gt;n; int res; if(answer.count(n)){ res = answer[n]; }else{ res = find(n); answer[n] = res; } printf(\u0026#34;Case #%d: %d\\n\u0026#34;, i+1, res); // cout\u0026lt;\u0026lt;\u0026#34;find(n)\u0026lt;\u0026lt;endl; // int res = find(n,0,mapLen); // cout\u0026lt;\u0026lt;fiboIndex[res]\u0026lt;\u0026lt;endl; } // cout\u0026lt;\u0026lt;fiboSorted.size()\u0026lt;\u0026lt;endl; // cout\u0026lt;\u0026lt;(fiboSorted.begin()+1)-\u0026gt;first\u0026lt;\u0026lt;endl; } int main() { run(); return 0; } ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-12333-revenge-of-fibonacci-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%9A%84%E5%A4%8D%E4%BB%87-%E5%90%8E%E6%97%A5%E8%B0%88by-sucicada/","summary":"正篇以及正确解题思路和代码参见 UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) by SuCicada 此篇为后日谈 要说为什么专门开一篇来记录想法呢，主要是因为想说的太多了。首先从UVA的提交记录上来看，上一次答题是在足足1年之前了。\n这么久以来都没有再好好做算法，感觉快要忘本了。而且出来之后脑子也不是那么灵光了，虽然更理性，但是却少了些抽象的想象力。\n再说这道题，一开始我根本不知道什么字典序，完全是打表暴力比对的。把前40位算出来那里都是没错的。\n但是之后我想的是：用map排个序，然后二分查找。但是这样会有问题，因为二分找到的可能并不是最小的，所以找到之后还需要分别找到同样匹配前缀的那一区域的数字，因为是map排过序的，所以他们都是挨着的。\n但是之后在极端痛苦了两个晚上之后，我放弃了这种做法，经过测试计算，发现我电脑中g++在一秒钟可以进行4亿次运算，假设有5万个40位数字需要比对，4亿除以5万除以40 有20万呢，或者保险点我们取个1000。（一直到当时我都以为这道题的时间限制是1秒）\n然后我就在死灰复燃的状态下在下2天晚上把位数比对写出了（暴力）。为了减少比对量，我打表了前3位，也就是记录下前三位的数字第一次出现的序数，而且这个序数是map中的序数，map中的序数和fibo的序数可是不同的。\n而且map不能随机读取，怎么办，我又创造了两个数组专门存放键和值。\n后来我还发现个位数的搜索起来比较慢，因为他们要暴力比对的数是最多的，所以我又用一个map来记录已经查找过的结果。\n我真的是要疯，一直到昨天晚上我把这套模型整通。本地一跑，通过，time测下来 1.2秒，我巨喜。提交，time limit exceeded。把udebug上的样例全部跑了一遍，没有超过1.5秒的。我随机生成各种5万个数的组合，2秒之内绝对能过。\n但是 time limit exceeded， time limit exceeded，time limit exceeded，time limit exceeded，time limit exceeded。\n”难道是表打的太小了？“我又将打表位数升到4，升到5。然而为什么更慢了。\n那会已经3点钟了，我感到生命力的衰减，在极度无望的情况下，我打开百度，UVA 12333，我真特么被这道题23333了，\n这道题考大数+字典树\n我惊住，一个新的窗子仿佛打开了，一查，全懂了，完全懂了。我缩在床上颤抖不已，脑子瞬间就明白了我该怎么做，但是身体已经无法支撑下去，为了能保持住自己的生命力。我艰难的进入睡眠。\n第二天我写，真的很快，因为我已经知道了，虽然遇到了oj离奇而严厉的 runtime error错误。但是我很冷静，因为我知道这个方法肯定是没错的，这条路一定是对的。就是这种知道目的的坚定。\n当Accepted出现在屏幕上，我想哭了。太痛苦了，太刺激了，太疯狂了。再加上17个小时没有进食带来的虚弱感让我恍惚，感觉我活下来了。\n劫后余生的感激之情。\n而现在已经5点怅然若失感时不时在席卷我，跨时两个星期，4个夜晚的崩溃，20余小时的挣扎，20多次的错误。我太弱了，我为我的弱小感到伤心，但是我又为我的成功感到高兴。\n算法拯救我，算法伤害我，算法摧残我，算法安慰我。\n我时尝为我的自艾感到痛苦。\n但是我害怕痛苦吗，不如说我正喜欢痛苦。\n附赠更快的却更错的代码：\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;iterator\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;iomanip\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; vector\u0026lt;string\u0026gt; fibonacci(100005); map\u0026lt;string,int\u0026gt; fiboSorted; vector\u0026lt;string\u0026gt; fiboName(100005); vector\u0026lt;int\u0026gt; fiboIndex(100005); int limitSite = 52; string add(string a,string b){ int aLen = a.","title":"UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) 【后日谈】by SuCicada"},{"content":" 合适的思路 大数加法 字典树 代码 注意点 附录 后日谈 习题5-15 Fibonacci的复仇（Revenge of Fibonacci, ACM/ICPC Shanghai 2011,\nUVa12333）\nFibonacci数的定义为：F(0)=F(1)=1，然后从F(2)开始，F(i)=F(i-1)+F(i-2)。例如，前10\n项Fibonacci数分别为1, 1, 2, 3, 5, 8, 13, 21, 34, 55……\n有一天晚上，你梦到了Fibonacci，它告诉你一个有趣的Fibonacci数。醒来以后，你只记\n得了它的开头几个数字。你的任务是找出以它开头的最小Fibonacci数的序号。例如以12开头\n的最小Fibonacci数是F(25)。输入不超过40个数字，输出满足条件的序号。\n如果序号小于100000的Fibonacci数均不满足条件，输出-1。\n提示：本题有一定效率要求。如果高精度代码比较慢，可能会超时。\n原题链接 合适的思路 首先想我们该怎么样能匹配前缀，首先我们不知道完整的数字是什么，所以我们要先得到符合要求的数字数据集。\n然后将这些数据集放入字典树中\n所以我们要做的就是\n使用大数加法技巧，计算前100000个fibonacci 将每一个fibo数存入字典树中 大数加法 首先先做大数加法，使用字符串存储数字，两个字符串（数字）从最后一位即个位开始一位一位加。\n问题在于：\n100000个fibo数字，到后期位数是相当恐怖的，测试时发现第10万个数字有足足2万多位。这会造成在运算时时间和空间的非常糟糕的消耗。\n所以我们就可以遵从题意，只关心前40位，我们只截取每个数字的前面一部分做计算。这就要引出第2个和第3个问题。 如果我们使用40位，不论后面多少位，就把第40位当作个位。这会产生一个误差的问题。 比如两个数字 11001 和88999，如果我们只取他们的前2位算出来下一个数的前2位是99，但是实际上下一个数的前2位是10。这就是误差。 在解决第1个问题的时候，我们需要考虑数字进位的情况，因为我们只能看到数字的前一部分，不知道两个相加的数字是否位数相等，比如1234和345相加，假设取前2位，那么我们只能看到12和34，这样直接相加是不对的。 解决\n问题:3：先解决位数问题，我们可以将位数记录在字符串中，比如加入一个最后一位专门用来放位数。但是这样我们只能放256个无符号数字（因为使用char型元素存储）。那么换个思路，因为我们的问题在于两个数字位数不等，而不是位数究竟多少，所以可以只记录位数的奇偶即可。\n（另：其他办法，因为是Fibo数，位数不等的情况下，后一个数是大的数字，位数肯定多，而且第一位肯定是1，可以用这些关键点来解决） 问题:2：为了解决误差问题，我们就不能只选取前40位，那么应该选几位呢，经过测试发现最小能保证前40位没有问题的位数是52，测试方法见附录。\n不过要是不能测试的时候可以以10位为单位扩大范围，反正50和60位的差距远比50和2万的差距小。 字典树 每一个结点中存有\n从根节点到此结点的最小的Fibo序数，即最小前缀数字。 一个map，存有下一位的数字到下一位所在的结点的位置映射关系。 结点之间的关系如下图\n在存储的时候，存入的字符串在经过每一个结点的时候，都要比一下这个结点中存储的minIndex（FIbo最小前缀序号），并将其替换成两者中更小的。\n这样就能保证按照字典树的脉络寻找，寻找到的结点中的序号，一定是前缀数所在的最小的Fibo序号。\n注意点 不知道现在的UVA 编译器是怎么回事，我定义的 int型返回值函数没有给返回值，返回判我 Runtime error。我一开始压根不明觉厉，一行一行注释，然后一次次提交看看哪部分代码没有才会不报 re，以此来判断问题出在哪部分。光是这样就提交了十几次。\n我愿称之为绝活。\n在 线 O J ，现 场 调 试。\n代码 #include\u0026lt;iostream\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; class Site{ public: int minIndex; // 到目前这个结点为止的最小序数 map\u0026lt;char,Site*\u0026gt; next; // 下一个位们的 位对应结点 }; Site root; int limitSite = 52; // 选取的Fibo数的前置位数数，这个数能保证前40位的准确 void putTree(string a,int index){ int len = a.size(); Site* front = \u0026amp;root; for(int i=0;i\u0026lt;len;i++){ // 开始一位一位找, 每一位都需要 // 1. 比较树中有没有结点, 没有就new一个,把自己加上(还有序数),然后记录下一个指针,并把自己给了上一个指针, // 有则比较序数, 换成小的 char c = a[i]; if(!(front-\u0026gt;next).count(c)){ // 如果没有 Site* newsite = new Site(); // 手动申请空间, 不然函数结束后就会被清理 newsite-\u0026gt;minIndex = index; (front-\u0026gt;next)[c] = newsite; }else{ (front-\u0026gt;next)[c]-\u0026gt;minIndex = min((front-\u0026gt;next)[c]-\u0026gt;minIndex, index); } front = (front-\u0026gt;next)[c]; // 跳到下一个结点(位) } } int find(string str){ int len = str.size(); Site* front = \u0026amp;root; for(int i=0;i\u0026lt;len;i++){ // 一位一位找, 如果有一位没有找到, 那说明树中没有这个前缀, 返回-1 // 一直找到最后一位, 这最后一位所在的结点上的值就是要的 char c = str[i]; if(!(front-\u0026gt;next).count(c)){ // 如果没有 return -1; } front = (front-\u0026gt;next)[c]; // 跳到下一个结点(位) } // 没有位了,所以上一个结点就是最后一位所在结点 return front-\u0026gt;minIndex; } string add(string a,string b){ int aLen = a.size()-1; // 数长 int bLen = b.size()-1; int alastSite = min(limitSite, aLen); int blastSite = min(limitSite, bLen); int aSiteNum = a[alastSite]; // 位数奇偶,从最后一位取得 int bSiteNum = b[blastSite]; int ten = 0; int newLen = bLen+1; // 新数长度,一位放头放0 int i = aLen-1; int j = bLen-1; if(aLen == bLen \u0026amp;\u0026amp; aSiteNum!=bSiteNum){ // 位数不等,并且数字已经取了部分了 i--; // 小的数扔一位 } string res(newLen+1,\u0026#39;0\u0026#39;); // 最后一位放位数(奇偶) int resSite = newLen-1; // 记录结果的当前位数 for(; j\u0026gt;=0; i--,j--){ int aa=\u0026#39;0\u0026#39;; if(i\u0026gt;=0){ aa = a[i]; } int r = aa-\u0026#39;0\u0026#39; + b[j]-\u0026#39;0\u0026#39; + ten; ten = r/10; res[resSite--] = r%10+\u0026#39;0\u0026#39;; } res[0] = ten+\u0026#39;0\u0026#39;; if(ten==0){ //不会进位 string result = res.substr(1,limitSite+1); result[result.size()-1] = bSiteNum; return result; }else{ string result = res.substr(0,limitSite); result[result.size()-1] = !(bSiteNum-\u0026#39;0\u0026#39;) +\u0026#39;0\u0026#39;; return result; } } int main(){ string a,b,c; a = \u0026#34;11\u0026#34;; b = \u0026#34;11\u0026#34;; c = \u0026#34;\u0026#34;; putTree(\u0026#34;1\u0026#34;,0); for(int i=2;i\u0026lt;100000;i++){ // 100000以内,不包括 c = add(a,b); a = b; b = c; string s = c.substr(0, min(40,(int)c.size()-1) ); putTree(s,i); } int T; cin\u0026gt;\u0026gt;T; for(int i=0;i\u0026lt;T;i++){ string n; cin\u0026gt;\u0026gt;n; int res; printf(\u0026#34;Case #%d: %d\\n\u0026#34;, i+1, find(n)); } return 0; } // AC at 2020/3/7 13:00 附录 解决位数选取部分导致的误差使用的测试方法\n先生成完整的Fibo数，10万位，数据文件有100MB了。然后设置limitSite，将结果输出到文件中。然后使用脚本将两个文件一行一行即一个数一个数进行对比可知。 后日谈 UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) 【后日谈】by SuCicada\n唠叨几句\n居然写了120行，说明还不够精炼，我见有人80行。而且通过这次，我了解了一个事，\n我不是那些天才，可以自己发现发明算法。\n我只能积累前人创造的知识，\n有时一个知识点，一个关键词，一个方法，真的胜过自己乱搞。\n但是我明明在期间也想到了map套map的形如字典树的形式，为什么没有采用那种方法呢。我回忆，是因为不确定的方法，以及思维上的疏忽，我当时认为每一位都会有10个数字的分支，算下来就是10^40个分支了，这个数字吓到了我。导致我没有意识到，很多分支不会存在，最多的情况只会有10万个，而且实际上只有 3567669 个。\n为什么会这样呢，是对自己的不信任，是没有否定之否定。思维深度不够，不够严谨，不够周密，不够勇敢。如果能够敢于将错误的方法，思路也进行思考、分析。可能就不会这么痛苦了。\n但是我害怕痛苦吗。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-12333-revenge-of-fibonacci-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%9A%84%E5%A4%8D%E4%BB%87-by-sucicada/","summary":"合适的思路 大数加法 字典树 代码 注意点 附录 后日谈 习题5-15 Fibonacci的复仇（Revenge of Fibonacci, ACM/ICPC Shanghai 2011,\nUVa12333）\nFibonacci数的定义为：F(0)=F(1)=1，然后从F(2)开始，F(i)=F(i-1)+F(i-2)。例如，前10\n项Fibonacci数分别为1, 1, 2, 3, 5, 8, 13, 21, 34, 55……\n有一天晚上，你梦到了Fibonacci，它告诉你一个有趣的Fibonacci数。醒来以后，你只记\n得了它的开头几个数字。你的任务是找出以它开头的最小Fibonacci数的序号。例如以12开头\n的最小Fibonacci数是F(25)。输入不超过40个数字，输出满足条件的序号。\n如果序号小于100000的Fibonacci数均不满足条件，输出-1。\n提示：本题有一定效率要求。如果高精度代码比较慢，可能会超时。\n原题链接 合适的思路 首先想我们该怎么样能匹配前缀，首先我们不知道完整的数字是什么，所以我们要先得到符合要求的数字数据集。\n然后将这些数据集放入字典树中\n所以我们要做的就是\n使用大数加法技巧，计算前100000个fibonacci 将每一个fibo数存入字典树中 大数加法 首先先做大数加法，使用字符串存储数字，两个字符串（数字）从最后一位即个位开始一位一位加。\n问题在于：\n100000个fibo数字，到后期位数是相当恐怖的，测试时发现第10万个数字有足足2万多位。这会造成在运算时时间和空间的非常糟糕的消耗。\n所以我们就可以遵从题意，只关心前40位，我们只截取每个数字的前面一部分做计算。这就要引出第2个和第3个问题。 如果我们使用40位，不论后面多少位，就把第40位当作个位。这会产生一个误差的问题。 比如两个数字 11001 和88999，如果我们只取他们的前2位算出来下一个数的前2位是99，但是实际上下一个数的前2位是10。这就是误差。 在解决第1个问题的时候，我们需要考虑数字进位的情况，因为我们只能看到数字的前一部分，不知道两个相加的数字是否位数相等，比如1234和345相加，假设取前2位，那么我们只能看到12和34，这样直接相加是不对的。 解决\n问题:3：先解决位数问题，我们可以将位数记录在字符串中，比如加入一个最后一位专门用来放位数。但是这样我们只能放256个无符号数字（因为使用char型元素存储）。那么换个思路，因为我们的问题在于两个数字位数不等，而不是位数究竟多少，所以可以只记录位数的奇偶即可。\n（另：其他办法，因为是Fibo数，位数不等的情况下，后一个数是大的数字，位数肯定多，而且第一位肯定是1，可以用这些关键点来解决） 问题:2：为了解决误差问题，我们就不能只选取前40位，那么应该选几位呢，经过测试发现最小能保证前40位没有问题的位数是52，测试方法见附录。\n不过要是不能测试的时候可以以10位为单位扩大范围，反正50和60位的差距远比50和2万的差距小。 字典树 每一个结点中存有\n从根节点到此结点的最小的Fibo序数，即最小前缀数字。 一个map，存有下一位的数字到下一位所在的结点的位置映射关系。 结点之间的关系如下图\n在存储的时候，存入的字符串在经过每一个结点的时候，都要比一下这个结点中存储的minIndex（FIbo最小前缀序号），并将其替换成两者中更小的。\n这样就能保证按照字典树的脉络寻找，寻找到的结点中的序号，一定是前缀数所在的最小的Fibo序号。\n注意点 不知道现在的UVA 编译器是怎么回事，我定义的 int型返回值函数没有给返回值，返回判我 Runtime error。我一开始压根不明觉厉，一行一行注释，然后一次次提交看看哪部分代码没有才会不报 re，以此来判断问题出在哪部分。光是这样就提交了十几次。\n我愿称之为绝活。\n在 线 O J ，现 场 调 试。","title":"UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) by SuCicada"},{"content":" 例题4-3 救济金发放（The Dole Queue, UVa 133）\nn(n\u0026lt;20)个人站成一圈，逆时针编号为1～n。有两个官员，A从1开始逆时针数，B从n开\n始顺时针数。在每一轮中，官员A数k个就停下来，官员B数m个就停下来（注意有可能两个\n官员停在同一个人上）。接下来被官员选中的人（1个或者2个）离开队伍。\n输入n，k，m输出每轮里被选中的人的编号（如果有两个人，先输出被A选中的）。例\n如，n=10，k=4，m=3，输出为4 8, 9 5, 3 1, 2 6, 10, 7。注意：输出的每个数应当恰好占3格。（即setw(3)）\nSample Input\n10 4 3\n0 0 0\nSample Output\n␣␣4␣␣8,␣␣9␣␣5,␣␣3␣␣1,␣␣2␣␣6,␣10,␣␣7\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=832\u0026amp;page=show_problem\u0026amp;problem=69\n有一个数组来表示队列里的人，然后分别用两个循环，从头和尾开始依次过，并且记录下每一轮最后的落脚点，在下一轮中就当做是起始点了。点出来的人的位置可以直接用0代替。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;iomanip\u0026gt; using namespace std; int dole[25]; int n,a,b; int cycle(int j)//int n,int ab) { //int j=0; for(int i=0;i\u0026lt;a;i++) { do { j++; if(j==n) j=0; continue; } while(dole[j]==0); //j++; } return j; } int cycle2(int j)//int n,int b) { //int j=n-1; for(int i=0;i\u0026lt;b;i++) { do { j--; if(j\u0026lt;0) j=n-1; continue; } while(dole[j]==0); } //cout\u0026lt;\u0026lt;\u0026#34;j \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl; return j; } int main() { while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026amp;\u0026amp;(n!=0||a!=0||b!=0)) { int num=n;//num是还存在的人 for(int i=0;i\u0026lt;n;i++) dole[i]=i+1; int tempa=-1,tempb=n;// while(num) { tempa = cycle(tempa);//这里用引用更方便 tempb = cycle2(tempb); //cout\u0026lt;\u0026lt;tempa\u0026lt;\u0026lt;\u0026#34; aaa \u0026#34;\u0026lt;\u0026lt;tempb\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;dole[tempa]; if(tempa != tempb) { cout\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;dole[tempb]; num-=2; } else num--; dole[tempa]=dole[tempb]=0; if(num) cout\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; else cout\u0026lt;\u0026lt;endl; //for(int i=0;i\u0026lt;n;i++)cout\u0026lt;\u0026lt;dole[i];cout\u0026lt;\u0026lt;endl; } } return 0; } //AC at 2018/2/5 ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-133-the-dole-queue%E6%95%91%E6%B5%8E%E9%87%91%E7%82%B9%E4%BA%BA/","summary":"例题4-3 救济金发放（The Dole Queue, UVa 133）\nn(n\u0026lt;20)个人站成一圈，逆时针编号为1～n。有两个官员，A从1开始逆时针数，B从n开\n始顺时针数。在每一轮中，官员A数k个就停下来，官员B数m个就停下来（注意有可能两个\n官员停在同一个人上）。接下来被官员选中的人（1个或者2个）离开队伍。\n输入n，k，m输出每轮里被选中的人的编号（如果有两个人，先输出被A选中的）。例\n如，n=10，k=4，m=3，输出为4 8, 9 5, 3 1, 2 6, 10, 7。注意：输出的每个数应当恰好占3格。（即setw(3)）\nSample Input\n10 4 3\n0 0 0\nSample Output\n␣␣4␣␣8,␣␣9␣␣5,␣␣3␣␣1,␣␣2␣␣6,␣10,␣␣7\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=832\u0026amp;page=show_problem\u0026amp;problem=69\n有一个数组来表示队列里的人，然后分别用两个循环，从头和尾开始依次过，并且记录下每一轮最后的落脚点，在下一轮中就当做是起始点了。点出来的人的位置可以直接用0代替。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;iomanip\u0026gt; using namespace std; int dole[25]; int n,a,b; int cycle(int j)//int n,int ab) { //int j=0; for(int i=0;i\u0026lt;a;i++) { do { j++; if(j==n) j=0; continue; } while(dole[j]==0); //j++; } return j; } int cycle2(int j)//int n,int b) { //int j=n-1; for(int i=0;i\u0026lt;b;i++) { do { j--; if(j\u0026lt;0) j=n-1; continue; } while(dole[j]==0); } //cout\u0026lt;\u0026lt;\u0026#34;j \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl; return j; } int main() { while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026amp;\u0026amp;(n!","title":"uva 133 - The Dole Queue（救济金点人）"},{"content":" 例题4-1 古老的密码（Ancient Cipher, NEERC 2004, UVa1339）\n给定两个长度相同且不超过100的字符串，判断是否能把其中一个字符串的各个字母重\n排，然后对26个字母做一个一一映射，使得两个字符串相同。例如，JWPUDJSTVP重排后可\n以得到WJDUPSJPVT，然后把每个字母映射到它前一个字母（B-\u0026gt;A, C-\u0026gt;B, …, Z-\u0026gt;Y, A-\nZ），得到VICTORIOUS。输入两个字符串，输出YES或者NO。\nSample Input\nJWPUDJSTVP\nVICTORIOUS\nMAMA\nROME\nHAHA\nHEHE\nAAA\nAAA\nNEERCISTHEBEST\nSECRETMESSAGES\nSample Output\nYES\nNO\nYES\nYES\nNO\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=832\u0026amp;problem=4085\u0026amp;mosmsg=Submission+received+with+ID+20728592\n//1、我们只需要分别记录两个字串里出现的各个字母的数量， //2、然后从小到大或从大到小排序， //3、之后进行比较，如果两个字串对应，那么他们的字母数量表相同下标的元素值（代表字母的数量）也应该相同。 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; void ssqrt(int *str) { //cout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;26;i++) for(int j=i+1;j\u0026lt;26;j++) if(str[i]\u0026gt;str[j]) { int temp=str[i]; str[i]=str[j]; str[j]=temp; } //cout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; } int main() { string str,guess;//输入的两个字串 while(cin\u0026gt;\u0026gt;str\u0026gt;\u0026gt;guess) { int cha1[26]={0},cha2[26]={0};//分别记录两个字串里的各个字母的数量 for(int i=0;i\u0026lt;str.size();i++)//记录str里各个字母数量 { cha1[str[i]-\u0026#39;A\u0026#39;]++; cha2[guess[i]-\u0026#39;A\u0026#39;]++; } ssqrt(cha1);//对各个字母量排序 ssqrt(cha2); // for(int i=0;i\u0026lt;26;i++) // cout\u0026lt;\u0026lt;cha1[i]; // cout\u0026lt;\u0026lt;endl; // for(int i=0;i\u0026lt;26;i++) // cout\u0026lt;\u0026lt;cha2[i]; // cout\u0026lt;\u0026lt;endl; int iff=1; // cout\u0026lt;\u0026lt;\u0026#34;str \u0026#34;\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; // cout\u0026lt;\u0026lt;\u0026#34;guess \u0026#34;\u0026lt;\u0026lt;guess\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;26;i++)//比较排序后的字母量串 { if(cha1[i]!=cha2[i]) { iff=0; cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; break; } } if(iff==1) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } //AC at 2018/2/5 另：uva上，题目目录如果是蓝色的，代表那道题你提交过但没有Accepted。绿色则是通过，无色就是没有提交过。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1339-ancient-cipher%E6%98%A0%E5%B0%84%E5%AF%86%E7%A0%81/","summary":"例题4-1 古老的密码（Ancient Cipher, NEERC 2004, UVa1339）\n给定两个长度相同且不超过100的字符串，判断是否能把其中一个字符串的各个字母重\n排，然后对26个字母做一个一一映射，使得两个字符串相同。例如，JWPUDJSTVP重排后可\n以得到WJDUPSJPVT，然后把每个字母映射到它前一个字母（B-\u0026gt;A, C-\u0026gt;B, …, Z-\u0026gt;Y, A-\nZ），得到VICTORIOUS。输入两个字符串，输出YES或者NO。\nSample Input\nJWPUDJSTVP\nVICTORIOUS\nMAMA\nROME\nHAHA\nHEHE\nAAA\nAAA\nNEERCISTHEBEST\nSECRETMESSAGES\nSample Output\nYES\nNO\nYES\nYES\nNO\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=832\u0026amp;problem=4085\u0026amp;mosmsg=Submission+received+with+ID+20728592\n//1、我们只需要分别记录两个字串里出现的各个字母的数量， //2、然后从小到大或从大到小排序， //3、之后进行比较，如果两个字串对应，那么他们的字母数量表相同下标的元素值（代表字母的数量）也应该相同。 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; void ssqrt(int *str) { //cout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;26;i++) for(int j=i+1;j\u0026lt;26;j++) if(str[i]\u0026gt;str[j]) { int temp=str[i]; str[i]=str[j]; str[j]=temp; } //cout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; } int main() { string str,guess;//输入的两个字串 while(cin\u0026gt;\u0026gt;str\u0026gt;\u0026gt;guess) { int cha1[26]={0},cha2[26]={0};//分别记录两个字串里的各个字母的数量 for(int i=0;i\u0026lt;str.","title":"uva 1339 - Ancient Cipher（映射密码）"},{"content":" 习题3-7 DNA序列（DNA Consensus String, ACM/ICPC Seoul 2006, UVa1368）\n输入m个长度均为n的DNA序列，求一个DNA序列，到所有序列的总Hamming距离尽量\n小。两个等长字符串的Hamming距离等于字符不同的位置个数，例如，ACGT和GCGA的\nHamming距离为2（左数第1, 4个字符不同）。\n输入整数m和n（4≤m≤50, 4≤n≤1000），以及m个长度为n的DNA序列（只包含字母\nA，C，G，T），输出到m个序列的Hamming距离和最小的DNA序列和对应的距离。如有多\n解，要求为字典序最小的解。例如，对于下面5个DNA序列，最优解为TAAGATAC。\nTATGATAC\nTAAGCTAC\nAAAGATCC\nTGAGATAC\nTAAGATGT\n（汉明距离：算出 每列与 此列最多量的字符 不同的字符的个数 ，各个列相加）\nSample Input\n3\n5 8\nTATGATAC\nTAAGCTAC\nAAAGATCC\nTGAGATAC\nTAAGATGT\n4 10\nACGTACGTAC\nCCGTACGTAG\nGCGTACGTAT\nTCGTACGTAA\n6 10\nATGTTACCAT\nAAGTTACGAT\nAACAAAGCAA\nAAGTTACCTT\nAAGTTACCAA\nTACTTACCAA\nSample Output\nTAAGATAC\n7\nACGTACGTAA\n6\nAAGTTACCAA\n12\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=4114\u0026amp;mosmsg=Submission+received+with+ID+20524214\n//能解出来就是好的，有时候略微繁琐一些是在所难免的。 //It\u0026#39;s not necessary to tack such a toxic attitude around that it\u0026#39;s slightly difficult.（不必对其仿佛洪水猛兽。） #include\u0026lt;iostream\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; const int M=50,N=1000; char dna[M+5][N+5]; int acgt[4][N+5]; int main() { int T; cin\u0026gt;\u0026gt;T; while(T--) { int m,n; cin\u0026gt;\u0026gt;m\u0026gt;\u0026gt;n; int hamming=0; memset(acgt,0,sizeof(acgt)); for(int i=0;i\u0026lt;m;i++) { for(int j=0;j\u0026lt;n;j++) { cin\u0026gt;\u0026gt;dna[i][j]; switch(dna[i][j]) { case \u0026#39;A\u0026#39;:acgt[0][j]++;break;//注意字典序 case \u0026#39;C\u0026#39;:acgt[1][j]++;break; case \u0026#39;G\u0026#39;:acgt[2][j]++;break; case \u0026#39;T\u0026#39;:acgt[3][j]++;break; } } } for(int j=0;j\u0026lt;n;j++) { int maxx=acgt[0][j],nn=0; for(int j2=1;j2\u0026lt;4;j2++) { if(maxx\u0026lt;acgt[j2][j]) { maxx=acgt[j2][j]; nn=j2; } } switch(nn) { case 0:cout\u0026lt;\u0026lt;\u0026#39;A\u0026#39;;break; case 1:cout\u0026lt;\u0026lt;\u0026#39;C\u0026#39;;break; case 2:cout\u0026lt;\u0026lt;\u0026#39;G\u0026#39;;break; case 3:cout\u0026lt;\u0026lt;\u0026#39;T\u0026#39;;break; } hamming+=(m-acgt[nn][j]);//行数-最大字符数量=单列汉明 } cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;hamming\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/22 因为物理实验考试，昨日拖码一日。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1368-dna-consensus-stringdna%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/","summary":"习题3-7 DNA序列（DNA Consensus String, ACM/ICPC Seoul 2006, UVa1368）\n输入m个长度均为n的DNA序列，求一个DNA序列，到所有序列的总Hamming距离尽量\n小。两个等长字符串的Hamming距离等于字符不同的位置个数，例如，ACGT和GCGA的\nHamming距离为2（左数第1, 4个字符不同）。\n输入整数m和n（4≤m≤50, 4≤n≤1000），以及m个长度为n的DNA序列（只包含字母\nA，C，G，T），输出到m个序列的Hamming距离和最小的DNA序列和对应的距离。如有多\n解，要求为字典序最小的解。例如，对于下面5个DNA序列，最优解为TAAGATAC。\nTATGATAC\nTAAGCTAC\nAAAGATCC\nTGAGATAC\nTAAGATGT\n（汉明距离：算出 每列与 此列最多量的字符 不同的字符的个数 ，各个列相加）\nSample Input\n3\n5 8\nTATGATAC\nTAAGCTAC\nAAAGATCC\nTGAGATAC\nTAAGATGT\n4 10\nACGTACGTAC\nCCGTACGTAG\nGCGTACGTAT\nTCGTACGTAA\n6 10\nATGTTACCAT\nAAGTTACGAT\nAACAAAGCAA\nAAGTTACCTT\nAAGTTACCAA\nTACTTACCAA\nSample Output\nTAAGATAC\n7\nACGTACGTAA\n6\nAAGTTACCAA\n12\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=4114\u0026amp;mosmsg=Submission+received+with+ID+20524214\n//能解出来就是好的，有时候略微繁琐一些是在所难免的。 //It\u0026#39;s not necessary to tack such a toxic attitude around that it\u0026#39;s slightly difficult.","title":"uva 1368 - DNA Consensus String（DNA汉明距离）"},{"content":" 例题5-4 反片语（Ananagrams，Uva 156）\n输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文\n本中的另外一个单词。 在判断是否满足条件时，字母不分大小写，但在输出时应保留输入中\n的大小写，按字典序进行排列（所有大写字母在所有小写字母的前面）。\nSample Input\nladder came tape soon leader acme RIDE lone Dreis peat\nScAlE orb eye Rides dealer NotE derail LaCeS drIed\nnoel dire Disk mace Rob dries\n#\nSample Output\nDisk\nNotE\nderail\ndrIed\neye\nladder\nsoon\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=835\u0026amp;problem=92\u0026amp;mosmsg=Submission+received+with+ID+22713249\n思路和书上的一样, 先把每次的单词变成小写, 然后将其存入map的键, 值就是原单词.\n如果是重复的单词, 那么就把值变成空的.\n最后判断 map 里每一个迭代对象的值是不是空就行了\n将不是空的结果存入一个set, set自动排序, 然后再将set遍历输出即可\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;set\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; string lower(string s){ string re; for(int i=0;i\u0026lt;s.size();i++){ re += s[i]\u0026gt;=\u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[i]\u0026lt;=\u0026#39;z\u0026#39; ? s[i] : s[i] - \u0026#39;A\u0026#39; + \u0026#39;a\u0026#39;; } return re; } int main() { map\u0026lt;string, string\u0026gt; dict; string word,temp; while(cin\u0026gt;\u0026gt;word \u0026amp;\u0026amp; word != \u0026#34;#\u0026#34;){ // cout\u0026lt;\u0026lt;word\u0026lt;\u0026lt;endl; temp = lower(word); // cout\u0026lt;\u0026lt;\u0026#34;lower \u0026#34;\u0026lt;\u0026lt;temp\u0026lt;\u0026lt;endl; sort(temp.begin(), temp.end()); // cout\u0026lt;\u0026lt;\u0026#34;--\u0026#34;\u0026lt;\u0026lt;word\u0026lt;\u0026lt;endl; // cout\u0026lt;\u0026lt;\u0026#34;dict \u0026#34;\u0026lt;\u0026lt;dict[temp]\u0026lt;\u0026lt;endl; if(dict.count(temp) == 0){ //说明没有 dict[temp] = word; }else{ //有了我们就不要了 dict[temp] = \u0026#34;\u0026#34;; } } set\u0026lt;string\u0026gt; res; map\u0026lt;string, string\u0026gt;::iterator i = dict.begin(); for(;i!=dict.end();i++){ if((*i).second != \u0026#34;\u0026#34;){ // cout\u0026lt;\u0026lt;(*i).second\u0026lt;\u0026lt;endl; res.insert((*i).second); } } for(set\u0026lt;string\u0026gt;::iterator i = res.begin(); i != res.end(); i++){ cout\u0026lt;\u0026lt;(*i)\u0026lt;\u0026lt;endl; } return 0; } // AC at 2019/1/30 2019年第一道题, 还是例题, 距离上次做题已经有8个月以上了.\n和去年相比实在是太散漫了, 是因为要学的东西多了吗,是因为要做的事多了吗,这不是借口,是我太废物了. 好不容易活到这个等级, 不能gameover啊啊.\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-156-ananagrams-%E5%8F%8D%E7%89%87%E8%AF%AD/","summary":"例题5-4 反片语（Ananagrams，Uva 156）\n输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文\n本中的另外一个单词。 在判断是否满足条件时，字母不分大小写，但在输出时应保留输入中\n的大小写，按字典序进行排列（所有大写字母在所有小写字母的前面）。\nSample Input\nladder came tape soon leader acme RIDE lone Dreis peat\nScAlE orb eye Rides dealer NotE derail LaCeS drIed\nnoel dire Disk mace Rob dries\n#\nSample Output\nDisk\nNotE\nderail\ndrIed\neye\nladder\nsoon\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=835\u0026amp;problem=92\u0026amp;mosmsg=Submission+received+with+ID+22713249\n思路和书上的一样, 先把每次的单词变成小写, 然后将其存入map的键, 值就是原单词.\n如果是重复的单词, 那么就把值变成空的.\n最后判断 map 里每一个迭代对象的值是不是空就行了\n将不是空的结果存入一个set, set自动排序, 然后再将set遍历输出即可\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;set\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; string lower(string s){ string re; for(int i=0;i\u0026lt;s.","title":"UVA 156 - Ananagrams (反片语)"},{"content":" 例题6-19 自组合（Self-Assembly, ACM/ICPC World Finals 2013, UVa 1572）\n有n（n≤40000）种边上带标号的正方形。每条边上的标号要么为一个大写字母后面跟着一个加号或减号，要么为数字00。当且仅当两条边的字母相同且符号相反时，两条边能拼在一起（00不能和任何边拼在一起，包括另一条标号为00的边）。\n假设输入的每种正方形都有无穷多种，而且可以旋转和翻转，你的任务是判断能否组成一个无限大的结构。每条边要么悬空（不和任何边相邻），要么和一个上述可拼接的边相邻。如图6-17（a）所示是3个正方形，图6-17（b）所示边是它们组成的一个合法结构（但大小有限）。\nSample Input\n3\nA+00A+A+ 00B+D+A- B-C+00C+\n1\nK+K-Q+Q\nSample Output\nbounded\nunbounded\n本家地址\n提炼一下关键点：一共53种符号。方块数目很大，构造传统二维图会过大而超时。方块内部符号已知连通性。求方块间符号连通性。\n可以抽象为52个点（00去掉），已知连通性（方块内部，不互补符号），互补符号可连通，当一段方块能够重复连接，即能够无限，即在可能的通路中求是否存在环路。\n所以解决方案：使用dfs的方式，从一个符号开始，然后循环找方块内部的道路，找到之后，再递归走向下一个与其互补的符号。然后记录每一次递归通过的符号，即结点，当某一次递归走到了已经走过的符号结点上，那么就存在重复道路，即环路了。\n具体看注释\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; /* x -\u0026gt; y : inner */ /* y -\u0026gt; x : outer( + -) */ // /* A+B+C+D+...A-B-C-D- */ /* A+A-B+B-C+C-D+D-... */ int table[55][55]; /* 1: can go 2: has gone 用于减少计算数 */ int look[55]; /* 作为标记，锁一类。作为当前一次dfs中,这个点是否已经走过了 用于判断环路存在 */ int run[55]; int getIndex(char a,char b){ return (a-\u0026#39;A\u0026#39;)*2 + (b==\u0026#39;-\u0026#39;?1:0); } void show(); /* 考虑什么时候有回路 从一个口子出去, 经过几圈之后, 从另一个口子进来, 在内部又到了这个口子, 即重复路 */ int calc(int n){ if(run[n]==1){ return 1; } /* n开始了 */ run[n]=1; /* n没有进过 */ if(look[n]==1){ for(int i=0;i\u0026lt;52;i++){ /* 循环找内部路 */ if(table[n][i]==1) { /* 能走 */ /* 找到了, i为出口,即互补符号 */ int nextIn = i-1*(i%2*2-1); if(calc(nextIn)){ return 1; } } } look[n] = 2; } run[n] = 0; return 0; } int main(){ int T; while(cin\u0026gt;\u0026gt;T){ memset(table,0,sizeof(table)); memset(look,0,sizeof(look)); memset(run,0,sizeof(run)); string str; while(T--){ cin\u0026gt;\u0026gt;str; for(int i=0;i\u0026lt;8;i+=2){ if(str[i]!=\u0026#39;0\u0026#39;){ int xi = getIndex(str[i],str[i+1]); look[xi]=1; for(int j=0;j\u0026lt;8;j+=2){ if(i!=j \u0026amp;\u0026amp; str[j] !=\u0026#39;0\u0026#39;){ int yi = getIndex(str[j],str[j+1]); table[xi][yi]=1; } } } } } int yes=0; for(int i=0;i\u0026lt;52;i++){ if(look[i]==1){ int res = calc(i); if(res==1){ yes = 1; break; } } } if(yes){ cout\u0026lt;\u0026lt;\u0026#34;unbounded\u0026#34;\u0026lt;\u0026lt;endl; }else{ cout\u0026lt;\u0026lt;\u0026#34;bounded\u0026#34;\u0026lt;\u0026lt;endl; } } return 0; } // AC at 2020/09/13 ps：有时候写一种方法写不下去了，思路纠结住了，怎么改怎么不对，那么就抛弃这个扭曲的函数，重新开始整理思路，写一个新的同样功能的函数。\n这个题也求助于刘汝佳了，这个星期的状态实在太糟糕了。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1572-self-assembly%E8%87%AA%E7%BB%84%E5%90%88-by-sucicada/","summary":"例题6-19 自组合（Self-Assembly, ACM/ICPC World Finals 2013, UVa 1572）\n有n（n≤40000）种边上带标号的正方形。每条边上的标号要么为一个大写字母后面跟着一个加号或减号，要么为数字00。当且仅当两条边的字母相同且符号相反时，两条边能拼在一起（00不能和任何边拼在一起，包括另一条标号为00的边）。\n假设输入的每种正方形都有无穷多种，而且可以旋转和翻转，你的任务是判断能否组成一个无限大的结构。每条边要么悬空（不和任何边相邻），要么和一个上述可拼接的边相邻。如图6-17（a）所示是3个正方形，图6-17（b）所示边是它们组成的一个合法结构（但大小有限）。\nSample Input\n3\nA+00A+A+ 00B+D+A- B-C+00C+\n1\nK+K-Q+Q\nSample Output\nbounded\nunbounded\n本家地址\n提炼一下关键点：一共53种符号。方块数目很大，构造传统二维图会过大而超时。方块内部符号已知连通性。求方块间符号连通性。\n可以抽象为52个点（00去掉），已知连通性（方块内部，不互补符号），互补符号可连通，当一段方块能够重复连接，即能够无限，即在可能的通路中求是否存在环路。\n所以解决方案：使用dfs的方式，从一个符号开始，然后循环找方块内部的道路，找到之后，再递归走向下一个与其互补的符号。然后记录每一次递归通过的符号，即结点，当某一次递归走到了已经走过的符号结点上，那么就存在重复道路，即环路了。\n具体看注释\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; /* x -\u0026gt; y : inner */ /* y -\u0026gt; x : outer( + -) */ // /* A+B+C+D+...A-B-C-D- */ /* A+A-B+B-C+C-D+D-... */ int table[55][55]; /* 1: can go 2: has gone 用于减少计算数 */ int look[55]; /* 作为标记，锁一类。作为当前一次dfs中,这个点是否已经走过了 用于判断环路存在 */ int run[55]; int getIndex(char a,char b){ return (a-\u0026#39;A\u0026#39;)*2 + (b==\u0026#39;-\u0026#39;?","title":"UVA 1572 - Self-Assembly(自组合) By SuCicada"},{"content":" 长度为n的环状串有n种表示法，分别为从某\n个位置开始顺时针得到。例如，图3-4的环状串\n有10种表示：\nCGAGTCAGCT，GAGTCAGCTC，AGTCAGCTCG等。在这些表示法中，字典序最小的称\n为\u0026quot;最小表示\u0026quot;。\n输入一个长度为n（n≤100）的环状DNA串（只包含A、C、G、T这4种字符）的一种表\n示法，你的任务是输出该环状串的最小表示。例如，CTCC的最小表示是\nCCCT，CGAGTCAGCT的最小表示为AGCTCGAGTC。\nSample Input\n2\nCGAGTCAGCT\nCTCC\nSample Output\nAGCTCGAGTC\nCCCT\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=829\u0026amp;page=show_problem\u0026amp;problem=4459\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; int const N = 100; //比较从be1,和从be2开始的字串哪一个更小 int com(char *s,int be1,int be2) { int sl=strlen(s); for(int i=0;i\u0026lt;sl;i++) { //cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;(be1+i)%N\u0026lt;\u0026lt;endl; //cout\u0026lt;\u0026lt;s[(be1+i)%N]\u0026lt;\u0026lt;\u0026#34;_\u0026#34;\u0026lt;\u0026lt;s[(be2+i)%N]\u0026lt;\u0026lt;endl; if(s[(be1+i)%sl]\u0026gt;s[(be2+i)%sl]) return be2; if(s[(be1+i)%sl]\u0026lt;s[(be2+i)%sl]) return be1; } return be1; } char s[N+5]; int main() { // char acgt[4]=\u0026#34;ACGT\u0026#34;; int T=1; cin\u0026gt;\u0026gt;T; while(T--) { scanf(\u0026#34;%s\u0026#34;,s); int j=0; int be1=0,be2; for(int i=0;i\u0026lt;strlen(s);i++)//找最小的首字符给be1 { if(s[i]\u0026lt;s[be1]) { be1=i; } } //cout\u0026lt;\u0026lt;be1\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;strlen(s);i++)//在最小的首字符中 找最小的字串 { if(s[i]==s[be1]) { if(com(s,be1,i)==i) be1=i; } } for(int i=0;i\u0026lt;strlen(s);i++) cout\u0026lt;\u0026lt;s[(be1+i)%strlen(s)]; cout\u0026lt;\u0026lt;endl; } return 0; } ACat2017/12/9 ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1584-circular-sequence%E7%8E%AF%E7%8A%B6%E5%BA%8F%E5%88%97/","summary":" 长度为n的环状串有n种表示法，分别为从某\n个位置开始顺时针得到。例如，图3-4的环状串\n有10种表示：\nCGAGTCAGCT，GAGTCAGCTC，AGTCAGCTCG等。在这些表示法中，字典序最小的称\n为\u0026quot;最小表示\u0026quot;。\n输入一个长度为n（n≤100）的环状DNA串（只包含A、C、G、T这4种字符）的一种表\n示法，你的任务是输出该环状串的最小表示。例如，CTCC的最小表示是\nCCCT，CGAGTCAGCT的最小表示为AGCTCGAGTC。\nSample Input\n2\nCGAGTCAGCT\nCTCC\nSample Output\nAGCTCGAGTC\nCCCT\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=829\u0026amp;page=show_problem\u0026amp;problem=4459\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; int const N = 100; //比较从be1,和从be2开始的字串哪一个更小 int com(char *s,int be1,int be2) { int sl=strlen(s); for(int i=0;i\u0026lt;sl;i++) { //cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;(be1+i)%N\u0026lt;\u0026lt;endl; //cout\u0026lt;\u0026lt;s[(be1+i)%N]\u0026lt;\u0026lt;\u0026#34;_\u0026#34;\u0026lt;\u0026lt;s[(be2+i)%N]\u0026lt;\u0026lt;endl; if(s[(be1+i)%sl]\u0026gt;s[(be2+i)%sl]) return be2; if(s[(be1+i)%sl]\u0026lt;s[(be2+i)%sl]) return be1; } return be1; } char s[N+5]; int main() { // char acgt[4]=\u0026#34;ACGT\u0026#34;; int T=1; cin\u0026gt;\u0026gt;T; while(T--) { scanf(\u0026#34;%s\u0026#34;,s); int j=0; int be1=0,be2; for(int i=0;i\u0026lt;strlen(s);i++)//找最小的首字符给be1 { if(s[i]\u0026lt;s[be1]) { be1=i; } } //cout\u0026lt;\u0026lt;be1\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;strlen(s);i++)//在最小的首字符中 找最小的字串 { if(s[i]==s[be1]) { if(com(s,be1,i)==i) be1=i; } } for(int i=0;i\u0026lt;strlen(s);i++) cout\u0026lt;\u0026lt;s[(be1+i)%strlen(s)]; cout\u0026lt;\u0026lt;endl; } return 0; } ACat2017/12/9 ","title":"uva 1584 - Circular Sequence（环状序列）"},{"content":" 给出一个由O和X组成的串（长度为1～80），统计得分。每个O的得分为目前连续出现\n的O的个数，X的得分为0。例如，OOXXOXXOOO的得分为1+2+0+0+1+0+0+1+2+3。\nSample Input\n5\nOOXXOXXOOO\nOOXXOOXXOO\nOXOXOXOXOXOXOX\nOOOOOOOOOO\nOOOOXOOOOXOOOOX\nSample Output\n10\n9\n7\n55\n30\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=4460\u0026amp;mosmsg=Submission+received+with+ID+20465648\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { int T; cin\u0026gt;\u0026gt;T; getchar(); while(T--) { int sum=0; int o=1; int c; while((c=getchar())!=\u0026#39;\\n\u0026#39;) { if(c==\u0026#39;O\u0026#39;) { sum+=o; o++; } if(c==\u0026#39;X\u0026#39;) { o=1; } } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/9 ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1585-ancient-cipher-ox/","summary":" 给出一个由O和X组成的串（长度为1～80），统计得分。每个O的得分为目前连续出现\n的O的个数，X的得分为0。例如，OOXXOXXOOO的得分为1+2+0+0+1+0+0+1+2+3。\nSample Input\n5\nOOXXOXXOOO\nOOXXOOXXOO\nOXOXOXOXOXOXOX\nOOOOOOOOOO\nOOOOXOOOOXOOOOX\nSample Output\n10\n9\n7\n55\n30\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=4460\u0026amp;mosmsg=Submission+received+with+ID+20465648\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { int T; cin\u0026gt;\u0026gt;T; getchar(); while(T--) { int sum=0; int o=1; int c; while((c=getchar())!=\u0026#39;\\n\u0026#39;) { if(c==\u0026#39;O\u0026#39;) { sum+=o; o++; } if(c==\u0026#39;X\u0026#39;) { o=1; } } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/9 ","title":"uva 1585 - Ancient Cipher （OX）"},{"content":" 给出一种物质的分子式（不带括号），求分子量。本题中的分子式只包含4种原子，分\n别为C, H, O, N，原子量分别为12.01, 1.008, 16.00, 14.01（单位：g/mol）。例如，C6H5OH的\n分子量为94.108g/mol。\nSample Input\n4\nC\nC6H5OH\nNH2CH2COOH\nC12H22O11\nSample Output\n12.010\n94.108\n75.070\n342.296\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=4461\u0026amp;mosmsg=Submission+received+with+ID+20466109\n//通过判断下一个字符的类型来执行上一个原子的量计算 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cctype\u0026gt; using namespace std; int main()//两个变量，一个存原子量，一个存后面的数字 { int T; cin\u0026gt;\u0026gt;T; getchar(); while(T--) { int c; double sum=0,mol=0; int num=0; while((c=getchar())!=\u0026#39;\\n\u0026#39;) { if(isdigit(c)) { num=num*10+c-\u0026#39;0\u0026#39;; //sum+=mol*(c-\u0026#39;0\u0026#39;); //num=1; } else { if(num) { sum+=mol*num;//加前一个原子*数量 mol=num=0; } else { sum+=mol;//加前一个原子 } switch(c) { case \u0026#39;C\u0026#39;:mol=12.01;break; case \u0026#39;H\u0026#39;:mol=1.008;break; case \u0026#39;O\u0026#39;:mol=16.00;break; case \u0026#39;N\u0026#39;:mol=14.01;break; } //cout\u0026lt;\u0026lt;\u0026#34;mol \u0026#34;\u0026lt;\u0026lt;mol\u0026lt;\u0026lt;\u0026#34; num \u0026#34;\u0026lt;\u0026lt;num\u0026lt;\u0026lt;\u0026#34; sum \u0026#34;\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } } if(num==0) sum+=mol; else sum+=mol*num; printf(\u0026#34;%.3lf\\n\u0026#34;,sum); } return 0; } //AC at 2017/12/9 // hh23h // c mol num sum // h 1 0 0 // h 1 0 1 // 2 1 2 1 // 3 1 2+3*10 1 // h 1 0 1+23+1 // \\n 1 0 24+1 ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1586-molar-mass%E5%88%86%E5%AD%90%E9%87%8F/","summary":"给出一种物质的分子式（不带括号），求分子量。本题中的分子式只包含4种原子，分\n别为C, H, O, N，原子量分别为12.01, 1.008, 16.00, 14.01（单位：g/mol）。例如，C6H5OH的\n分子量为94.108g/mol。\nSample Input\n4\nC\nC6H5OH\nNH2CH2COOH\nC12H22O11\nSample Output\n12.010\n94.108\n75.070\n342.296\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=4461\u0026amp;mosmsg=Submission+received+with+ID+20466109\n//通过判断下一个字符的类型来执行上一个原子的量计算 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cctype\u0026gt; using namespace std; int main()//两个变量，一个存原子量，一个存后面的数字 { int T; cin\u0026gt;\u0026gt;T; getchar(); while(T--) { int c; double sum=0,mol=0; int num=0; while((c=getchar())!=\u0026#39;\\n\u0026#39;) { if(isdigit(c)) { num=num*10+c-\u0026#39;0\u0026#39;; //sum+=mol*(c-\u0026#39;0\u0026#39;); //num=1; } else { if(num) { sum+=mol*num;//加前一个原子*数量 mol=num=0; } else { sum+=mol;//加前一个原子 } switch(c) { case \u0026#39;C\u0026#39;:mol=12.01;break; case \u0026#39;H\u0026#39;:mol=1.","title":"uva 1586 - Molar mass（分子量）"},{"content":" 习题3-10 盒子（Box, ACM/ICPC NEERC 2004, UVa1587）\n给定6个矩形的长和宽wi和hi（1≤wi，hi≤1000），判断它们能否构成长方体的6个面。\nSample Input\n1345 2584\n2584 683\n2584 1345\n683 1345\n683 1345\n2584 683\n1234 4567\n1234 4567\n4567 4321\n4322 4567\n4321 1234\n4321 1234\nSample Output\nPOSSIBLE\nIMPOSSIBLE\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=4462\u0026amp;mosmsg=Submission+received+with+ID+20554313\n1、因为长方体都有三组含四条的边，我们先将三条不同的边长度用一个数组存起，在用一个数组存各个边在六组数据中分别出现的次数。\n2、输入的同时来进行存边，并记录下出现的正方形的个数（即输入的两条边相等）。\n3、六组输入完成后，判断是否属于以下情况\n（1）a 4 , b 4 ,c 4 ,正方面 0\n（2）a 8 , b 4 ,c 0 ,正方面 2\n（3）a 12 , b 0 ,c 0 ,正方面 6\n（a 4：a长度的边有4条）\n属于的则是长方形，这里就要注意长方形有三种类型\n#include\u0026lt;iostream\u0026gt; using namespace std; int main() { int a[2];//每组的两条边 while(cin\u0026gt;\u0026gt;a[0]\u0026gt;\u0026gt;a[1]) { int s[3]={0},n[3]={0};//边长，边数目 int ns6=6; int same=0; while(ns6--)//六个面 { if(ns6\u0026lt;5) cin\u0026gt;\u0026gt;a[0]\u0026gt;\u0026gt;a[1]; if(a[0]==a[1]) same++;//输入的正方形的个数 for(int j=0;j\u0026lt;2;j++) for(int i=0;i\u0026lt;3;i++) { if(s[i]==a[j])//如果长度和i边一样，则第i边出现的个数+1 { n[i]++; break; } else if(s[i]==0)//存入新边 { s[i]=a[j]; n[i]++; break; } } } // for(int i=0;i\u0026lt;3;i++) // cout\u0026lt;\u0026lt;\u0026#34;s \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;s[i]\u0026lt;\u0026lt;\u0026#34; |n \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;n[i]\u0026lt;\u0026lt;\u0026#34; same \u0026#34;\u0026lt;\u0026lt;same\u0026lt;\u0026lt;endl; if((n[0]==4\u0026amp;\u0026amp;n[1]==4\u0026amp;\u0026amp;n[2]==4\u0026amp;\u0026amp;same==0)|| ((n[0]==4||n[0]==8)\u0026amp;\u0026amp;n[2]==0\u0026amp;\u0026amp;same==2)||//8并不一定是在n[0] (n[0]==12\u0026amp;\u0026amp;same==6)) cout\u0026lt;\u0026lt;\u0026#34;POSSIBLE\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;IMPOSSIBLE\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/31 （题外话：题不难，多亏uva用户提供的样例，不然就难以发现最后一个代码注释所说的错误。）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1587-box%E7%9B%92%E5%AD%90/","summary":"习题3-10 盒子（Box, ACM/ICPC NEERC 2004, UVa1587）\n给定6个矩形的长和宽wi和hi（1≤wi，hi≤1000），判断它们能否构成长方体的6个面。\nSample Input\n1345 2584\n2584 683\n2584 1345\n683 1345\n683 1345\n2584 683\n1234 4567\n1234 4567\n4567 4321\n4322 4567\n4321 1234\n4321 1234\nSample Output\nPOSSIBLE\nIMPOSSIBLE\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=4462\u0026amp;mosmsg=Submission+received+with+ID+20554313\n1、因为长方体都有三组含四条的边，我们先将三条不同的边长度用一个数组存起，在用一个数组存各个边在六组数据中分别出现的次数。\n2、输入的同时来进行存边，并记录下出现的正方形的个数（即输入的两条边相等）。\n3、六组输入完成后，判断是否属于以下情况\n（1）a 4 , b 4 ,c 4 ,正方面 0\n（2）a 8 , b 4 ,c 0 ,正方面 2\n（3）a 12 , b 0 ,c 0 ,正方面 6\n（a 4：a长度的边有4条）","title":"uva 1587 - Box（盒子）"},{"content":" 习题3-11 换低挡装置（Kickdown, ACM/ICPC NEERC 2006, UVa1588）\n给出两个长度分别为n1，n2（n1，n2≤100）且每列高度只为1或2的长条。需要将它们放\n入一个高度为3的容器（如图3-8所示），问能够容纳它们的最短容器长度。 Sample Input\n2112112112\n2212112\n12121212\n21212121\n2211221122\n21212\nSample Output\n10\n8\n15\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=4463\u0026amp;mosmsg=Submission+received+with+ID+20560401\n用两个字符串数组分别存这两个块，一块作为不动的，另一块在其上移动，判断当前移动到的位置是不是和下块契合（用循环依次比较各个位置），若不是则继续移动到下一位。\n需要注意的是，最短的契合方案有可能你漏想了，下面一共是三种可能的情况。所以我用一个函数来将两个块换了位置后又移动了一次。\n//三种情况：bbbbb aa (|a|:ab重叠 //1.短块在长块里(bb|aa|b) //2.短块头在长块里（外），短块尾巴超出长块尾(bbbb|a|a) //3.长块头在短块尾（外），长块尾巴超出短块尾(a|a|bbbb) //不要忘记第三种情况，有时最短空间就是出自3 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; const int N = 100; //int kick1[N+5],kick2[N+5]; int kickdown(string k1,string k2)//定k1，移k2 { //cout\u0026lt;\u0026lt;k1.size()\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;k2.size()\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;k1.size();i++) { int ii=i,j=0;//i就是大小块契合的那一位 //cout\u0026lt;\u0026lt;ii\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl; while((k1[ii]-\u0026#39;0\u0026#39;+k2[j]-\u0026#39;0\u0026#39;)\u0026lt;=3\u0026amp;\u0026amp;(j\u0026lt;k2.size()\u0026amp;\u0026amp;ii\u0026lt;k1.size()))//若当前位不匹配则进行for到下一位 { //cout\u0026lt;\u0026lt;\u0026#34;k1 ii \u0026#34;\u0026lt;\u0026lt;ii\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;k1[ii]\u0026lt;\u0026lt;\u0026#34; | k2 j\u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;k2[j]\u0026lt;\u0026lt;endl; ii++; j++; } if(j==k2.size()||ii==k1.size())//若是寿终正寝（即循环到块尾了） { //cout\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; i \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return (i+k2.size())\u0026gt;=k1.size()?(i+k2.size()):k1.size(); //若i+k2.size()比k1（长块）的长度还短，那么所需长度就直接是k1长度了 /*下面是通俗代码*/ //space=i+k2.size(); //if(space\u0026lt;k1.size()) // space=k1.size(); //break; } } return k1.size()+k2.size();//若没有契合处，只能接到后面了 } int main() { string k1,k2;//咱们要k1\u0026gt;k2 while(cin\u0026gt;\u0026gt;k1\u0026gt;\u0026gt;k2) { int space1=0,space2=0; space1=kickdown(k1,k2); space2=kickdown(k2,k1); //cout\u0026lt;\u0026lt;\u0026#34;s1 \u0026#34;\u0026lt;\u0026lt;space1\u0026lt;\u0026lt;\u0026#34; s2 \u0026#34;\u0026lt;\u0026lt;space2\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;(space1\u0026lt;space2?space1:space2)\u0026lt;\u0026lt;endl; } return 0; } //AC at 2018/1/2 一开始我被题目中的例子所蒙蔽，想的是固定长的块，移动短的块，最后算下来和网友给的样例比总是有一些要大上几个数。那人一口气给了500+对数十上百个元素的12字符串，想用cout断点的方式看出一些端倪是十分困难的。这道题花了两天吧，太糟。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1588-kickdown%E6%8D%A2%E4%BD%8E%E6%8C%A1%E8%A3%85%E7%BD%AE/","summary":"习题3-11 换低挡装置（Kickdown, ACM/ICPC NEERC 2006, UVa1588）\n给出两个长度分别为n1，n2（n1，n2≤100）且每列高度只为1或2的长条。需要将它们放\n入一个高度为3的容器（如图3-8所示），问能够容纳它们的最短容器长度。 Sample Input\n2112112112\n2212112\n12121212\n21212121\n2211221122\n21212\nSample Output\n10\n8\n15\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=4463\u0026amp;mosmsg=Submission+received+with+ID+20560401\n用两个字符串数组分别存这两个块，一块作为不动的，另一块在其上移动，判断当前移动到的位置是不是和下块契合（用循环依次比较各个位置），若不是则继续移动到下一位。\n需要注意的是，最短的契合方案有可能你漏想了，下面一共是三种可能的情况。所以我用一个函数来将两个块换了位置后又移动了一次。\n//三种情况：bbbbb aa (|a|:ab重叠 //1.短块在长块里(bb|aa|b) //2.短块头在长块里（外），短块尾巴超出长块尾(bbbb|a|a) //3.长块头在短块尾（外），长块尾巴超出短块尾(a|a|bbbb) //不要忘记第三种情况，有时最短空间就是出自3 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; const int N = 100; //int kick1[N+5],kick2[N+5]; int kickdown(string k1,string k2)//定k1，移k2 { //cout\u0026lt;\u0026lt;k1.size()\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;k2.size()\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;k1.size();i++) { int ii=i,j=0;//i就是大小块契合的那一位 //cout\u0026lt;\u0026lt;ii\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl; while((k1[ii]-\u0026#39;0\u0026#39;+k2[j]-\u0026#39;0\u0026#39;)\u0026lt;=3\u0026amp;\u0026amp;(j\u0026lt;k2.size()\u0026amp;\u0026amp;ii\u0026lt;k1.size()))//若当前位不匹配则进行for到下一位 { //cout\u0026lt;\u0026lt;\u0026#34;k1 ii \u0026#34;\u0026lt;\u0026lt;ii\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;k1[ii]\u0026lt;\u0026lt;\u0026#34; | k2 j\u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;k2[j]\u0026lt;\u0026lt;endl; ii++; j++; } if(j==k2.","title":"uva 1588 - Kickdown（换低挡装置）"},{"content":" 习题4-1 象棋（Xiangqi, ACM/ICPC Fuzhou 2011, UVa1589）\n考虑一个象棋残局，其中红方有n（2≤n≤7）个棋子，黑方只有一个将。红方除了有一个\n帅（G）之外还有3种可能的棋子：车（R），马（H），炮（C），并且需要考虑“蹩马\n腿”（如图4-4所示）与将和帅不能照面（将、帅如果同在一条直线上，中间又不隔着任何棋\n子的情况下，走子的一方获胜）的规则。\n输入所有棋子的位置，保证局面合法并且红方已经将军。你的任务是判断红方是否已经\n把黑方将死。\nSample Input\n2 1 4\nG 10 5\nR 6 4\n3 1 5\nH 4 5\nG 10 5\nC 7 5\n0 0 0\nSample Output\nYES\nNO\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=833\u0026amp;problem=4464\u0026amp;mosmsg=Submission+received+with+ID+20833399\n注意：\n输入的第一行第一个为红子的数量，后两个是黑将的位置。接下来的是红子类型和位置。\n思路：\n1、黑将有四种走法，即上下左右。我们只要判断 是否这四种走法中合理的都是死路 即可判断将是否被将死 。\n2、先判断是否当前的黑将走子的位置是否合理，即当前的将子有没有超出九宫格。\n3、对于车炮帅的将军，我们可以一起判断，先从将的位置开始，依次往一条路过，比如从（1，4）向（10，4）竖的过，\n（1）如果路上遇到车或帅，那么就是将军了。\n（2）若是非车帅的子，就计数加一。（比如我用c_iff变量记录目前非车帅的子数量）。\n（3）若是炮，判断炮前是否有一个子（c_iff的值是不是一），若是，将军 。\n（4）关于如何将“顺次从黑将开始分别左一行，右一行，上一列，下一列遍历格子上的子”放在一个循环条件里，见代码，我是将本应四个循环的条件写在一个循环体里用 if 处理了\n4、关于马的将军，我们可以单独判断。看图,(x,y)位置为黑将，黑框位置为蹩马腿，如果此处没有子那么与其相邻的两个位置上有马的话就可以将军了。\n这里的技巧1：两层循环过完四个方向，见代码\n技巧2：黑框位置：（x+i，y+j），与其相邻的马（x+i+i，y+j）和（x+i，y+j+j）\n5、注意：还有一点陷阱，我们还要考虑一开始黑将就和红帅对面，那样的话黑将就可以直接击杀红帅。样例：\n2 1 5\nG 10 5\nR 1 1\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; char board[14][15];//9*10的棋盘 int checkmate(int rx,int ry) { //cout\u0026lt;\u0026lt;\u0026#34;rx \u0026#34;\u0026lt;\u0026lt;rx\u0026lt;\u0026lt;\u0026#34; ry \u0026#34;\u0026lt;\u0026lt;ry\u0026lt;\u0026lt;endl; if((rx\u0026lt;1||rx\u0026gt;3)||(ry\u0026lt;4||ry\u0026gt;6))//出逃即越界，不合理走法 { //cout\u0026lt;\u0026lt;\u0026#34;escape\u0026#34;\u0026lt;\u0026lt;endl; return 1; } int c_iff=0;//炮前有子加1 int ix=-1,iy=0; int x=rx+ix;//!注意：一开始的位置就是将的位置，所以要先避开，同时模拟了吃子 int y=ry; //int xy,rc_n=10; // for(;y\u0026lt;=9;y+=ic) // for(;/*x\u0026gt;=1\u0026amp;\u0026amp;*/x\u0026lt;=10;x+=ic) for(;y\u0026lt;=9;x+=ix,y+=iy)//3.(4)的技巧见33--54行 { //cout\u0026lt;\u0026lt;\u0026#34;x \u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; y \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; if(x\u0026lt;1)//上边过完了，就该过下边的列 {ix=1;x=rx;c_iff=0;continue;} if(x\u0026gt;10)//该遍历竖列了，先左行 { ix=0;//注意：接下来x就不能动了 iy=-1; x=rx; c_iff=0; continue; } if(y\u0026lt;1)//左行遍历结束，该右行 {iy=1;y=ry;c_iff=0;continue;} if(board[x][y]==\u0026#39;0\u0026#39;)//没有子 continue; //如果当前是炮或将且之前没有过 子 if((c_iff==0\u0026amp;\u0026amp;(board[x][y]==\u0026#39;R\u0026#39;||board[x][y]==\u0026#39;G\u0026#39;))||//车决 (board[x][y]==\u0026#39;C\u0026#39;\u0026amp;\u0026amp;c_iff==1))//炮击身亡 { //cout\u0026lt;\u0026lt;board[x][y]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34; dead\u0026#34;\u0026lt;\u0026lt;endl; return 1;//dead } else //若果不是炮或将，就加一 c_iff++; } // return 0; //} //int horse(int rx,int ry) //{ //判断马子是否将军 for(int ix=1;ix\u0026gt;=-1;ix-=2) for(int iy=1;iy\u0026gt;=-1;iy-=2)//用于判断四个方位 if(((rx+ix)\u0026lt;1||(rx+ix)\u0026gt;10||(ry+iy)\u0026lt;1||(ry+iy)\u0026gt;9)==0)//不越界 if(board[rx+ix][ry+iy]==\u0026#39;0\u0026#39;)//不蹩马腿 if(board[rx+ix*2][ry+iy]==\u0026#39;H\u0026#39;||board[rx+ix][ry+iy*2]==\u0026#39;H\u0026#39;)//那个致死位置上有马 return 1;//马杀 //cout\u0026lt;\u0026lt;\u0026#34;safe\u0026#34;\u0026lt;\u0026lt;endl; return 0; } int main() { int T,rx,ry; int cx,cy; char chess; while(cin\u0026gt;\u0026gt;T\u0026gt;\u0026gt;rx\u0026gt;\u0026gt;ry\u0026amp;\u0026amp;!(!T||!rx||!ry)) { memset(board,\u0026#39;0\u0026#39;,sizeof(board)); while(T--)//摆棋子 { cin\u0026gt;\u0026gt;chess; cin\u0026gt;\u0026gt;cx\u0026gt;\u0026gt;cy; board[cx][cy] = chess; } int i; for(i=rx+1;rx\u0026lt;=10\u0026amp;\u0026amp;board[i][ry]==\u0026#39;0\u0026#39;;i++);//判断一开始是否将对帅，是就NO，即思路5 if(board[i][ry]==\u0026#39;G\u0026#39;){cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl;continue;} int dead_sum=0;//记录死亡路线，为4就是将死 //cout\u0026lt;\u0026lt;\u0026#34;rx \u0026#34;\u0026lt;\u0026lt;rx\u0026lt;\u0026lt;\u0026#34; ry \u0026#34;\u0026lt;\u0026lt;ry\u0026lt;\u0026lt;endl; dead_sum += checkmate(rx+1,ry); dead_sum += checkmate(rx-1,ry); dead_sum += checkmate(rx,ry+1); dead_sum += checkmate(rx,ry-1); //cout\u0026lt;\u0026lt;\u0026#34;dead_sum \u0026#34;\u0026lt;\u0026lt;dead_sum\u0026lt;\u0026lt;endl; if(dead_sum==4) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } //AC at 2018/2/26 （题外话：终于病好了，赶紧交题，这个题比上一道用友好多了，感谢udebug，博客写的更累，头晕目眩不能再写了）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1589-xiangqi%E8%B1%A1%E6%A3%8B/","summary":"习题4-1 象棋（Xiangqi, ACM/ICPC Fuzhou 2011, UVa1589）\n考虑一个象棋残局，其中红方有n（2≤n≤7）个棋子，黑方只有一个将。红方除了有一个\n帅（G）之外还有3种可能的棋子：车（R），马（H），炮（C），并且需要考虑“蹩马\n腿”（如图4-4所示）与将和帅不能照面（将、帅如果同在一条直线上，中间又不隔着任何棋\n子的情况下，走子的一方获胜）的规则。\n输入所有棋子的位置，保证局面合法并且红方已经将军。你的任务是判断红方是否已经\n把黑方将死。\nSample Input\n2 1 4\nG 10 5\nR 6 4\n3 1 5\nH 4 5\nG 10 5\nC 7 5\n0 0 0\nSample Output\nYES\nNO\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=833\u0026amp;problem=4464\u0026amp;mosmsg=Submission+received+with+ID+20833399\n注意：\n输入的第一行第一个为红子的数量，后两个是黑将的位置。接下来的是红子类型和位置。\n思路：\n1、黑将有四种走法，即上下左右。我们只要判断 是否这四种走法中合理的都是死路 即可判断将是否被将死 。\n2、先判断是否当前的黑将走子的位置是否合理，即当前的将子有没有超出九宫格。\n3、对于车炮帅的将军，我们可以一起判断，先从将的位置开始，依次往一条路过，比如从（1，4）向（10，4）竖的过，\n（1）如果路上遇到车或帅，那么就是将军了。\n（2）若是非车帅的子，就计数加一。（比如我用c_iff变量记录目前非车帅的子数量）。\n（3）若是炮，判断炮前是否有一个子（c_iff的值是不是一），若是，将军 。\n（4）关于如何将“顺次从黑将开始分别左一行，右一行，上一列，下一列遍历格子上的子”放在一个循环条件里，见代码，我是将本应四个循环的条件写在一个循环体里用 if 处理了\n4、关于马的将军，我们可以单独判断。看图,(x,y)位置为黑将，黑框位置为蹩马腿，如果此处没有子那么与其相邻的两个位置上有马的话就可以将军了。\n这里的技巧1：两层循环过完四个方向，见代码\n技巧2：黑框位置：（x+i，y+j），与其相邻的马（x+i+i，y+j）和（x+i，y+j+j）\n5、注意：还有一点陷阱，我们还要考虑一开始黑将就和红帅对面，那样的话黑将就可以直接击杀红帅。样例：\n2 1 5\nG 10 5","title":"uva 1589 - Xiangqi（象棋）"},{"content":" 习题4-5 IP网络（IP Networks, ACM/ICPC NEERC 2005, UVa1590）\n可以用一个网络地址和一个子网掩码描述一个子网（即连续的IP地址范围）。其中子网\n掩码包含32个二进制位，前32-n位为1，后n位为0，网络地址的前32-n位任意，后n位为0。\n所有前32-n位和网络地址相同的IP都属于此网络。\n例如，网络地址为194.85.160.176（二进制为11000010|01010101|10100000|10110000），\n子网掩码为255.255.255.248（二进制为11111111|11111111|11111111|11111000），则该子网\n的IP地址范围是194.85.160.176～194.85.160.183。输入一些IP地址，求最小的网络（即包含IP\n地址最少的网络），包含所有这些输入地址。\n例如，若输入3个IP地址：194.85.160.177、194.85.160.183和194.85.160.178，包含上述3\n个地址的最小网络的网络地址为194.85.160.176，子网掩码为255.255.255.248。\nSample Input\n3\n194.85.160.177\n194.85.160.183\n194.85.160.178\nSample Output\n194.85.160.176\n255.255.255.248\n【注意：他可能有很多组输入，而每组输出之间没有空行】\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=833\u0026amp;problem=4465\u0026amp;mosmsg=Submission+received+with+ID+21184770\n思路：\n1、先将所有ip存起来，用数组或容器什么的。\n2、转换二进制\n3、从第一位开始，诸位比较所有的ip在这一位上的数字一样否\n4、判断出最小网络位数，即掩码为1的位数。\n5、转换十进制\n（我用来存二进制的ip用的是string）\n（用了下vector，当然也可以用数组存，一个32*1000的数组）\n/* 110000100101010110100000_10110001 110000100101010110100000_10110111 110000100101010110100000_10110010 11000010010101011010000010110000 11111111111111111111111111111000 */ //特殊情况：只输入一个IP地址，这时掩码应该32位1 #include\u0026lt;iostream\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; string binary(int dec) { string str=\u0026#34;00000000\u0026#34;; stack\u0026lt;int\u0026gt; s; int bin=0; for(int i=7;i\u0026gt;=0;i--) { //s.push(dec%2); str[i]=dec%2+\u0026#39;0\u0026#39;; dec /= 2; } // while(!s.empty()) // { // bin = bin*10 + s.top(); // s.pop(); // } // return bin; return str; } int decimal(string bin) { int dec =0; for(int i=0;i\u0026lt;8;i++) //从高位开始 { dec += (int)pow(2,8-i-1)* (bin[i]-\u0026#39;0\u0026#39;); } return dec; } int main() { int T; while(cin\u0026gt;\u0026gt;T) { vector\u0026lt;string\u0026gt;ip; // 存储输入的所有ip int num=0; if(T==1) //防止只输入一个地址的特殊情况 num=32; while(T--) //输入 { int a[4]; string str; scanf(\u0026#34;%d.%d.%d.%d\u0026#34;,\u0026amp;a[0],\u0026amp;a[1],\u0026amp;a[2],\u0026amp;a[3]); for(int i=0;i\u0026lt;4;i++) { str += binary(a[i]); } ip.push_back(str); } for(int j=0;j\u0026lt;32;j++) //判断相等的位数 { int iff=0; for(int i=1;i\u0026lt;ip.size();i++) { //cout\u0026lt;\u0026lt;ip.at(i)\u0026lt;\u0026lt;endl; if(ip.at(0)[j] == ip.at(i)[j]) //这一位相等 { iff=1; } else { iff=0; break; } } if(iff) //这一位相等，掩码位数加一 num++; else break; } string zero=\u0026#34;00000000\u0026#34;; //备用0 string mask,minip; int score[4];//存储最小网络的四个十进制ip地址段 int score2[4];//存储mask的四个十进制的ip地址段 for(int i=1;i\u0026lt;=32-num;i++) //先从最后开始补0 { minip=\u0026#39;0\u0026#39;+minip; mask=\u0026#39;0\u0026#39;+mask; } for(int i=num-1;i\u0026gt;=0;i--) //倒的补 { minip=ip[0].at(i)+minip; mask=\u0026#39;1\u0026#39;+mask; } // cout\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl; // for(int i=0;i\u0026lt;ip.size();i++) // cout\u0026lt;\u0026lt;ip[i]\u0026lt;\u0026lt;endl; // cout\u0026lt;\u0026lt;endl; // cout\u0026lt;\u0026lt;mask\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;4;i++) //运算最小网络 { score[i] =decimal(minip.substr(i*8,8)); score2[i] =decimal(mask.substr(i*8,8)); //以下淘汰的方法是：边变换，边比对是否位数到了最小网络位。 //比较上面的先做好一个最小网络的二进制地址,然后在直接变换。要更复杂 // if(i*8+8\u0026gt;num) // { // //cout\u0026lt;\u0026lt;i*8\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl; // //cout\u0026lt;\u0026lt;ip[0].substr(i*8,num-i*8)\u0026lt;\u0026lt;\u0026#34;|\u0026#34;\u0026lt;\u0026lt;zero.substr(0,32-num)\u0026lt;\u0026lt;endl; // score[i]=decimal(ip[0].substr(i*8,num-i*8)+zero.substr(0,32-num)); // } // else // { // //cout\u0026lt;\u0026lt;ip[0].substr(i*8,8)\u0026lt;\u0026lt;endl; // score[i]=decimal(ip[0].substr(i*8,8)); // } } printf(\u0026#34;%d.%d.%d.%d\\n\u0026#34;,score[0],score[1],score[2],score[3]); printf(\u0026#34;%d.%d.%d.%d\\n\u0026#34;,score2[0],score2[1],score2[2],score2[3]); } return 0; } //AC at 2018/4/22 （题外话：好在上学期的网络课设就是算ip地址，所以这道题我才想了半个多小时就有思路了（哭））\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1590-ip-networksip%E5%9C%B0%E5%9D%80/","summary":"习题4-5 IP网络（IP Networks, ACM/ICPC NEERC 2005, UVa1590）\n可以用一个网络地址和一个子网掩码描述一个子网（即连续的IP地址范围）。其中子网\n掩码包含32个二进制位，前32-n位为1，后n位为0，网络地址的前32-n位任意，后n位为0。\n所有前32-n位和网络地址相同的IP都属于此网络。\n例如，网络地址为194.85.160.176（二进制为11000010|01010101|10100000|10110000），\n子网掩码为255.255.255.248（二进制为11111111|11111111|11111111|11111000），则该子网\n的IP地址范围是194.85.160.176～194.85.160.183。输入一些IP地址，求最小的网络（即包含IP\n地址最少的网络），包含所有这些输入地址。\n例如，若输入3个IP地址：194.85.160.177、194.85.160.183和194.85.160.178，包含上述3\n个地址的最小网络的网络地址为194.85.160.176，子网掩码为255.255.255.248。\nSample Input\n3\n194.85.160.177\n194.85.160.183\n194.85.160.178\nSample Output\n194.85.160.176\n255.255.255.248\n【注意：他可能有很多组输入，而每组输出之间没有空行】\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=833\u0026amp;problem=4465\u0026amp;mosmsg=Submission+received+with+ID+21184770\n思路：\n1、先将所有ip存起来，用数组或容器什么的。\n2、转换二进制\n3、从第一位开始，诸位比较所有的ip在这一位上的数字一样否\n4、判断出最小网络位数，即掩码为1的位数。\n5、转换十进制\n（我用来存二进制的ip用的是string）\n（用了下vector，当然也可以用数组存，一个32*1000的数组）\n/* 110000100101010110100000_10110001 110000100101010110100000_10110111 110000100101010110100000_10110010 11000010010101011010000010110000 11111111111111111111111111111000 */ //特殊情况：只输入一个IP地址，这时掩码应该32位1 #include\u0026lt;iostream\u0026gt; #include\u0026lt;stack\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; string binary(int dec) { string str=\u0026#34;00000000\u0026#34;; stack\u0026lt;int\u0026gt; s; int bin=0; for(int i=7;i\u0026gt;=0;i--) { //s.push(dec%2); str[i]=dec%2+\u0026#39;0\u0026#39;; dec /= 2; } // while(!","title":"uva 1590 - IP Networks（IP地址）"},{"content":" 例题5-9 数据库（Database，ACM/ICPC NEERC 2009，UVa1592）\n输入一个n行m列的数据库（1≤n≤10000，1≤i≤10），是否存在两个不同行r1，r2和两个\n不同列c1，c2，使得这两行和这两列相同（即（r1，c1）和（r2，c1）相同，（r1，c2）和\n（r2，c2）相同）。例如，对于如图5-3所示的数据库，第2、3行和第2、3列满足要求。\nSample Input\n3 3\nHow to compete in ACM ICPC,Peter,peter@neerc.ifmo.ru\nHow to win ACM ICPC,Michael,michael@neerc.ifmo.ru\nNotes from ACM ICPC champion,Michael,michael@neerc.ifmo.ru\n2 3\n1,Peter,peter@neerc.ifmo.ru\n2,Michael,michael@neerc.ifmo.ru\nSample Output\nNO\n2 3\n2 3\nYES\n本家地址\n设计存储的结构\n[ { (c1.value, c2.value) -\u0026gt; r0.index } ] 列表中存储每一行中列列的组合（map存储）。列表的大小会是数据库的列*(列-1)/2。map的键是一个存有2个元素的列表（列表中存的是列值），map的值是对应的行下标。map的大小为总行数。\n存储：\n我们在存储时，针对每一行进行列的两两组合，然后对每一个组合在当前列组合下标中进行map查找，如果总排列数过完之后，有2个map匹配项，那我们就找到了。\n在这里也用到了字符串索引存储的方式。类比指针，我们对每一个字符串给定一个编号，然后存在数据库中的就只是这个编号，而不用存字符串，节省了很大空间。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;set\u0026gt; using namespace std; /* [ { (c1.value, c2.value) -\u0026gt; r0.index } ] */ vector\u0026lt; map\u0026lt; vector\u0026lt;int\u0026gt;,int\u0026gt; \u0026gt; parquet; map\u0026lt;string, int\u0026gt; dict; /* temp of one row */ vector\u0026lt;int\u0026gt; rowTemp; int X,Y; char tmp[99]; int getIndexOfStr(string str){ if(!dict.count(str)){ dict[str] = dict.size(); } return dict[str]; } int calc(int row,int* col1,int* col2){ vector\u0026lt;int\u0026gt; tuple2; int tuple2_index = 0; for(int i=0;i\u0026lt;Y;i++){ for(int j=i+1;j\u0026lt;Y;j++){ tuple2.clear(); tuple2.push_back(rowTemp[i]); tuple2.push_back(rowTemp[j]); // cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;tuple2_index\u0026lt;\u0026lt;endl; if(parquet[tuple2_index].count(tuple2)){ int row1 = parquet[tuple2_index][tuple2]; *col1 = i; *col2 = j; return row1; }else{ parquet[tuple2_index][tuple2] = row; } tuple2_index++; } } return -1; } int main(){ int a,b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b){ getchar(); X=a,Y=b; /* 新的一组 */ /* init vector */ parquet.clear(); for(int i=0;i\u0026lt;Y*(Y-1)/2;i++){ map\u0026lt;vector\u0026lt;int\u0026gt;, int\u0026gt; tempMap; parquet.push_back(tempMap); } /* 过一行中的一列 */ int right=0; int row1,row2; int col1,col2; for(int row=0;row\u0026lt;a;row++){ /* 新的一行开始了 */ rowTemp.clear(); char c; int i=0,col=0; while((c=getchar()) \u0026amp;\u0026amp;c !=\u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; c!=EOF){ if(c==\u0026#39;,\u0026#39;){ string s(tmp,0,i); rowTemp.push_back(getIndexOfStr(s)); col++; i=0; }else{ tmp[i]=c; i++; } } string s(tmp,0,i); rowTemp.push_back(getIndexOfStr(s)); /* 存入新的一行中的2列组合 */ if(right==0){ int ccol1,ccol2; int rrow1 = calc(row,\u0026amp;ccol1,\u0026amp;ccol2); if(rrow1 != -1){ right = 1; col1 = ccol1+1; col2 = ccol2+1; row1 = rrow1+1; row2 = row+1; } } /* 这一行过完了 */ } /* 这一组过完了 */ if(right){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;row1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;row2\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;col1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;col2\u0026lt;\u0026lt;endl; }else{ cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; } } return 0; } // AC at 2020/09/08 ps：这一道题重点在于设计数据库存储方式上，我居然最终求助于刘汝佳，真是太逊了。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1592-database-%E6%95%B0%E6%8D%AE%E5%BA%93-by-sucicada/","summary":"例题5-9 数据库（Database，ACM/ICPC NEERC 2009，UVa1592）\n输入一个n行m列的数据库（1≤n≤10000，1≤i≤10），是否存在两个不同行r1，r2和两个\n不同列c1，c2，使得这两行和这两列相同（即（r1，c1）和（r2，c1）相同，（r1，c2）和\n（r2，c2）相同）。例如，对于如图5-3所示的数据库，第2、3行和第2、3列满足要求。\nSample Input\n3 3\nHow to compete in ACM ICPC,Peter,peter@neerc.ifmo.ru\nHow to win ACM ICPC,Michael,michael@neerc.ifmo.ru\nNotes from ACM ICPC champion,Michael,michael@neerc.ifmo.ru\n2 3\n1,Peter,peter@neerc.ifmo.ru\n2,Michael,michael@neerc.ifmo.ru\nSample Output\nNO\n2 3\n2 3\nYES\n本家地址\n设计存储的结构\n[ { (c1.value, c2.value) -\u0026gt; r0.index } ] 列表中存储每一行中列列的组合（map存储）。列表的大小会是数据库的列*(列-1)/2。map的键是一个存有2个元素的列表（列表中存的是列值），map的值是对应的行下标。map的大小为总行数。\n存储：\n我们在存储时，针对每一行进行列的两两组合，然后对每一个组合在当前列组合下标中进行map查找，如果总排列数过完之后，有2个map匹配项，那我们就找到了。\n在这里也用到了字符串索引存储的方式。类比指针，我们对每一个字符串给定一个编号，然后存在数据库中的就只是这个编号，而不用存字符串，节省了很大空间。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;set\u0026gt; using namespace std; /* [ { (c1.value, c2.value) -\u0026gt; r0.","title":"UVA 1592 - Database (数据库) By SuCicada"},{"content":" 例题6-20 理想路径（Ideal Path, NEERC 2010, UVa1599）\n给一个n个点m条边（2≤n≤100000，1≤m≤200000）的无向图，每条边上都涂有一种颜\n色。求从结点1到结点n的一条路径，使得经过的边数尽量少，在此前提下，经过边的颜色序\n列的字典序最小。一对结点间可能有多条边，一条边可能连接两个相同结点。输入保证结点\n1可以达到结点n。颜色为1～10\n9的整数。\nSample Input\n4 6\n1 2 1\n1 3 2\n3 4 3\n2 3 1\n2 4 4\n3 1 1\nSample Output\n2\n1 3\n本家链接\n先找最短路：倒序从终点bfs找。\n- 在此认为倒序和正序效果一样。只是某些处理逻辑相反。\nbfs之后，可能存在多条最短路，所以再需要一次bfs，来选出颜色最小的路。\n降低时间的注意点：\n选择合适的数据结构存储图。 一开始使用了map作为存储图的结构，后来在遍历过程中实在比vector慢了太多。 使用标记记录走过的结点，减少bfs重复计算。 对了2:00 - 2:30 期间uva oj 判题特别慢特别慢。尽量避开。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;set\u0026gt; using namespace std; #define mapiter map\u0026lt;int,int\u0026gt;::iterator const int MAX_N = 100005; /* 先找最短路：倒序从终点bfs找。 - 在此认为倒序和正序效果一样。只是某些处理逻辑相反。 bfs之后，可能存在多条最短路，所以再需要一次bfs，来选出颜色最小的路。 一开始使用了map作为存储图的结构，后来在遍历过程中实在比vector慢了太多。 */ /* a-\u0026gt;b map[a][b] == color */ class Node{ public: int next; int color; }; // map\u0026lt;int,int\u0026gt; door[MAX_N]; vector\u0026lt;Node\u0026gt; door[MAX_N]; /* 存储无向图，因为结点太多了 */ int book[MAX_N]; /* 记录每个点距离终点`的最小距离 */ int visit[MAX_N]; /* 记录走过的点 */ int big = (1L\u0026lt;\u0026lt;31)-1; int res[MAX_N]; int N,M; /* n下各点 到n 的距离取最短+1 door[a][b] a -\u0026gt; b log[b] = min(log[b], log[a]+1) */ void bfs(){ queue\u0026lt;int\u0026gt; tmp; tmp.push(N); visit[N] = 1; while(!tmp.empty()){ int a = tmp.front(); tmp.pop(); if(a==1){ /* 到头了 */ break; } for(int i=0;i\u0026lt;door[a].size();i++){ int b = door[a][i].next; if(book[b] \u0026gt; book[a]+1){ book[b] = book[a]+1; } if(!visit[b]){ visit[b] = 1; tmp.push(b); } } } } void calc(){ memset(visit, 0, sizeof(visit)); set\u0026lt;int\u0026gt; tmp; int resN = book[1]; tmp.insert(1); while(!tmp.empty()){ vector\u0026lt;int\u0026gt; tmpV; int a; int min_color = big; int min_b = big; int n; /* 同color同距离的 一层 , 不同的位置即a, 要找出最小的 color和对应的 位置 */ for(set\u0026lt;int\u0026gt;::iterator it = tmp.begin();it!=tmp.end();it++){ a = *it; // 这个的位置 n = book[a]; // 这一个的距离到n /* 扫相连, 找下一跳, \u0026amp;\u0026amp; 字典序小 */ for(int i=0;i\u0026lt;door[a].size();i++){ int b = door[a][i].next; int color = door[a][i].color; if(book[b]==n-1){ min_b = b; if( min_color \u0026gt; color){ min_color = color; tmpV.clear(); tmpV.push_back(b); }else if(min_color == color){ tmpV.push_back(b);// 相同的color位置存 } } } } // 得到了这一层最小的color对应的位置: tmp if(n==0) break; // 这个位置虽然下一跳不确定,但是color确定了, 存下 res[n] = min(res[n],min_color); tmp.clear(); // 开始遍历color相同的位置 for(int i=0;i\u0026lt;tmpV.size();i++){ // 不走重复的愿望路是非常重要的 if(visit[index]==0){ visit[index]=1; tmp.insert(index); } } } } int main(){ int n,m; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m){ for(int i=1;i\u0026lt;=n;i++){ door[i].clear(); book[i]= big; res[i] = big; visit[i] = 0; } N = n; M = m; for(int i=0;i\u0026lt;m;i++){ int a,b,c; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; Node n1; n1.next = b; n1.color = c; Node n2; n2.next = a; n2.color = c; door[a].push_back(n1); door[b].push_back(n2); } book[n] = 0; bfs(); calc(); cout\u0026lt;\u0026lt;book[1]\u0026lt;\u0026lt;endl; for(int i=book[1];i\u0026gt;=1;i--){ cout\u0026lt;\u0026lt;res[i]; if(i!=1){ cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } } cout\u0026lt;\u0026lt;endl; } return 0; } // AC at 2020/09/16 ps：这道题提交了太多次，做了很多天，一度绝望，一直超时。熬夜一天废一周。所以要保证良好的精神状态和心态再来做题。警惕陷入负面漩涡之中。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-1599-ideal-path%E7%90%86%E6%83%B3%E8%B7%AF%E5%BE%84-by-sucicada/","summary":"例题6-20 理想路径（Ideal Path, NEERC 2010, UVa1599）\n给一个n个点m条边（2≤n≤100000，1≤m≤200000）的无向图，每条边上都涂有一种颜\n色。求从结点1到结点n的一条路径，使得经过的边数尽量少，在此前提下，经过边的颜色序\n列的字典序最小。一对结点间可能有多条边，一条边可能连接两个相同结点。输入保证结点\n1可以达到结点n。颜色为1～10\n9的整数。\nSample Input\n4 6\n1 2 1\n1 3 2\n3 4 3\n2 3 1\n2 4 4\n3 1 1\nSample Output\n2\n1 3\n本家链接\n先找最短路：倒序从终点bfs找。\n- 在此认为倒序和正序效果一样。只是某些处理逻辑相反。\nbfs之后，可能存在多条最短路，所以再需要一次bfs，来选出颜色最小的路。\n降低时间的注意点：\n选择合适的数据结构存储图。 一开始使用了map作为存储图的结构，后来在遍历过程中实在比vector慢了太多。 使用标记记录走过的结点，减少bfs重复计算。 对了2:00 - 2:30 期间uva oj 判题特别慢特别慢。尽量避开。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;set\u0026gt; using namespace std; #define mapiter map\u0026lt;int,int\u0026gt;::iterator const int MAX_N = 100005; /* 先找最短路：倒序从终点bfs找。 - 在此认为倒序和正序效果一样。只是某些处理逻辑相反。 bfs之后，可能存在多条最短路，所以再需要一次bfs，来选出颜色最小的路。 一开始使用了map作为存储图的结构，后来在遍历过程中实在比vector慢了太多。 */ /* a-\u0026gt;b map[a][b] == color */ class Node{ public: int next; int color; }; // map\u0026lt;int,int\u0026gt; door[MAX_N]; vector\u0026lt;Node\u0026gt; door[MAX_N]; /* 存储无向图，因为结点太多了 */ int book[MAX_N]; /* 记录每个点距离终点`的最小距离 */ int visit[MAX_N]; /* 记录走过的点 */ int big = (1L\u0026lt;\u0026lt;31)-1; int res[MAX_N]; int N,M; /* n下各点 到n 的距离取最短+1 door[a][b] a -\u0026gt; b log[b] = min(log[b], log[a]+1) */ void bfs(){ queue\u0026lt;int\u0026gt; tmp; tmp.","title":"UVA 1599 - Ideal Path(理想路径) By SuCicada"},{"content":" 习题4-2 正方形（Squares, ACM/ICPC World Finals 1990, UVa201）\n有n行n列（2≤n≤9）的小黑点，还有m条线段连接其中的一些黑点。统计这些线段连成\n了多少个正方形（每种边长分别统计）。\n行从上到下编号为1～n，列从左到右编号为1～n。边用H i j和V i j表示，分别代表边\n(i,j)-(i,j+1)和(i,j)-(i+1,j)。如图4-5所示最左边的线段用V 1 1表示。图中包含两个边长为1的正\n方形和一个边长为2的正方形。\nSample Input\n4\n16\nH 1 1\nH 1 3\nH 2 1\nH 2 2\nH 2 3\nH 3 2\nH 4 2\nH 4 3\nV 1 1\nV 2 1\nV 2 2\nV 2 3\nV 3 2\nV 4 1\nV 4 2\nV 4 3\n2\n3\nH 1 1\nH 2 1\nV 2 1\nSample Output\nProblem #1\n2 square (s) of size 1\n1 square (s) of size 2\n**********************************\nProblem #2\nNo completed squares can be found.\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=833\u0026amp;problem=137\u0026amp;mosmsg=Submission+received+with+ID+20866282\n（注意最后一次输出后面没有空行）\n思路：\n先看输入的数据：\nH输入的是行列的点往右连的一条边\nV输入的是列行的点往下连的一条边\n1、我们先用两个二维数组记录下输入的点的坐标，一个H（水平），一个V（垂直）。比如右边的点就记为1。\n2、写个函数，传进参数为查找的方块的边长。\n3、然后从第一个点开始遍历。判断以这个点作为左上顶点的正方形，的四条边是不是存在，即标志四条边的点的值是不是1。\n4、关于大于1的边长来说，我们可以在判断时用个循环，每次循环判断的是边长中的一部分（一个单位长度）的边是不是存在。即可。\n5、具体看代码吧。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; int hor[10][10],ver[10][10]; int N; int square(int sq_n) { //cout\u0026lt;\u0026lt;sq_n\u0026lt;\u0026lt;\u0026#34;sq_n\u0026#34;\u0026lt;\u0026lt;endl; int sqnum=0,iff=0; for(int x=1;x\u0026lt;=N-sq_n;x++) { for(int y=1;y\u0026lt;=N-sq_n;y++) { //cout\u0026lt;\u0026lt;hor[x][y]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ver[x][y]\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;sq_n;i++)//判断大于1边长正方形 if(hor[x][y+i]\u0026amp;\u0026amp;hor[x+sq_n][y+i]\u0026amp;\u0026amp; ver[x+i][y]\u0026amp;\u0026amp;ver[x+i][y+sq_n]) iff=1;//成方块 else { iff=0;//不成方块 break; } if(iff) sqnum++;//方块的个数 } } return sqnum; } int main() { int T,TN=1; while(cin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;T) { if(TN\u0026gt;1) cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;**********************************\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;Problem #\u0026#34;\u0026lt;\u0026lt;TN++\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;endl; memset(hor,0,sizeof(hor)); memset(ver,0,sizeof(ver)); while(T--)//记录点的信息 { char hv; int x,y; cin\u0026gt;\u0026gt;hv\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(hv==\u0026#39;H\u0026#39;) hor[x][y]=1; else ver[y][x]=1;//注意ver的是反的 } int num; int ifn=0; for(int i=1;i\u0026lt;=N;i++) { num = square(i); if(num) { cout\u0026lt;\u0026lt;num\u0026lt;\u0026lt;\u0026#34; square (s) of size \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; ifn++; } } if(!ifn) cout\u0026lt;\u0026lt;\u0026#34;No completed squares can be found.\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } //AC at 2018/3/4 （题外话：到校第一道题还算顺利。祝福接下来的旅程吧。算法真害人。）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-201-squares%E6%95%B0%E6%AD%A3%E6%96%B9%E5%BD%A2/","summary":"习题4-2 正方形（Squares, ACM/ICPC World Finals 1990, UVa201）\n有n行n列（2≤n≤9）的小黑点，还有m条线段连接其中的一些黑点。统计这些线段连成\n了多少个正方形（每种边长分别统计）。\n行从上到下编号为1～n，列从左到右编号为1～n。边用H i j和V i j表示，分别代表边\n(i,j)-(i,j+1)和(i,j)-(i+1,j)。如图4-5所示最左边的线段用V 1 1表示。图中包含两个边长为1的正\n方形和一个边长为2的正方形。\nSample Input\n4\n16\nH 1 1\nH 1 3\nH 2 1\nH 2 2\nH 2 3\nH 3 2\nH 4 2\nH 4 3\nV 1 1\nV 2 1\nV 2 2\nV 2 3\nV 3 2\nV 4 1\nV 4 2\nV 4 3","title":"uva 201 - Squares（数正方形）"},{"content":" 习题3-8 循环小数（Repeating Decimals, ACM/ICPC World Finals 1990, UVa202）\n输入整数a和b（0≤a≤3000，1≤b≤3000），输出a/b的循环小数表示以及循环节长度。例\n如a=5，b=43，小数表示为0.(116279069767441860465)，循环节长度为21。\n注意：有些即便是原题也可能没用看清的要求\n（如果小数位大于50括号里显示到50个小数位即可，后面加\u0026hellip;）\n（但是输出的小数位要是确实的位数，即便几百几千）\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=138\u0026amp;mosmsg=Submission+received+with+ID+20551105\nSample Input\n76 25\n5 43\n1 397\nSample Output\n76/25 = 3.04(0)\n1 = number of digits in repeating cycle\n5/43 = 0.(116279069767441860465)\n21 = number of digits in repeating cycle\n1/397 = 0.(00251889168765743073047858942065491183879093198992\u0026hellip;)\n99 = number of digits in repeating cycle\n（ps：这个案例的99就很是误导人）\n思路：从手算的除法公式下手，每一次的被除数都是 上一个被除数 \u0026ndash; 上一位商*除数，而我们只要找到从哪里开始的被除数和之前的某一个被除数一样，那么从这一位便开始循环；如果不懂，看下面的例子：2/3\n0.6 6 // 3|2.0 //一开始不够除，补零 1.8 //28 = 4（商）* 7（除数） 2 0 //20 = (30（被除数）- 4（商）* 7（除数）)*10 //开始循环 //同时我们发现 这里的被除数20 和第二行的被除数20 一样， 如果还不懂，亲自写一下除法运算，真的可以秒懂。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; int const N = 3000; int divident[N+5];//被除数 int result[N+5];//得数 int circle(int nd,int n1) { for(int i=0;i\u0026lt;nd;i++) { if(n1==divident[i])//发现循环 { return i;//返回 循环体的头部位置, } } return -1; } int main() { int a,b; while(cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b) { int n1=a;//被除数 int nc=-1; int nd=1,nr=0;//因为result第一位是整数位，所以为了输出对上 nd=1 memset(divident,0,sizeof(divident)); memset(result,0,sizeof(result)); do { result[nr++]=n1/b;//cout\u0026lt;\u0026lt;n1/b; //cout\u0026lt;\u0026lt;n1\u0026lt;\u0026lt;\u0026#34; n1 \u0026#34;\u0026lt;\u0026lt;result[nr-1]\u0026lt;\u0026lt;endl; //if(nc==1) n1 = (n1-n1/b*b); n1*=10; divident[nd++]=n1;//将每一阶段的被除数存下 //cout\u0026lt;\u0026lt;n1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;result[nr-1]\u0026lt;\u0026lt;endl; if(n1==0)//若能整除 { result[nr++]=0; nc=nd-1; nd++; break; } }while((nc=circle(nd-1,n1))==-1);//\u0026amp;\u0026amp;nr\u0026lt;=50);//nc---(nd-1)循环 // if(nr\u0026gt;50) // nc=1; cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;/\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34; = \u0026#34;; cout\u0026lt;\u0026lt;result[0]\u0026lt;\u0026lt;\u0026#34;.\u0026#34;; for(int i=1;i\u0026lt;nc;i++) cout\u0026lt;\u0026lt;result[i]; cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;; for(int i=nc;i\u0026lt;nd-1\u0026amp;\u0026amp;i\u0026lt;=50;i++) cout\u0026lt;\u0026lt;result[i]; if(nr\u0026gt;50) cout\u0026lt;\u0026lt;\u0026#34;...\u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;)\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;nd-nc-1//(nr\u0026lt;=50?nd-nc-1:99)要求算具体的 \u0026lt;\u0026lt;\u0026#34; = number of digits in repeating cycle\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/30 （题外话：一开始认为很难，查询资料，琢磨用辗转还是减减，后来在（未再次找到）博客上获得灵感。总计花费2个多小时，一周前就写好初始版了，之后一直忙于课设，昨天修改后始终wa，深夜难眠。今日有幸发现uva站的参考参数和参考结果 模块，甚是大喜，风吹落叶般改好了代码，果不其然，漂亮的AC。\n给吾身一言，入寒假之后，还望能发出关于两个课设的程序，与uva站的使用介绍。）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-202-repeating-decimals%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0/","summary":"习题3-8 循环小数（Repeating Decimals, ACM/ICPC World Finals 1990, UVa202）\n输入整数a和b（0≤a≤3000，1≤b≤3000），输出a/b的循环小数表示以及循环节长度。例\n如a=5，b=43，小数表示为0.(116279069767441860465)，循环节长度为21。\n注意：有些即便是原题也可能没用看清的要求\n（如果小数位大于50括号里显示到50个小数位即可，后面加\u0026hellip;）\n（但是输出的小数位要是确实的位数，即便几百几千）\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=138\u0026amp;mosmsg=Submission+received+with+ID+20551105\nSample Input\n76 25\n5 43\n1 397\nSample Output\n76/25 = 3.04(0)\n1 = number of digits in repeating cycle\n5/43 = 0.(116279069767441860465)\n21 = number of digits in repeating cycle\n1/397 = 0.(00251889168765743073047858942065491183879093198992\u0026hellip;)\n99 = number of digits in repeating cycle\n（ps：这个案例的99就很是误导人）\n思路：从手算的除法公式下手，每一次的被除数都是 上一个被除数 \u0026ndash; 上一位商*除数，而我们只要找到从哪里开始的被除数和之前的某一个被除数一样，那么从这一位便开始循环；如果不懂，看下面的例子：2/3\n0.6 6 // 3|2.0 //一开始不够除，补零 1.8 //28 = 4（商）* 7（除数） 2 0 //20 = (30（被除数）- 4（商）* 7（除数）)*10 //开始循环 //同时我们发现 这里的被除数20 和第二行的被除数20 一样， 如果还不懂，亲自写一下除法运算，真的可以秒懂。","title":"uva 202 - Repeating Decimals（循环小数）"},{"content":" 例题6-1 并行程序模拟（ Concurrency Simulator, ACM/ICPC World Finals 1991,\nUVa210）\n你的任务是模拟n个程序（ 按输入顺序编号为1～ n） 的并行执行。 每个程序包含不超过\n25条语句， 格式一共有5种： var = constant（ 赋值） ； print var（ 打印） ； lock； unlock； end。\n变量用单个小写字母表示， 初始为0， 为所有程序公有（ 因此在一个程序里对某个变量\n赋值可能会影响另一个程序） 。 常数是小于100的非负整数。\n每个时刻只能有一个程序处于运行态， 其他程序均处于等待态。 上述5种语句分别需\n要t1、 t2、 t3、 t4、 t5单位时间。 运行态的程序每次最多运行Q个单位时间（ 称为配额） 。 当\n一个程序的配额用完之后， 把当前语句（ 如果存在） 执行完之后该程序会被插入一个等待队\n列中， 然后处理器从队首取出一个程序继续执行。 初始等待队列包含按输入顺序排列的各个\n程序， 但由于lock/unlock语句的出现， 这个顺序可能会改变。\nlock的作用是申请对所有变量的独占访问。 lock和unlock总是成对出现， 并且不会嵌套。\nlock总是在unlock的前面。 当一个程序成功执行完lock指令之后， 其他程序一旦试图执行lock\n指令， 就会马上被放到一个所谓的阻止队列的尾部（ 没有用完的配额就浪费了） 。 当unlock\n执行完毕后， 阻止队列的第一个程序进入等待队列的首部。\n输入n, t1, t2, t3, t4, t5, Q以及n个程序， 按照时间顺序输出所有print语句的程序编号和结\n果。\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=838\u0026amp;page=show_problem\u0026amp;problem=146\n// 当前程序执行完,配额时间有剩余: 让下一个程序继续用\n// 当配额时间用完,当前程序一句代码没执行完: 继续执行到完\n就按照题目思路往下写出来的，但是我不知道为什么我写了这么多行。不想缩减了，\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;deque\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; // 当前程序执行完,配额时间有剩余: 让下一个程序继续用 // 当配额时间用完,当前程序一句代码没执行完: 继续执行到完 // 多组输入 // 每组输出之间空一行 // 所有变量初值为0 // 最后一组的输出之后不要有空行 map\u0026lt;char, int\u0026gt; vars; vector\u0026lt;deque\u0026lt;string\u0026gt; \u0026gt; group; deque\u0026lt;int\u0026gt; stop; deque\u0026lt;int\u0026gt; wait; void fun(){ int N,t1,t2,t3,t4,t5,Q; cin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;t1\u0026gt;\u0026gt;t2\u0026gt;\u0026gt;t3\u0026gt;\u0026gt;t4\u0026gt;\u0026gt;t5\u0026gt;\u0026gt;Q; cin.get(); // [注意] 接收空格 group = vector\u0026lt;deque\u0026lt;string\u0026gt; \u0026gt;(N); for(int i=0;i\u0026lt;N;i++){ string str; while(str != \u0026#34;end\u0026#34;){ getline(cin, str); group[i].push_back(str); } wait.push_back(i); } int index = 0; //当前第几个程序 int count_live = N; int lock = 0; // 作为临界资源的记录型信号量,代表阻塞程序个数 int part_time = 0; // 单位剩余时间 while(count_live){ int end_flag = 0; // 0:程序没结束, 1:程序end结束 -1:程序阻塞 index = wait[0]; // 读取等待队列首 wait.pop_front(); part_time = Q; while(part_time\u0026gt;0){ // 一个单位时间剩余的时间 string code = group[index][0]; // 读取程序队列首代码 string judge = code.substr(0,2); if(judge == \u0026#34;pr\u0026#34;){ // print cout\u0026lt;\u0026lt;index+1\u0026lt;\u0026lt;\u0026#34;: \u0026#34;\u0026lt;\u0026lt; vars[code[6]]\u0026lt;\u0026lt;endl; part_time -= t2; }else if(judge == \u0026#34;lo\u0026#34;){ // lock if(lock){ // 要阻塞,语句不执行,不记时 stop.push_back(index); end_flag = -1; part_time = 0; // 此次时间片废了 break; // 进入阻止队列,就不用进入等待队列了, 而且lock代码还需要执行 }else{ // 正常执行 lock++; part_time -= t3; } }else if(judge == \u0026#34;un\u0026#34;){ // unlock int pro = stop[0]; if(!stop.empty()){ // 若是最后一个解锁的,那么阻塞队列就是空 stop.pop_front(); wait.push_front(pro); } lock--; part_time -= t4; }else if(judge == \u0026#34;en\u0026#34;){ // end count_live --; part_time -= t5; end_flag = 1; break; // 结束本程序,时间片给下一个 }else{ // var int n; sscanf(code.substr(4).c_str(), \u0026#34;%d\u0026#34;,\u0026amp;n); vars[judge[0]] = n; part_time -= t1; } group[index].pop_front(); // 执行成功,代码出队列 } if(end_flag == 0) wait.push_back(index); // 时间片完,只要程序没有end, 就会入wait队列 } } int main() { int T; cin\u0026gt;\u0026gt;T; for(int i=0;i\u0026lt;T;i++){ if(i\u0026gt;0) cout\u0026lt;\u0026lt;endl; vars.clear(); group.clear(); stop.clear(); wait.clear(); fun(); } return 0; } // AC at 2019/2/8 00:25 // spend about 4 hours ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-210-concurrency-simulator-%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F/","summary":"例题6-1 并行程序模拟（ Concurrency Simulator, ACM/ICPC World Finals 1991,\nUVa210）\n你的任务是模拟n个程序（ 按输入顺序编号为1～ n） 的并行执行。 每个程序包含不超过\n25条语句， 格式一共有5种： var = constant（ 赋值） ； print var（ 打印） ； lock； unlock； end。\n变量用单个小写字母表示， 初始为0， 为所有程序公有（ 因此在一个程序里对某个变量\n赋值可能会影响另一个程序） 。 常数是小于100的非负整数。\n每个时刻只能有一个程序处于运行态， 其他程序均处于等待态。 上述5种语句分别需\n要t1、 t2、 t3、 t4、 t5单位时间。 运行态的程序每次最多运行Q个单位时间（ 称为配额） 。 当\n一个程序的配额用完之后， 把当前语句（ 如果存在） 执行完之后该程序会被插入一个等待队\n列中， 然后处理器从队首取出一个程序继续执行。 初始等待队列包含按输入顺序排列的各个\n程序， 但由于lock/unlock语句的出现， 这个顺序可能会改变。\nlock的作用是申请对所有变量的独占访问。 lock和unlock总是成对出现， 并且不会嵌套。\nlock总是在unlock的前面。 当一个程序成功执行完lock指令之后， 其他程序一旦试图执行lock\n指令， 就会马上被放到一个所谓的阻止队列的尾部（ 没有用完的配额就浪费了） 。 当unlock\n执行完毕后， 阻止队列的第一个程序进入等待队列的首部。","title":"uva 210 - Concurrency Simulator (并行程序模拟)"},{"content":" 例题4-4 信息解码（Message Decoding, ACM/ICPC World Finals 1991, UVa 213）\n考虑下面的01串序列：\n0, 00, 01, 10, 000, 001, 010, 011, 100, 101, 110, 0000, 0001, …, 1101, 1110, 00000, …\n首先是长度为1的串，然后是长度为2的串，依此类推。如果看成二进制，相同长度的后\n一个串等于前一个串加1。注意上述序列中不存在全为1的串。\n你的任务是编写一个解码程序。首先输入一个编码头（例如AB#TANCnrtXc），则上述\n序列的每个串依次对应编码头的每个字符。例如，0对应A，00对应B，01对应#，…，110对\n应X，0000对应c。接下来是编码文本（可能由多行组成，你应当把它们拼成一个长长的01\n串）。编码文本由多个小节组成，每个小节的前3个数字代表小节中每个编码的长度（用二\n进制表示，例如010代表长度为2），然后是各个字符的编码，以全1结束（例如，编码长度\n为2的小节以11结束）。编码文本以编码长度为000的小节结束。\n例如，编码头为$#\\，编码文本为0100000101101100011100101000，应这样解码：\n010(编码长度为2)00(#)00(#)10(*)11(小节结束)011(编码长度为3)000()111(小节结束)001(编码\n长度为1)0($)1(小节结束)000(编码结束)。\nSample input\nTNM AEIOU\n0010101100011\n1010001001110110011\n11000\n$#\n0100000101101100011100101000\nSample output\nTAN ME\n##*$\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=832\u0026amp;problem=149\u0026amp;mosmsg=Submission+received+with+ID+20759428\n/* 1、先接收字符串，因为有空格，所以我用了getline，因为我用string 2、然后我们将输入的字符串存入code这个二维数组里，code[i][j]中i代表二进制码的位数，j代表当前01码的十进制数。以此我们每次循环的j小于2^i-i即可。 3、然后我们用循环，先将三位的二进制数传入bin_dec()函数，来得出接下来代表一个字符的二进制码的位数。 4、contra()函数是用来进行每一组相同码长的字符的输出。 （1）其思路是用一个变量记录当前bcode（01码字符串）读到哪个位了。 （2）然后循环将之后的len位二进制变成一个整数，传入bin_dec()函数得出其代表的十进制数，而这个十进制数也是code数组的第二维的下标。 5、还有一点，因为二进制码在输入的过程中并不一定是在同一行,所以我用了：当前下标+要接受的码长 和 当前的01码字符串长度来进行比较，若大则接收新的一行字符串，再加到原先01码字符串后面。（！注意这里用的是while循环而不是单一次的if判断，是因为可能接收一次字串后也依然不够码长，所以要一直接收到足够长为止。）*/ #include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; char code[7][1\u0026lt;\u0026lt;7];//长度，值，来存字符 int bin_dec(int b)//二进制转十进制 { int dec=0; for(int i=0;b!=0;i++) { dec += ((b%10)\u0026lt;\u0026lt;i); b/=10; } return dec; } int dec_bin(int dec)//十进制转二进制 { int b=0; for(int i=0;dec!=0;i++) { b += (dec%2)*(int)(pow(10,i)+0.1); dec=dec\u0026gt;\u0026gt;1; } return b; } string s;//字符串 string bcode;//01码 //此函数用于输出当前码长为len的一组01码所代表的的字符 void contra(int \u0026amp;n,int len)//下一元素的下标，码长 { int dec; while(1) { int bin=0; while(n+len\u0026gt;=bcode.size())//用于接收断裂处之后的01码 { string temp; cin\u0026gt;\u0026gt;temp; bcode += temp; } for(int i=0;i\u0026lt;len;i++) { bin+=(bcode[n++]-\u0026#39;0\u0026#39;)*(int)(pow(10,len-i-1)+0.1); } dec=bin_dec(bin); if(dec==(1\u0026lt;\u0026lt;len)-1) break; cout\u0026lt;\u0026lt;code[len-1][dec]; } } int main() { while(getline(cin,s)\u0026amp;\u0026amp;cin\u0026gt;\u0026gt;bcode) { memset(code,0,sizeof(code));//清空数组 int si=0; for(int i=0;i\u0026lt;7\u0026amp;\u0026amp;si\u0026lt;s.size();i++)//存表 { for(int j=0;j\u0026lt;(1\u0026lt;\u0026lt;(i+1))-1\u0026amp;\u0026amp;si\u0026lt;s.size();j++) { code[i][j]=s[si++]; } } int n=0;//下一个元素下标 while(1) { while(n+3\u0026gt;bcode.size())//用于接收断裂处之后的01码 { string temp; cin\u0026gt;\u0026gt;temp; bcode += temp; } int s1=bcode[n]*100+bcode[n+1]*10+bcode[n+2]-111*\u0026#39;0\u0026#39;;//三位01码 if(s1==0) break; n+=3; s1=bin_dec(s1);//判断前三位 分析出码长 contra(n,s1); } //cout\u0026lt;\u0026lt;\u0026#34;!!!!!end\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;endl; cin.get(); } return 0; } //AC at 2018/2/11 另外在使用pow函数时遇到了一个问题，那就是浮点型的精度问题，\n在计算pow(10,2)算下来的double是99.9999多，我在强制转换int后就只剩下了99，所以当时在十转二进制十出错了。\n虽然我以前没出现过此错误，但是我们可以采用(int)(pow(10,i)+0.1)这个办法。\n（然后就是题外话：这道题上午看没有头绪，睡起来花了累计3小时才做出来，真的累。快过年了，真的是）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-213-message-decoding%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/","summary":"例题4-4 信息解码（Message Decoding, ACM/ICPC World Finals 1991, UVa 213）\n考虑下面的01串序列：\n0, 00, 01, 10, 000, 001, 010, 011, 100, 101, 110, 0000, 0001, …, 1101, 1110, 00000, …\n首先是长度为1的串，然后是长度为2的串，依此类推。如果看成二进制，相同长度的后\n一个串等于前一个串加1。注意上述序列中不存在全为1的串。\n你的任务是编写一个解码程序。首先输入一个编码头（例如AB#TANCnrtXc），则上述\n序列的每个串依次对应编码头的每个字符。例如，0对应A，00对应B，01对应#，…，110对\n应X，0000对应c。接下来是编码文本（可能由多行组成，你应当把它们拼成一个长长的01\n串）。编码文本由多个小节组成，每个小节的前3个数字代表小节中每个编码的长度（用二\n进制表示，例如010代表长度为2），然后是各个字符的编码，以全1结束（例如，编码长度\n为2的小节以11结束）。编码文本以编码长度为000的小节结束。\n例如，编码头为$#\\，编码文本为0100000101101100011100101000，应这样解码：\n010(编码长度为2)00(#)00(#)10(*)11(小节结束)011(编码长度为3)000()111(小节结束)001(编码\n长度为1)0($)1(小节结束)000(编码结束)。\nSample input\nTNM AEIOU\n0010101100011\n1010001001110110011\n11000\n$#\n0100000101101100011100101000\nSample output\nTAN ME\n##*$\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=832\u0026amp;problem=149\u0026amp;mosmsg=Submission+received+with+ID+20759428\n/* 1、先接收字符串，因为有空格，所以我用了getline，因为我用string 2、然后我们将输入的字符串存入code这个二维数组里，code[i][j]中i代表二进制码的位数，j代表当前01码的十进制数。以此我们每次循环的j小于2^i-i即可。 3、然后我们用循环，先将三位的二进制数传入bin_dec()函数，来得出接下来代表一个字符的二进制码的位数。 4、contra()函数是用来进行每一组相同码长的字符的输出。 （1）其思路是用一个变量记录当前bcode（01码字符串）读到哪个位了。 （2）然后循环将之后的len位二进制变成一个整数，传入bin_dec()函数得出其代表的十进制数，而这个十进制数也是code数组的第二维的下标。 5、还有一点，因为二进制码在输入的过程中并不一定是在同一行,所以我用了：当前下标+要接受的码长 和 当前的01码字符串长度来进行比较，若大则接收新的一行字符串，再加到原先01码字符串后面。（！注意这里用的是while循环而不是单一次的if判断，是因为可能接收一次字串后也依然不够码长，所以要一直接收到足够长为止。）*/ #include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; char code[7][1\u0026lt;\u0026lt;7];//长度，值，来存字符 int bin_dec(int b)//二进制转十进制 { int dec=0; for(int i=0;b!","title":"uva 213 - Message Decoding（二进制编码）"},{"content":" 习题4-3 黑白棋（Othello, ACM/ICPC World Finals 1992, UVa220）\n你的任务是模拟黑白棋游戏的进程。黑白棋的规则为：黑白双方轮流放棋子，每次必须\n让新放的棋子“夹住”至少一枚对方棋子，然后把所有被新放棋子“夹住”的对方棋子替换成己\n方棋子。一段连续（横、竖或者斜向）的同色棋子被“夹住”的条件是两端都是对方棋子（不\n能是空位）。如图4-6（a）所示，白棋有6个合法操作，分别为(2,3),(3,3),(3,5), (6,2),(7,3),\n(7,4)。选择在(7,3)放白棋后变成如图4-6（b）所示效果（注意有竖向和斜向的共两枚黑棋变\n白）。注意(4,6)的黑色棋子虽然被夹住，但不是被新放的棋子夹住，因此不变白。\n（a） （b）\n图4-6 黑白棋\n输入一个8*8的棋盘以及当前下一次操作的游戏者，处理3种指令：\nL指令打印所有合法操作，按照从上到下，从左到右的顺序排列（没有合法操作时输出No legal move）。\nMrc指令放一枚棋子在(r,c)。如果当前游戏者没有合法操作，则是先切换游戏者再操作。输入保证这个操作是合法的。输出操作完毕后黑白方的棋子总数。\nQ指令退出游戏，并打印当前棋盘（格式同输入）。\nSample Input\n2\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n\u0026mdash;WB\u0026mdash;\n-\u0026ndash;BW\u0026mdash;\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\nW\nL\nM35\nL\nQ\nWWWWB\u0026mdash;\nWWWB\u0026mdash;-\nWWB\u0026mdash;\u0026ndash;\nWB\u0026mdash;\u0026mdash;\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\nB\nL\nM25\nL\nQ\nSample Output\n(3,5) (4,6) (5,3) (6,4)\nBlack - 1 White - 4\n(3,4) (3,6) (5,6)\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n\u0026mdash;-W\u0026mdash;\n\u0026mdash;WW\u0026mdash;\n\u0026mdash;BW\u0026mdash;\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\nNo legal move.\nBlack - 3 White - 12\n(3,5)\nWWWWB\u0026mdash;\nWWWWW\u0026mdash;\nWWB\u0026mdash;\u0026ndash;\nWB\u0026mdash;\u0026mdash;\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=833\u0026amp;problem=156\u0026amp;mosmsg=Submission+received+with+ID+20901787\n挺复杂的题，题目就比较难弄懂，要不是我会玩黑白翻转棋（笑），可能就很难办了吧。\n思路：\n1、用一个二维数组存储棋盘的状态，\n2、通过一个函数来翻转棋子，传进去的两个参数是落子的坐标\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;iomanip\u0026gt; using namespace std; char board[10][10]; int yesnum=0;//输出空格的格式 char disk,nodisk;//要走的棋，被翻的棋 //int exceed(int i,int j)//判断越界 //{ // if(i\u0026gt;=1\u0026amp;\u0026amp;i\u0026lt;=8\u0026amp;\u0026amp;j\u0026gt;=1\u0026amp;\u0026amp;j\u0026lt;=8) // return 1; // else // return 0; //} int reverse(int i,int j,int con)//(i,j)上应该是空的 { for(int in=-1;in\u0026lt;=1;in++)//八个方位的循环 { for(int jn=-1;jn\u0026lt;=1;jn++)//八个方位的循环用于翻棋子 { if(in==0\u0026amp;\u0026amp;jn==0) continue;//中间的棋不用管它先 // if(i+in\u0026gt;=1\u0026amp;\u0026amp;i+in\u0026lt;=8\u0026amp;\u0026amp;j+jn\u0026gt;=1\u0026amp;\u0026amp;j+jn\u0026lt;=8\u0026amp;\u0026amp;/*exceed(i+in,j+jn)\u0026amp;\u0026amp;*/ // board[i+in][j+jn]==nodisk)//可翻 //board[i+in][j+jn]==\u0026#39;-\u0026#39;)//有空位能放子 // { //cout\u0026lt;\u0026lt;\u0026#34;board \u0026#34;\u0026lt;\u0026lt;board[i+in][j+jn]\u0026lt;\u0026lt;endl; int n=1;//用于能翻的子的包的界限标志（说不懂，见下面第一个if） while((i+in*n\u0026gt;=1\u0026amp;\u0026amp;i+in*n\u0026lt;=8\u0026amp;\u0026amp;j+jn*n\u0026gt;=1\u0026amp;\u0026amp;j+jn*n\u0026lt;=8)\u0026amp;\u0026amp;/*exceed(i-in*n,j-jn*n)*///判断越界 board[i+in*n][j+jn*n]==nodisk)//还能继续翻 { n++; } if(board[i+in*n][j+jn*n]==disk\u0026amp;\u0026amp;n\u0026gt;1)//包住了，就翻这么多 { //cout\u0026lt;\u0026lt;i+in*n\u0026lt;\u0026lt;\u0026#34;_\u0026#34;\u0026lt;\u0026lt;j+jn*n\u0026lt;\u0026lt;\u0026#34;_\u0026#34;\u0026lt;\u0026lt;board[i+in*n][j+jn*n]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;endl; if(con==\u0026#39;L\u0026#39;) { if(yesnum\u0026gt;0) cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;)\u0026#34;; yesnum++; return 0; } else { for(int n2=0;n2\u0026lt;n;n2++)//翻转操作，--n为了不bang掉最后的disk { board[i+in*n2][j+jn*n2]=disk; } } //break; } //} } } } int main() { int T; cin\u0026gt;\u0026gt;T; while(T--) { for(int i=1;i\u0026lt;=8;i++)//存表 for(int j=1;j\u0026lt;=8;j++) cin\u0026gt;\u0026gt;board[i][j]; char con;//下一个子，操作 cin\u0026gt;\u0026gt;disk; int Wnum=0,Bnum=0; while(cin\u0026gt;\u0026gt;con\u0026amp;\u0026amp;con!=\u0026#39;Q\u0026#39;) { if(disk==\u0026#39;W\u0026#39;) nodisk = \u0026#39;B\u0026#39;; else nodisk = \u0026#39;W\u0026#39;; //cout\u0026lt;\u0026lt;\u0026#34;disk \u0026#34;\u0026lt;\u0026lt;disk\u0026lt;\u0026lt;endl; if(con==\u0026#39;L\u0026#39;)//显示下一步可走子 { yesnum=0; for(int i=1;i\u0026lt;=8;i++)//全地图遍历 { for(int j=1;j\u0026lt;=8;j++)//全地图遍历 { if(board[i][j]==\u0026#39;-\u0026#39;)//如果可以翻 { //cout\u0026lt;\u0026lt;disk\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; ij \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl; reverse(i,j,\u0026#39;L\u0026#39;); } } } if(!yesnum) { cout\u0026lt;\u0026lt;\u0026#34;No legal move.\u0026#34;; if(disk==\u0026#39;W\u0026#39;) disk=\u0026#39;B\u0026#39;; else disk = \u0026#39;W\u0026#39;; } cout\u0026lt;\u0026lt;endl; } else { int x; cin\u0026gt;\u0026gt;x; reverse(x/10,x%10,\u0026#39;M\u0026#39;); Bnum=Wnum=0; for(int i=1;i\u0026lt;=8;i++) for(int j=1;j\u0026lt;=8;j++) if(board[i][j]==\u0026#39;B\u0026#39;) Bnum++; else if(board[i][j]==\u0026#39;W\u0026#39;) Wnum++; cout\u0026lt;\u0026lt;\u0026#34;Black -\u0026#34;\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;Bnum\u0026lt;\u0026lt;\u0026#34; White -\u0026#34;\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;Wnum\u0026lt;\u0026lt;endl; if(disk==\u0026#39;W\u0026#39;) disk=\u0026#39;B\u0026#39;; else disk = \u0026#39;W\u0026#39;; } } for(int i=1;i\u0026lt;=8;i++) { for(int j=1;j\u0026lt;=8;j++) cout\u0026lt;\u0026lt;board[i][j]; cout\u0026lt;\u0026lt;endl; } if(T\u0026gt;=1) cout\u0026lt;\u0026lt;endl; } return 0; } //AC at 2018/3/9 （题外话：这个题一个月多前就通过了，但是一直拖到现在才写博客，我都忘了当时遇到的困难和当时的思路了。那时是因为要准备蓝桥杯，所以就没再做这本书上的题了，这一个月里发生了不少事，团队天梯赛，蓝桥杯，清明，英语活动。\n又去了两趟医院去看眼睛，对于要靠电脑吃饭的人来说，眼睛是绝对不能出问题的，但是啊哎，好希望若要研究程序的话，能抛开肉体的限制就好了。存在于网络上的文化乐园也岌岌可危，我无能为力，我要争取机会去往乐园能深深扎根的地方）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-220-othello%E9%BB%91%E7%99%BD%E7%BF%BB%E8%BD%AC%E6%A3%8B/","summary":"习题4-3 黑白棋（Othello, ACM/ICPC World Finals 1992, UVa220）\n你的任务是模拟黑白棋游戏的进程。黑白棋的规则为：黑白双方轮流放棋子，每次必须\n让新放的棋子“夹住”至少一枚对方棋子，然后把所有被新放棋子“夹住”的对方棋子替换成己\n方棋子。一段连续（横、竖或者斜向）的同色棋子被“夹住”的条件是两端都是对方棋子（不\n能是空位）。如图4-6（a）所示，白棋有6个合法操作，分别为(2,3),(3,3),(3,5), (6,2),(7,3),\n(7,4)。选择在(7,3)放白棋后变成如图4-6（b）所示效果（注意有竖向和斜向的共两枚黑棋变\n白）。注意(4,6)的黑色棋子虽然被夹住，但不是被新放的棋子夹住，因此不变白。\n（a） （b）\n图4-6 黑白棋\n输入一个8*8的棋盘以及当前下一次操作的游戏者，处理3种指令：\nL指令打印所有合法操作，按照从上到下，从左到右的顺序排列（没有合法操作时输出No legal move）。\nMrc指令放一枚棋子在(r,c)。如果当前游戏者没有合法操作，则是先切换游戏者再操作。输入保证这个操作是合法的。输出操作完毕后黑白方的棋子总数。\nQ指令退出游戏，并打印当前棋盘（格式同输入）。\nSample Input\n2\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n\u0026mdash;WB\u0026mdash;\n-\u0026ndash;BW\u0026mdash;\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\nW\nL\nM35\nL\nQ\nWWWWB\u0026mdash;\nWWWB\u0026mdash;-\nWWB\u0026mdash;\u0026ndash;\nWB\u0026mdash;\u0026mdash;\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\n-\u0026mdash;\u0026mdash;-\nB\nL\nM25\nL\nQ\nSample Output\n(3,5) (4,6) (5,3) (6,4)\nBlack - 1 White - 4\n(3,4) (3,6) (5,6)\n-\u0026mdash;\u0026mdash;-","title":"uva 220 - Othello（黑白翻转棋）"},{"content":" 例题5-12 城市正视图（Urban Elevations, ACM/ICPC World Finals 1992, UVa221）\n如图5-4所示，有n（n≤100）个建筑物。左侧是俯视图（左上角为建筑物编号，右下角\n为高度），右侧是从南向北看的正视图。\n图5-4 建筑俯视图与正视图\n输入每个建筑物左下角坐标（即x、y坐标的最小值）、宽度（即x方向的长度）、深度\n（即y方向的长度）和高度（以上数据均为实数），输出正视图中能看到的所有建筑物，按\n照左下角x坐标从小到大进行排序。左下角x坐标相同时，按y坐标从小到大排序。\n输入保证不同的x坐标不会很接近（即任意两个x坐标要么完全相同，要么差别足够大，\n不会引起精度问题）。\nSample Input\n14\n160 0 30 60 30\n125 0 32 28 60\n95 0 27 28 40\n70 35 19 55 90\n0 0 60 35 80\n0 40 29 20 60\n35 40 25 45 80\n0 67 25 20 50\n0 92 90 20 80\n95 38 55 12 50\n95 60 60 13 30\n95 80 45 25 50\n165 65 15 15 25\n165 85 10 15 35\n0\nSample Output\nFor map #1, the visible buildings are numbered as follows:\n5 9 4 3 10 2 1 14\n本家地址\nx，y：建筑位置，z：建筑高度\n存储所有的建筑的头尾x坐标。\n然后依次遍历建筑，判断每个建筑是否能够显现。\n判断的方式就是依次遍历每个建筑，然后针对每个建筑遍历x坐标，寻找能够显示出建筑的x坐标范围。\n判断能否显示的方式：先判断x坐标范围是否在建筑x范围内，若在，遍历建筑群，比较同样在x范围内的建筑的y坐标。以此得出是否能够显示此建筑。\n（这已经有3层循环了，得利于建筑最多只有100个）\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; /* 两个方块的比较: 比 x, y, 高 先比 x, 小的 小 x 相同 比 存方块 vector\u0026lt;Build\u0026gt; 存x map\u0026lt;int, vector\u0026lt;int\u0026gt; \u0026gt; x-\u0026gt;List[index] 插入新的build 比x, 若已有 若无则插入, =\u0026gt; 得到前一个: 得到前一个中组中的最后一个(即宽度最大的) 比其是否 \u0026gt; this 若 \u0026lt; : 无视 若 \u0026gt; : 比y 得到后一个: 比 this.宽度+x 是否大于 后一个的x - - 得到显示的方块 - 排序 */ class Build{ public: double x,y,w,d,h; int index; bool operator \u0026lt;(const Build \u0026amp;bb){ if(x \u0026lt; bb.x) return true; else if(x==bb.x) return y \u0026lt; bb.y; else return false; } }; vector\u0026lt;Build\u0026gt; buildList; vector\u0026lt;int\u0026gt; xList; int isShow(int bi, int xx){ if(buildList[bi].x \u0026lt; xx \u0026amp;\u0026amp; buildList[bi].x+buildList[bi].w \u0026gt; xx){ for(int i=0;i\u0026lt;buildList.size();i++){ if(i!=bi \u0026amp;\u0026amp; buildList[i].x \u0026lt; xx \u0026amp;\u0026amp; buildList[i].x+buildList[i].w \u0026gt; xx \u0026amp;\u0026amp; buildList[i].y \u0026lt; buildList[bi].y \u0026amp;\u0026amp; buildList[i].h \u0026gt;= buildList[bi].h){ return 0; } } return 1; } /* 不在范围 */ return -1; } int main(){ int T; int N=1; while(cin\u0026gt;\u0026gt;T \u0026amp;\u0026amp; T){ buildList.clear(); xList.clear(); for(int i=1;i\u0026lt;=T;i++){ double x,y,w,d,h; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;w\u0026gt;\u0026gt;d\u0026gt;\u0026gt;h; Build b; b.x = x; b.y = y; b.w = w; b.d = d; b.h = h; b.index = i; buildList.push_back(b); xList.push_back(x); xList.push_back(x+w); } sort(buildList.begin(), buildList.end()); sort(xList.begin(), xList.end()); vector\u0026lt;int\u0026gt;::iterator vi = unique(xList.begin(), xList.end()); xList.erase(vi,xList.end()); if(N\u0026gt;1){ cout\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;\u0026#34;For map #\u0026#34;\u0026lt;\u0026lt; N++ \u0026lt;\u0026lt;\u0026#34;, the visible buildings are numbered as follows:\u0026#34;\u0026lt;\u0026lt;endl; int one = 0; for(int i=0;i\u0026lt;buildList.size();i++){ int show = 0; for(int j=0;j\u0026lt;xList.size()-1;j++){ int xi = (xList[j] + xList[j+1]) / 2; show = isShow(i,xi); if(show==1){ break; } } if(show==1){ if(one){ cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;buildList[i].index; one = 1; } } cout\u0026lt;\u0026lt;endl; } return 0; } // AC at 2020/09/10 ps：这个题是后面雕塑家的铺垫，百思不得，痛苦万分，想到了一个方向但是由于不知道对错而不敢继续深入，这是一个问题，理应的思维方式是dfs形式，但是我由于踌躇变成了bfs。要冷静，要好好思考，不能被外物干扰。\n现实中的诱惑越来越多，甚至医治我们的“良药”也变成了诱惑，任何缓解型“药物“都有成瘾性。我们要想一个办法才行。\n同伴有时候救命稻草，有时却又变成隐形荆棘。坚定自我，我们还是需要同伴的，因为即便是自我解决方案也是依靠创造虚假同伴来间接解决。\n人的需求之一：群体的认可。人作为群体趋向型生物，离开群体便会开始走向异变。我在思考：群居的必须性，如何做到呢。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-221-urban-elevations%E5%9F%8E%E5%B8%82%E6%AD%A3%E8%A7%86%E5%9B%BE-by-sucicada/","summary":"例题5-12 城市正视图（Urban Elevations, ACM/ICPC World Finals 1992, UVa221）\n如图5-4所示，有n（n≤100）个建筑物。左侧是俯视图（左上角为建筑物编号，右下角\n为高度），右侧是从南向北看的正视图。\n图5-4 建筑俯视图与正视图\n输入每个建筑物左下角坐标（即x、y坐标的最小值）、宽度（即x方向的长度）、深度\n（即y方向的长度）和高度（以上数据均为实数），输出正视图中能看到的所有建筑物，按\n照左下角x坐标从小到大进行排序。左下角x坐标相同时，按y坐标从小到大排序。\n输入保证不同的x坐标不会很接近（即任意两个x坐标要么完全相同，要么差别足够大，\n不会引起精度问题）。\nSample Input\n14\n160 0 30 60 30\n125 0 32 28 60\n95 0 27 28 40\n70 35 19 55 90\n0 0 60 35 80\n0 40 29 20 60\n35 40 25 45 80\n0 67 25 20 50\n0 92 90 20 80\n95 38 55 12 50","title":"UVA 221 - Urban Elevations(城市正视图) By SuCicada"},{"content":" 习题3-5 谜题（Puzzle, ACM/ICPC World Finals 1993, UVa227）\n有一个5*5的网格，其中恰好有一个格子是空的，其他格子各有一个字母。一共有4种指\n令：A, B, L, R，分别表示把空格上、下、左、右的相邻字母移到空格中。输入初始网格和指\n令序列（以数字0结束），输出指令执行完毕后的网格。如果有非法指令，应输出“This\npuzzle has no final configuration.\n还有：输入的迷宫以大写 Z 结束。输出的行与行间要有一行空行\nSample Input\nTRGSJ\nXDOKI\nM VLN\nWPABE\nUQHCF\nARRBBL0\nABCDE\nFGHIJ\nKLMNO\nPQRS\nTUVWX\nAAA\nLLLL0\nABCDE\nFGHIJ\nKLMNO\nPQRS\nTUVWX\nAAAAABBRRRLL0\nZ\nSample Output\nPuzzle #1:\nT R G S J\nX O K L I\nM D V B N\nW P A E\nU Q H C F\nPuzzle #2:\nA B C D\nF G H I E\nK L M N J\nP Q R S O\nT U V W X\nPuzzle #3:\nThis puzzle has no final configuration.\n（注意：例子中有PQRS的那一行后是有空格的，在用样例测试时注意不要丢失）\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=163\u0026amp;mosmsg=Submission+received+with+ID+20487026\n//思路没什么难的，通过判断指令的字符是什么，来替换空格用它上下左右的元素。 //主要是逻辑上容易出错，还有就是一些容易忽视的小陷阱。 //要注意的都写在了注释里 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; void dis(char puzz[5][5])//为了在测试时方便观看过程写了函数 { for(int i=0;i\u0026lt;5;i++) { for(int j=0;j\u0026lt;4;j++) cout\u0026lt;\u0026lt;puzz[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;//注意每行最后一个字符后不能有空格 cout\u0026lt;\u0026lt;puzz[i][4]; cout\u0026lt;\u0026lt;endl; } } int main() { char puzz[5][5]; char mov; int N=1;//次数 int si,sj;//空格坐标 while(gets(puzz[0])\u0026amp;\u0026amp;puzz[0][0]!=\u0026#39;Z\u0026#39;)//先接收第一行，以便好判断Z { //cout\u0026lt;\u0026lt;puzz[0][0]\u0026lt;\u0026lt;endl; int iff=1;//0为越出数组网格 // gets(puzz[0]); // if(puzz[0][0]==\u0026#39;Z\u0026#39;)//判断可以写在里面 // break; for(int i=0;i\u0026lt;5;i++) { if(i\u0026gt;0) gets(puzz[i]); //scanf(\u0026#34;%[^\\n]\u0026#34;,puzz[i]); for(int j=0;j\u0026lt;5;j++) { //cout\u0026lt;\u0026lt;puzz[i][j]; if(puzz[i][j]==\u0026#39; \u0026#39;) { si=i; sj=j; } } //cout\u0026lt;\u0026lt;endl; } //dis(puzz);cout\u0026lt;\u0026lt;si\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;sj\u0026lt;\u0026lt;endl; while((mov=getchar())!=\u0026#39;0\u0026#39;) { switch(mov) { case \u0026#39;L\u0026#39;: if(sj-1\u0026lt;0){iff=0;break;} puzz[si][sj]=puzz[si][sj-1];//让移动位代替空格即可，不必将移动位换成空格 sj--; break; case \u0026#39;R\u0026#39;: if(sj+1\u0026gt;4){iff=0;break;} puzz[si][sj]=puzz[si][sj+1]; sj++; break; case \u0026#39;A\u0026#39;: if(si-1\u0026lt;0){iff=0;break;} //cout\u0026lt;\u0026lt;\u0026#34;___A\u0026#34;\u0026lt;\u0026lt;endl; puzz[si][sj]=puzz[si-1][sj]; si--; break; case \u0026#39;B\u0026#39;: if(si+1\u0026gt;4){iff=0;break;} puzz[si][sj]=puzz[si+1][sj]; si++; break; } //if(iff==0) break; } if(N!=1)//采用先换行再输出，所以第一次输出前不能有空行 cout\u0026lt;\u0026lt;endl; printf(\u0026#34;Puzzle #%d:\\n\u0026#34;,N++); if(iff==0) { cout\u0026lt;\u0026lt;\u0026#34;This puzzle has no final configuration.\u0026#34;\u0026lt;\u0026lt;endl; } else { puzz[si][sj]=\u0026#39; \u0026#39;; dis(puzz); } getchar();//回收0后的换行符 //cout\u0026lt;\u0026lt;\u0026#34;end\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/14 ps:写一篇文章平均要花去20+分钟时间\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-227-puzzle-%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC/","summary":"习题3-5 谜题（Puzzle, ACM/ICPC World Finals 1993, UVa227）\n有一个5*5的网格，其中恰好有一个格子是空的，其他格子各有一个字母。一共有4种指\n令：A, B, L, R，分别表示把空格上、下、左、右的相邻字母移到空格中。输入初始网格和指\n令序列（以数字0结束），输出指令执行完毕后的网格。如果有非法指令，应输出“This\npuzzle has no final configuration.\n还有：输入的迷宫以大写 Z 结束。输出的行与行间要有一行空行\nSample Input\nTRGSJ\nXDOKI\nM VLN\nWPABE\nUQHCF\nARRBBL0\nABCDE\nFGHIJ\nKLMNO\nPQRS\nTUVWX\nAAA\nLLLL0\nABCDE\nFGHIJ\nKLMNO\nPQRS\nTUVWX\nAAAAABBRRRLL0\nZ\nSample Output\nPuzzle #1:\nT R G S J\nX O K L I\nM D V B N\nW P A E\nU Q H C F","title":"uva 227 - Puzzle （迷宫中的空格）"},{"content":" 习题3-6 纵横字谜的答案（Crossword Answers, ACM/ICPC World Finals 1994,\nUVa232）\n输入一个r行c列（1≤r，c≤10）的网格，黑格用“*”表示，每个白格都填有一个字母。如\n果一个白格的左边相邻位置或者上边相邻位置没有白格（可能是黑格，也可能出了网格边\n界），则称这个白格是一个起始格。\n首先把所有起始格按照从上到下、从左到右的顺序编号为1, 2, 3,…，如图所示。\n接下来要找出所有横向单词（Across）。这些单词必须从一个起始格开始，向右延伸到\n一个黑格的左边或者整个网格的最右列。最后找出所有竖向单词（Down）。这些单词必须\n从一个起始格开始，向下延伸到一个黑格的上边或者整个网格的最下行。\n输出时每两行之间有空行\nSample Input\n2 2\nAT\nO\n6 7\nAIMDEN\nMEONE\nUPONTO\nSOERIN\nSAOR*\nIES*DEA\n0\nSample Output\npuzzle #1:\nAcross\n1.AT\n3.O\nDown\n1.A\n2.TO\npuzzle #2:\nAcross\n1.AIM\n4.DEN\n7.ME\n8.ONE\n9.UPON\n11.TO\n12.SO\n13.ERIN\n15.SA\n17.OR\n18.IES\n19.DEA\nDown\n1.A\n2.IMPOSE\n3.MEO\n4.DO\n5.ENTIRE\n6.NEON\n9.US\n10.NE\n14.ROD\n16.AS\n18.I\n20.A\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=168\u0026amp;mosmsg=Submission+received+with+ID+20505776\n关于char数组和动态指针做的数组 1.前者下标可以越界，后者一旦越界即便没有操作那个地方的元素，也会程序出错。 2.后者好在大小可以自定义。而却因为下标越界问题导致有些算法判断的地方需要多些代码。 (其实即便是动态数组，只要在创建时将行列多建几个就行了) //以汉字书写顺序，先左到右，在上到下依次边遍历，边输出， //凡是输出的格子以@代替，之所以不用*代替是为了统计起始格的个数。 //本题因为说了行列的范围，所以直接用char型的二维数组即可。 //而我没注意以为是任意行列的数组，所以用了动态内存分配生成二维数组。（代码数多在这了） //其他注意点在代码里注释了。 #include\u0026lt;iostream\u0026gt; #include\u0026lt;iomanip\u0026gt; using namespace std; int hang,lie; //测试用的显示函数 //void dis(char **puzz) //{ // for(int i=0;i\u0026lt;hang;i++) // { // for(int j=0;j\u0026lt;lie;j++) // cout\u0026lt;\u0026lt;puzz[i][j]; // cout\u0026lt;\u0026lt;endl; // } //} char** creat() { char **puzz; puzz=new char*[hang]; for(int i=0;i\u0026lt;hang;i++) puzz[i]=new char[lie]; return puzz; } void print(char **puzz,char AD) { int i,j,pi,pj,*pij;//p系列是为打印一组字符的 if(AD==\u0026#39;A\u0026#39;) { cout\u0026lt;\u0026lt;\u0026#34;Across\u0026#34;; pij=\u0026amp;pj; } if(AD==\u0026#39;D\u0026#39;) { cout\u0026lt;\u0026lt;\u0026#34;Down\u0026#34;; pij=\u0026amp;pi; } int qsg=0; for(i=0;i\u0026lt;hang;i++) for(j=0;j\u0026lt;lie;j++) { //cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;puzz[i][j]\u0026lt;\u0026lt;\u0026#34; ????\u0026#34;\u0026lt;\u0026lt;endl; if(puzz[i][j]==\u0026#39;*\u0026#39;)//把*当作起始格就不好了 continue; bool iff=false; if(j==0||i==0)//找起始格 { iff=true; qsg++; } else if(puzz[i][j-1]==\u0026#39;*\u0026#39;||puzz[i-1][j]==\u0026#39;*\u0026#39;)//为了防止j-1和i-1小于0的情况 { iff=true; qsg++; } if(iff) { if(puzz[i][j]==\u0026#39;@\u0026#39;)//虽然此元素也在起始格，但是因为已经被走过了，所以不允许其捣乱 continue;//不能break cout\u0026lt;\u0026lt;endl//开始一组才换行，防止多余空行 \u0026lt;\u0026lt;setw(3)//注意是3格的右对齐 \u0026lt;\u0026lt;qsg\u0026lt;\u0026lt;\u0026#34;.\u0026#34;; pi=i; pj=j; while(puzz[pi][pj]!=\u0026#39;*\u0026#39;)//输出across的字符 { cout\u0026lt;\u0026lt;puzz[pi][pj]; puzz[pi][pj]=\u0026#39;@\u0026#39;; (*pij)++; if(!(pj\u0026lt;lie\u0026amp;\u0026amp;pi\u0026lt;hang))//一旦下标越界，就会出错 break; // if(AD==\u0026#39;A\u0026#39;) // j++; // if(AD==\u0026#39;D\u0026#39;) // i++; } } //if(pj\u0026lt;lie\u0026amp;\u0026amp;pi\u0026lt;hang)//还有更好的办法吗//yes //cout\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;endl; } int main() { int num=1; while(cin\u0026gt;\u0026gt;hang\u0026amp;\u0026amp;hang!=0) { cin\u0026gt;\u0026gt;lie; if(num\u0026gt;1) cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;puzzle #\u0026#34;\u0026lt;\u0026lt;num++\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;endl; char **puzz; puzz=creat();//必须把指针传回来 for(int i=0;i\u0026lt;hang;i++)//原始迷宫 for(int j=0;j\u0026lt;lie;j++) { //puzz[i][j]=\u0026#39;o\u0026#39;; cin\u0026gt;\u0026gt;puzz[i][j]; } //dis(puzz); char **puzz2; puzz2=creat(); for(int i=0;i\u0026lt;hang;i++)//克隆的迷宫 for(int j=0;j\u0026lt;lie;j++) puzz2[i][j]=puzz[i][j]; print(puzz,\u0026#39;A\u0026#39;); //cout\u0026lt;\u0026lt;endl; print(puzz2,\u0026#39;D\u0026#39;); // cout\u0026lt;\u0026lt;endl; // dis(puzz2); } return 0; } //AC at 2017/12/18 （题外话：一开始想出大体逻辑花了30+分钟，而一直到写成并通过花了3个晚上的算法题时间+，累计是3+小时吧，写的时候逻辑混乱，代码一改再改。 每次写都会查很多东西。）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-232-crossword-answers%E7%BA%B5%E6%A8%AA%E8%BF%B7%E5%AE%AB/","summary":"习题3-6 纵横字谜的答案（Crossword Answers, ACM/ICPC World Finals 1994,\nUVa232）\n输入一个r行c列（1≤r，c≤10）的网格，黑格用“*”表示，每个白格都填有一个字母。如\n果一个白格的左边相邻位置或者上边相邻位置没有白格（可能是黑格，也可能出了网格边\n界），则称这个白格是一个起始格。\n首先把所有起始格按照从上到下、从左到右的顺序编号为1, 2, 3,…，如图所示。\n接下来要找出所有横向单词（Across）。这些单词必须从一个起始格开始，向右延伸到\n一个黑格的左边或者整个网格的最右列。最后找出所有竖向单词（Down）。这些单词必须\n从一个起始格开始，向下延伸到一个黑格的上边或者整个网格的最下行。\n输出时每两行之间有空行\nSample Input\n2 2\nAT\nO\n6 7\nAIMDEN\nMEONE\nUPONTO\nSOERIN\nSAOR*\nIES*DEA\n0\nSample Output\npuzzle #1:\nAcross\n1.AT\n3.O\nDown\n1.A\n2.TO\npuzzle #2:\nAcross\n1.AIM\n4.DEN\n7.ME\n8.ONE\n9.UPON\n11.TO\n12.SO\n13.ERIN\n15.SA\n17.OR\n18.IES\n19.DEA\nDown\n1.A\n2.IMPOSE\n3.MEO\n4.DO\n5.ENTIRE\n6.NEON\n9.US\n10.NE\n14.ROD\n16.AS","title":"uva 232 - Crossword Answers（纵横迷宫）"},{"content":" 习题4-4 骰子涂色（Cube painting, UVa 253）\n输入两个骰子，判断二者是否等价。每个骰子用6个字母表示，如图4-7所示。\n图4-7 骰子涂色\n例如rbgggr和rggbgr分别表示如图4-8所示的两个骰子。二者是等价的，因为图4-8（a）\n所示的骰子沿着竖直轴旋转90°之后就可以得到图4-8（b）所示的骰子。\n（a） （b）\n图4-8 旋转前后的两个骰子\n.\nSample Input\nrbgggrrggbgr\nrrrbbbrrbbbr\nrbgrbgrrrrrg\nSample Output\nTRUE\nFALSE\nFALSE\n思路：暴力枚举，将一个骰子的所有姿态都列出来，\n1、注意第一个图上的数字，那个是记录骰子面的顺序\n2、先找最上面的，也就是1的位置，能排列6种（1，2，3，4，5，6）\n3、然后找到了上面也就找到了与其相对的面，就是下面，就是字串中第六个元素。这个不会额外记录，因为有上就有下了。\n4、然后就是中间四个的排列了，很显然，4种。\n5、然后我们变换第二个骰子，看看它在这24种情况中，有没有一种的情况和第一个骰子的记录是相同的。（比较字串即可）\n6、请注意骰子面的转换是否正确，虽然这个逻辑简单，但是容易写错，要好好检查，我就因为写错下标错了两次。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; /* 1 3 2 4 5 1在顶上 6 2 3 6 4 1 2在顶上 5 3 5 6 2 1\t3在顶上 4 4 2 6 5 1\t4在顶上 3 5 4 6 3 1\t5在顶上 2 6 3 5 4 2\t6在顶上 1 */ string s1,s2;//记录两个骰子的字符串 int str_equal(string a,char s1,char s2,char s3,char s4,char s5,char s6)//比较两个字串相等吗 { string b=\u0026#34;0000000\u0026#34;; b[1]=s1; b[2]=s2; b[3]=s3; b[4]=s4; b[5]=s5; b[6]=s6; //cout\u0026lt;\u0026lt;b.substr(1)\u0026lt;\u0026lt;endl; if(a==b) return 1; return 0; } int exc(string a,char s1,char s2,char s3,char s4,char s5,char s6)//中间四个面的四种情况 { if(str_equal(a,s1,s2,s3,s4,s5,s6)) return 1; if(str_equal(a,s1,s3,s5,s2,s4,s6)) return 1; if(str_equal(a,s1,s5,s4,s3,s2,s6)) return 1; if(str_equal(a,s1,s4,s2,s5,s3,s6)) return 1; return 0; } int main() { char c; while(cin\u0026gt;\u0026gt;c) { // cin\u0026gt;\u0026gt;s1; // s2=s1.substr(5); // s1.assign(s1,0,6); // cout\u0026lt;\u0026lt;s1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;s2\u0026lt;\u0026lt;endl; //以上注释是一种输入方法，以下是另一种 s1=s2=\u0026#34;0000000\u0026#34;; s1[1]=c; for(int i=2;i\u0026lt;=6;i++) //因为s1[1]已经在while中输入了 cin\u0026gt;\u0026gt;s1[i]; for(int i=1;i\u0026lt;=6;i++) cin\u0026gt;\u0026gt;s2[i]; //cout\u0026lt;\u0026lt;s1.substr(1)\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;s2\u0026lt;\u0026lt;endl; if(exc(s1,s2[1],s2[2],s2[3],s2[4],s2[5],s2[6])){cout\u0026lt;\u0026lt;\u0026#34;TRUE\u0026#34;\u0026lt;\u0026lt;endl;continue;} if(exc(s1,s2[2],s2[6],s2[3],s2[4],s2[1],s2[5])){cout\u0026lt;\u0026lt;\u0026#34;TRUE\u0026#34;\u0026lt;\u0026lt;endl;continue;} if(exc(s1,s2[3],s2[6],s2[5],s2[2],s2[1],s2[4])){cout\u0026lt;\u0026lt;\u0026#34;TRUE\u0026#34;\u0026lt;\u0026lt;endl;continue;} if(exc(s1,s2[4],s2[6],s2[2],s2[5],s2[1],s2[3])){cout\u0026lt;\u0026lt;\u0026#34;TRUE\u0026#34;\u0026lt;\u0026lt;endl;continue;} if(exc(s1,s2[5],s2[6],s2[4],s2[3],s2[1],s2[2])){cout\u0026lt;\u0026lt;\u0026#34;TRUE\u0026#34;\u0026lt;\u0026lt;endl;continue;} if(exc(s1,s2[6],s2[5],s2[3],s2[4],s2[2],s2[1])){cout\u0026lt;\u0026lt;\u0026#34;TRUE\u0026#34;\u0026lt;\u0026lt;endl;continue;} cout\u0026lt;\u0026lt;\u0026#34;FALSE\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } //AC at 2018/4/20 题外话：（\n休战一个月后的第一道题，手生的很（才不），这道题的灵感还是来自蓝桥的直播课上老师演示的二阶魔方转换题（然而并并不会做）\n因为最近一直看python，所以都不会用c++的string了，其中将字符连接起来就伤了我脑筋，不得已用了同样暴力的传进6+个参数的方法。（所谓一暴到底吗）\n啊啊好想做后面的题，一直窝在第四章，会来不及看真正有用的算法的，本来以外蓝桥后算法会松一些，但是比赛还有（好事不是吗），我会继续努力的（乖孩子的话语，不喜欢）\n）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-253-cube-painting%E7%9B%B8%E5%90%8C%E9%AA%B0%E5%AD%90/","summary":"习题4-4 骰子涂色（Cube painting, UVa 253）\n输入两个骰子，判断二者是否等价。每个骰子用6个字母表示，如图4-7所示。\n图4-7 骰子涂色\n例如rbgggr和rggbgr分别表示如图4-8所示的两个骰子。二者是等价的，因为图4-8（a）\n所示的骰子沿着竖直轴旋转90°之后就可以得到图4-8（b）所示的骰子。\n（a） （b）\n图4-8 旋转前后的两个骰子\n.\nSample Input\nrbgggrrggbgr\nrrrbbbrrbbbr\nrbgrbgrrrrrg\nSample Output\nTRUE\nFALSE\nFALSE\n思路：暴力枚举，将一个骰子的所有姿态都列出来，\n1、注意第一个图上的数字，那个是记录骰子面的顺序\n2、先找最上面的，也就是1的位置，能排列6种（1，2，3，4，5，6）\n3、然后找到了上面也就找到了与其相对的面，就是下面，就是字串中第六个元素。这个不会额外记录，因为有上就有下了。\n4、然后就是中间四个的排列了，很显然，4种。\n5、然后我们变换第二个骰子，看看它在这24种情况中，有没有一种的情况和第一个骰子的记录是相同的。（比较字串即可）\n6、请注意骰子面的转换是否正确，虽然这个逻辑简单，但是容易写错，要好好检查，我就因为写错下标错了两次。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; /* 1 3 2 4 5 1在顶上 6 2 3 6 4 1 2在顶上 5 3 5 6 2 1\t3在顶上 4 4 2 6 5 1\t4在顶上 3 5 4 6 3 1\t5在顶上 2 6 3 5 4 2\t6在顶上 1 */ string s1,s2;//记录两个骰子的字符串 int str_equal(string a,char s1,char s2,char s3,char s4,char s5,char s6)//比较两个字串相等吗 { string b=\u0026#34;0000000\u0026#34;; b[1]=s1; b[2]=s2; b[3]=s3; b[4]=s4; b[5]=s5; b[6]=s6; //cout\u0026lt;\u0026lt;b.","title":"uva 253 - Cube painting（相同骰子）"},{"content":" 例题6-11 四分树（Quadtrees, UVa 297）\n如图6-8所示，可以用四分树来表示一个黑白图像，方法是用根结点表示整幅图像，然\n后把行列各分成两等分，按照图中的方式编号，从左到右对应4个子结点。如果某子结点对\n应的区域全黑或者全白，则直接用一个黑结点或者白结点表示；如果既有黑又有白，则用一\n个灰结点表示，并且为这个区域递归建树。\n图6-8 四分树\n给出两棵四分树的先序遍历，求二者合并之后（黑色部分合并）黑色像素的个数。p表\n示中间结点，f表示黑色（full），e表示白色（empty）。\n样例输入：\n3\nppeeefpffeefe\npefepeefe\npeeef\npeefe\npeeef\npeepefefe\n样例输出：\nThere are 640 black pixels.\nThere are 512 black pixels.\nThere are 384 black pixels.\n本家\n构造32*32的矩阵，构建树木的时候同时给矩阵染色，由于黑色会覆盖，所以也不怕树木之间的冲突。然后最后刷一下矩阵，看看有多少个黑块块就行（即数字为1）\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; /* 共5+1层 32*32=4^5 */ int SIDE_LENGTH = 32; int quad[100][100]; int sum = 0; /* f \u0026gt; p \u0026gt; e */ void build(int side,int x,int y){ char c; cin\u0026gt;\u0026gt;c; if(c==\u0026#39;p\u0026#39;){ for(int xi=0;xi\u0026lt;=1;xi++){ for(int yi=0;yi\u0026lt;=1;yi++){ int nextSide = side / 2; int xx = x+nextSide*xi; int yy = y+nextSide*yi; build(nextSide,xx,yy); } } }else if(c==\u0026#39;f\u0026#39;){ /* fill $quad from $begin to $end */ for(int xi=x;xi\u0026lt;x+side;xi++){ for(int yi=y;yi\u0026lt;y+side;yi++){ if(quad[xi][yi]==0){ sum++; quad[xi][yi] = 1; } } } } } int main(){ int T; cin\u0026gt;\u0026gt;T; while(T--){ // memset(quad,0,SIDE_LENGTH*SIDE_LENGTH*sizeof(int)); for(int i=0;i\u0026lt;SIDE_LENGTH;i++){ for(int j=0;j\u0026lt;SIDE_LENGTH;j++){ quad[i][j]=0; } } sum = 0; for(int i=0;i\u0026lt;2;i++){ build(SIDE_LENGTH,0,0); } cout\u0026lt;\u0026lt;\u0026#34;There are \u0026#34;\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;\u0026#34; black pixels.\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } // AC at 2020/07/26 这个题遇到了 runtime error的错误，百思不得其解，甚至都开始在oj上debug（指注释代码定位错误消失情况）。后来才发现原来是build函数，设置了int作为返回值类型在一开始，但是没有给出一个return，导致，太不谨慎了。\nps：This blog is to make up for yesterday before yesterday. Recently, I often feel a headache, dizziness, and sleepiness. It must be because I used to stay up late day after day.\nToday I will continue to caught a AC, and then read English.\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-297-quadtrees-%E5%9B%9B%E5%88%86%E6%95%B0-by-sucicada/","summary":"例题6-11 四分树（Quadtrees, UVa 297）\n如图6-8所示，可以用四分树来表示一个黑白图像，方法是用根结点表示整幅图像，然\n后把行列各分成两等分，按照图中的方式编号，从左到右对应4个子结点。如果某子结点对\n应的区域全黑或者全白，则直接用一个黑结点或者白结点表示；如果既有黑又有白，则用一\n个灰结点表示，并且为这个区域递归建树。\n图6-8 四分树\n给出两棵四分树的先序遍历，求二者合并之后（黑色部分合并）黑色像素的个数。p表\n示中间结点，f表示黑色（full），e表示白色（empty）。\n样例输入：\n3\nppeeefpffeefe\npefepeefe\npeeef\npeefe\npeeef\npeepefefe\n样例输出：\nThere are 640 black pixels.\nThere are 512 black pixels.\nThere are 384 black pixels.\n本家\n构造32*32的矩阵，构建树木的时候同时给矩阵染色，由于黑色会覆盖，所以也不怕树木之间的冲突。然后最后刷一下矩阵，看看有多少个黑块块就行（即数字为1）\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; /* 共5+1层 32*32=4^5 */ int SIDE_LENGTH = 32; int quad[100][100]; int sum = 0; /* f \u0026gt; p \u0026gt; e */ void build(int side,int x,int y){ char c; cin\u0026gt;\u0026gt;c; if(c==\u0026#39;p\u0026#39;){ for(int xi=0;xi\u0026lt;=1;xi++){ for(int yi=0;yi\u0026lt;=1;yi++){ int nextSide = side / 2; int xx = x+nextSide*xi; int yy = y+nextSide*yi; build(nextSide,xx,yy); } } }else if(c==\u0026#39;f\u0026#39;){ /* fill $quad from $begin to $end */ for(int xi=x;xi\u0026lt;x+side;xi++){ for(int yi=y;yi\u0026lt;y+side;yi++){ if(quad[xi][yi]==0){ sum++; quad[xi][yi] = 1; } } } } } int main(){ int T; cin\u0026gt;\u0026gt;T; while(T--){ // memset(quad,0,SIDE_LENGTH*SIDE_LENGTH*sizeof(int)); for(int i=0;i\u0026lt;SIDE_LENGTH;i++){ for(int j=0;j\u0026lt;SIDE_LENGTH;j++){ quad[i][j]=0; } } sum = 0; for(int i=0;i\u0026lt;2;i++){ build(SIDE_LENGTH,0,0); } cout\u0026lt;\u0026lt;\u0026#34;There are \u0026#34;\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;\u0026#34; black pixels.","title":"UVA 297 - Quadtrees （四分数） By SuCicada"},{"content":" 实现一个经典\u0026quot;猜数字\u0026quot;游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确\n（A），有多少数字在两个序列都出现过但位置不对（B）。\n输入包含多组数据。每组输入第一行为序列长度n，第二行是答案序列，接下来是若干\n猜测序列。猜测序列全0时该组数据结束。n=0时输入结束。\n样例输入：\n4\n1 3 5 5\n1 1 2 3\n4 3 3 5\n6 5 5 1\n6 1 3 5\n1 3 5 5\n0 0 0 0\n10\n1 2 2 2 4 5 6 6 6 9\n1 2 3 4 5 6 7 8 9 1\n1 1 2 2 3 3 4 4 5 5\n1 2 1 3 1 5 1 6 1 9\n1 2 2 5 5 5 6 6 6 7\n0 0 0 0 0 0 0 0 0 0\n0\n样例输出：\nGame 1:\n(1,1)\n(2,0)\n(1,2)\n(1,2)\n(4,0)\nGame 2:\n(2,4)\n(3,2)\n(5,0)\n(7,0)\n题目来自刘汝佳书，以下是原网址:\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=829\u0026amp;page=show_problem\u0026amp;problem=276\n//比较原数串和所猜数串,先将位置一样的找出,再对位置非-1(未匹配)的所猜数串元素和原数串诸位对比. //所有比较过的位上的元素都替换为-1,防止二次匹配。 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; void output(int *a); int input(int *a,int n) { int iff=0; int i; for(i=0;i\u0026lt;n;i++) { cin\u0026gt;\u0026gt;a[i]; if(a[i]==0) iff++; } a[i+1]=\u0026#39;\\0\u0026#39;; if(iff==n) return 0; return 1; } void cop(int *coped,int *copee,int n) { for(int i=0;i\u0026lt;n;i++) { copee[i]=coped[i]; } } //void output(int a[]) //{ // //cout\u0026lt;\u0026lt;\u0026#34;!\u0026#34;\u0026lt;\u0026lt;sizeof(a)\u0026lt;\u0026lt;endl;//之所以是4，是因为a只是一个指针 // for(int i=0;a[i]!=\u0026#39;\\0\u0026#39;;i++) // cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; // cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; //} void guess(int *s,int *a,int n) { int r=0,b=0; int *bb=new int[n]; cop(s,bb,n); for(int j=0;j\u0026lt;n;j++) { if(a[j]==bb[j]) { a[j]=bb[j]=-1; r++; } } for(int j=0;j\u0026lt;n;j++) { if(a[j]==-1) continue; for(int i=0;i\u0026lt;n;i++) { //cout\u0026lt;\u0026lt;\u0026#34;!!\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; if(a[j]==bb[i]) { a[j]=bb[i]=-1; //output(bb); // output(a); b++; break; } } } printf(\u0026#34; (%d,%d)\\n\u0026#34;,r,b); delete []bb; } int main() { int n,gn=1; int ori[1005]={0}; int gus[1005]={0}; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)==1\u0026amp;\u0026amp;n!=0) { cout\u0026lt;\u0026lt;\u0026#34;Game \u0026#34;\u0026lt;\u0026lt;gn++\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;endl; input(ori,n); //cout\u0026lt;\u0026lt;\u0026#34;!\u0026#34;\u0026lt;\u0026lt;sizeof(ori)\u0026lt;\u0026lt;endl; //output(ori); while(input(gus,n)==1) { //output(gus); guess(ori,gus,n); } } return 0; } 和书上的参考代码相比，这个代码太冗长。反思：\n1.不能拘泥于题目的逻辑和固定的平常思维。\n2.要的是巧解而不是解出。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-340-master-mind-hints%E7%8C%9C%E6%95%B0%E4%B8%B2/","summary":"实现一个经典\u0026quot;猜数字\u0026quot;游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确\n（A），有多少数字在两个序列都出现过但位置不对（B）。\n输入包含多组数据。每组输入第一行为序列长度n，第二行是答案序列，接下来是若干\n猜测序列。猜测序列全0时该组数据结束。n=0时输入结束。\n样例输入：\n4\n1 3 5 5\n1 1 2 3\n4 3 3 5\n6 5 5 1\n6 1 3 5\n1 3 5 5\n0 0 0 0\n10\n1 2 2 2 4 5 6 6 6 9\n1 2 3 4 5 6 7 8 9 1\n1 1 2 2 3 3 4 4 5 5\n1 2 1 3 1 5 1 6 1 9","title":"uva 340 \tMaster-Mind Hints（猜数串）"},{"content":" 例题5-8 Unixls命令（Unix ls，UVa400） 输入正整数n以及n个文件名，按照字典序排序后按列优先的方式左对齐输出。 假设最长文件名有M字符，则最右列有M字符，其他列都是M＋2字符。\nSample Input\n10\ntiny\n2short4me\nvery_long_file_name\nshorter\nsize-1\nsize2\nsize3\nmuch_longer_name\n12345678.123\nmid_size_name\n12\nWeaser\nAlfalfa\nStimey\nBuckwheat\nPorky\nJoe\nDarla\nCotton\nButch\nFroggy\nMrs_Crabapple\nP.D.\n19\nMr._French\nJody\nBuffy\nSissy\nKeith\nDanny\nLori\nChris\nShirley\nMarsha\nJan\nCindy\nCarol\nMike\nGreg\nPeter\nBobby\nAlice\nRuben\nSample Output\n------------------------------------------------------------ 12345678.123 size-1 2short4me size2 mid_size_name size3 much_longer_name tiny shorter very_long_file_name ------------------------------------------------------------ Alfalfa Cotton Joe Porky Buckwheat Darla Mrs_Crabapple Stimey Butch Froggy P.D. Weaser ------------------------------------------------------------ Alice Chris Jan Marsha Ruben Bobby Cindy Jody Mike Shirley Buffy Danny Keith Mr._French Sissy Carol Greg Lori Peter https://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;problem=341\n[注意] 一行最后一个单词后面不要有两个空格\n[注意] 每组最后一个单词后面不用空2格\n算行数时向上取整\n输出时,设置额外的break条件,即已经输出完最后一个,不要继续越界输出\n其余看代码\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cmath\u0026gt; using namespace std; /* [注意] 一行最后一个单词后面不要有两个空格 [注意] 每组最后一个单词后面不用空2格 算行数时向上取整 输出时,设置额外的break条件,即已经输出完最后一个,不要继续越界输出 */ int main() { int N; while(cin\u0026gt;\u0026gt;N){ vector\u0026lt;string\u0026gt; list; int max_len = 0; for(int i=0;i\u0026lt;N;i++){ string str; cin\u0026gt;\u0026gt;str; max_len = max_len \u0026lt; str.size() ? str.size() : max_len; list.push_back(str); } sort(list.begin(), list.end()); int count_col = 0; // 列数 int count_line = 0; //行数 count_col = (60+2) / (max_len+2); count_line = ceil((double)list.size() / count_col); //[注意]这里除的时候要转换为浮点型 // cout\u0026lt;\u0026lt;list.size()\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;(double)list.size() / count_col + 0.5\u0026lt;\u0026lt;endl; // cout\u0026lt;\u0026lt;max_len\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;count_col\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;count_line\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;60;i++) cout\u0026lt;\u0026lt;\u0026#34;-\u0026#34;; cout\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;count_line;i++){ // 第几行 for(int k=0; k\u0026lt;count_col \u0026amp;\u0026amp; (i+k*count_line)\u0026lt;list.size(); k++){ // 第几列, 循环判断条件中,加上判输出单词个数足够 if(k\u0026gt;0) //作为两个词块之间间隔的空格,每行第一个之前没有 cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; string out = list[i+k*count_line]; cout\u0026lt;\u0026lt;out; //输出每个单词后面的占位空格 (不算单词块之间2个空格的间隔) for(int j=0;j\u0026lt;max_len-out.size();j++) cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } } return 0; } // AC at 2019/2/2 00:22 没什么难度,注意注意点就行, 感谢 udebug\nhttps://www.udebug.com/UVa/400\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-400-unix-ls-unixls%E5%91%BD%E4%BB%A4/","summary":"例题5-8 Unixls命令（Unix ls，UVa400） 输入正整数n以及n个文件名，按照字典序排序后按列优先的方式左对齐输出。 假设最长文件名有M字符，则最右列有M字符，其他列都是M＋2字符。\nSample Input\n10\ntiny\n2short4me\nvery_long_file_name\nshorter\nsize-1\nsize2\nsize3\nmuch_longer_name\n12345678.123\nmid_size_name\n12\nWeaser\nAlfalfa\nStimey\nBuckwheat\nPorky\nJoe\nDarla\nCotton\nButch\nFroggy\nMrs_Crabapple\nP.D.\n19\nMr._French\nJody\nBuffy\nSissy\nKeith\nDanny\nLori\nChris\nShirley\nMarsha\nJan\nCindy\nCarol\nMike\nGreg\nPeter\nBobby\nAlice\nRuben\nSample Output\n------------------------------------------------------------ 12345678.123 size-1 2short4me size2 mid_size_name size3 much_longer_name tiny shorter very_long_file_name ------------------------------------------------------------ Alfalfa Cotton Joe Porky Buckwheat Darla Mrs_Crabapple Stimey Butch Froggy P.","title":"UVA 400 - Unix ls (Unixls命令)"},{"content":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=829\u0026amp;problem=342\u0026amp;mosmsg=Submission+received+with+ID+20398535\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; string r=\u0026#34;A 3 HIL JM O 2TUVWXY501SE Z 8 \u0026#34;; char *m_c=\u0026#34;AHIMOTUVWXY018\u0026#34;; char mir_c(char c) { if(c\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;Z\u0026#39;) { c=r[c-\u0026#39;A\u0026#39;]; } else if(c\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;)//如果不是else if 那么变成2的S又会变回S c=r[c-\u0026#39;0\u0026#39;+26]; return c; } int main() { string s; while(cin\u0026gt;\u0026gt;s) { int n=s.size(); int m1=2,m2=3,i;//先判断对称，再判断镜像 for(i=0;i\u0026lt;n/2;i++) { if(s[i]!=s[n-i-1]) m1=1; if(mir_c(s[i])!=s[n-i-1]) { //cout\u0026lt;\u0026lt;mir_c(s[i])\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;s[n-i-1]; m2=1; } } if((n%2==1)\u0026amp;\u0026amp;strchr(m_c,s[n/2])==NULL) m2=1;//判断中间一位是不是镜像的 //cout\u0026lt;\u0026lt;m1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;m2\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;s; switch(m1*=m2) { case 1:cout\u0026lt;\u0026lt;\u0026#34; -- is not a palindrome.\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;endl;break; case 2:cout\u0026lt;\u0026lt;\u0026#34; -- is a regular palindrome.\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;endl;break; case 3:cout\u0026lt;\u0026lt;\u0026#34; -- is a mirrored string.\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;endl;break; case 6:cout\u0026lt;\u0026lt;\u0026#34; -- is a mirrored palindrome.\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;endl;break; } } return 0; } ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-401%E5%9B%9E%E6%96%87%E8%AF%8D/","summary":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=829\u0026amp;problem=342\u0026amp;mosmsg=Submission+received+with+ID+20398535\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; string r=\u0026#34;A 3 HIL JM O 2TUVWXY501SE Z 8 \u0026#34;; char *m_c=\u0026#34;AHIMOTUVWXY018\u0026#34;; char mir_c(char c) { if(c\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;Z\u0026#39;) { c=r[c-\u0026#39;A\u0026#39;]; } else if(c\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;)//如果不是else if 那么变成2的S又会变回S c=r[c-\u0026#39;0\u0026#39;+26]; return c; } int main() { string s; while(cin\u0026gt;\u0026gt;s) { int n=s.size(); int m1=2,m2=3,i;//先判断对称，再判断镜像 for(i=0;i\u0026lt;n/2;i++) { if(s[i]!=s[n-i-1]) m1=1; if(mir_c(s[i])!=s[n-i-1]) { //cout\u0026lt;\u0026lt;mir_c(s[i])\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;s[n-i-1]; m2=1; } } if((n%2==1)\u0026amp;\u0026amp;strchr(m_c,s[n/2])==NULL) m2=1;//判断中间一位是不是镜像的 //cout\u0026lt;\u0026lt;m1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;m2\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;s; switch(m1*=m2) { case 1:cout\u0026lt;\u0026lt;\u0026#34; -- is not a palindrome.","title":"uva 401（回文词）"},{"content":" 习题3-4 周期串（Periodic Strings, UVa455）\n如果一个字符串可以由某个长度为k的字符串重复多次得到，则称该串以k为周期。例\n如，abcabcabcabc以3为周期（注意，它也以6和12为周期）。\n输入一个长度不超过80的字符串，输出其最小周期。\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=396\u0026amp;mosmsg=Submission+received+with+ID+20473859\n//先找到和第一个元素相等的下一个元素，然后第一个元素位和找到的元素位依次往后过， //一直到结束，若一直一样则周期为找到的元素位。 //比如ababcababc， //1.s[0]先找到了和s[1]相等,然后分析， //2.s[0+1]和s[1+1]比，相等。 //3.s[0+1+1]再和s[1+1+1],不等，跳出 //4.s[0]再和s[2],s[3],s[4]比。。。 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; const int N = 80; char s[N+5]; int cir(int i) { int n=strlen(s); if(n%i!=0)//防止aba或abca输出2或3而不是3或4的情况 return 0; for(int j=i;j\u0026lt;strlen(s);j++)//顺次比较前后字串相等否 { if(s[j-i]!=s[j]) { return 0; } } return i; } int main () { int tt; scanf(\u0026#34;%d\u0026#34;,\u0026amp;tt); while(tt--) { scanf(\u0026#34;\\n%s\u0026#34;,s); int T=0;//周期 int i,n=strlen(s); for(i=1;i\u0026lt;n;i++) { if(s[0]==s[i]) { if((T=cir(i))==i) { break; } } } cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; if(tt!=0) cout\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/11 几周前就看见了这道题，寻思良久不得要领，本以为很难，今日侥幸做出。\n一开始一直WA。感谢http://bbs.csdn.net/topics/391840422的一楼小子。原来这种做法有陷阱。\n所谓缘分做题不过与此。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-455-periodic-strings-%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%A8%E6%9C%9F/","summary":"习题3-4 周期串（Periodic Strings, UVa455）\n如果一个字符串可以由某个长度为k的字符串重复多次得到，则称该串以k为周期。例\n如，abcabcabcabc以3为周期（注意，它也以6和12为周期）。\n输入一个长度不超过80的字符串，输出其最小周期。\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=830\u0026amp;problem=396\u0026amp;mosmsg=Submission+received+with+ID+20473859\n//先找到和第一个元素相等的下一个元素，然后第一个元素位和找到的元素位依次往后过， //一直到结束，若一直一样则周期为找到的元素位。 //比如ababcababc， //1.s[0]先找到了和s[1]相等,然后分析， //2.s[0+1]和s[1+1]比，相等。 //3.s[0+1+1]再和s[1+1+1],不等，跳出 //4.s[0]再和s[2],s[3],s[4]比。。。 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; const int N = 80; char s[N+5]; int cir(int i) { int n=strlen(s); if(n%i!=0)//防止aba或abca输出2或3而不是3或4的情况 return 0; for(int j=i;j\u0026lt;strlen(s);j++)//顺次比较前后字串相等否 { if(s[j-i]!=s[j]) { return 0; } } return i; } int main () { int tt; scanf(\u0026#34;%d\u0026#34;,\u0026amp;tt); while(tt--) { scanf(\u0026#34;\\n%s\u0026#34;,s); int T=0;//周期 int i,n=strlen(s); for(i=1;i\u0026lt;n;i++) { if(s[0]==s[i]) { if((T=cir(i))==i) { break; } } } cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; if(tt!","title":"uva 455 - Periodic Strings （找字符串周期）"},{"content":" 例题4-2 刽子手游戏（Hangman Judge, UVa 489）\n刽子手游戏其实是一款猜单词游戏，如图4-\n1所示。游戏规则是这样的：计算机想一个单词\n让你猜，你每次可以猜一个字母。如果单词里有\n那个字母，所有该字母会显示出来；如果没有那\n个字母，则计算机会在一幅“刽子手”画上填一\n笔。这幅画一共需要7笔就能完成，因此你最多\n只能错6次。注意，猜一个已经猜过的字母不！算\n错。\n在本题中，你的任务是编写一个“裁判”程\n序，输入单词和玩家的猜测，判断玩家赢了\n（You win.）、输了（You lose.）还是放弃了\n（You chickened out.）。每组数据包含3行，第1\n行是游戏编号（-1为输入结束标记），第2行是\n计算机想的单词，第3行是玩家的猜测。后两行\n保证只含小写字母。\n注意，猜一个已经猜过的字母不算\n错。！\nSample Input\n1\ncheese\nchese\n2\ncheese\nabcdefg\n3\ncheese\nabcdefgij\n-1\nSample Output\nRound 1\nYou win.\nRound 2\nYou chickened out.\nRound 3\nYou lose.\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=832\u0026amp;page=show_problem\u0026amp;problem=430\n用两个整型来记录当前还允许错的次数，和原始字符串的总字符数\n1，因为重复猜测不算错，所以我们先将guess字符串中的重复字符消去，用循环和string::erase()\n2，外循环猜测字符串，内循环原始字符串，如果相同，就将原始字符串的此元素变成‘ * ’。\n3，没猜中一次就记录，内循环结束后来更新记录。若果win或lose就return函数，否则循环都结束之后就说明是‘弃权’。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; string orig,guess; int hang(int num,int right) { for(int i=0;i\u0026lt;guess.size();i++) { int iff=0; for(int j=0;j\u0026lt;orig.size();j++) { if(orig[j]==guess[i]) { orig[j]=\u0026#39;*\u0026#39;; iff=1; num--; } if(num==0) { cout\u0026lt;\u0026lt;\u0026#34;You win.\u0026#34;\u0026lt;\u0026lt;endl; return 1;//break; } } if(iff==0) { right--; } if(right\u0026lt;0) { cout\u0026lt;\u0026lt;\u0026#34;You lose.\u0026#34;\u0026lt;\u0026lt;endl; return -1; } // if(num==0) // { // cout\u0026lt;\u0026lt;\u0026#34;win\u0026#34;\u0026lt;\u0026lt;endl; // break; // } } cout\u0026lt;\u0026lt;\u0026#34;You chickened out.\u0026#34;\u0026lt;\u0026lt;endl; } int main() { int T; while(cin\u0026gt;\u0026gt;T\u0026amp;\u0026amp;T!=-1) { cin\u0026gt;\u0026gt;orig\u0026gt;\u0026gt;guess; for(int i=0;i\u0026lt;guess.size();i++) { for(int j=i+1;j\u0026lt;guess.size();j++) { if(guess[j]==guess[i]) guess.erase(guess.begin()+j); } } //cout\u0026lt;\u0026lt;guess\u0026lt;\u0026lt;endl; int right=6;//错误次数 int num=orig.size();//要猜的个数 cout\u0026lt;\u0026lt;\u0026#34;Round \u0026#34;\u0026lt;\u0026lt;T\u0026lt;\u0026lt;endl; hang(num,right); } return 0; } //AC at 2018/2/7 ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-489-hangman-judge%E5%90%8A%E4%BA%BA%E6%B8%B8%E6%88%8F/","summary":"例题4-2 刽子手游戏（Hangman Judge, UVa 489）\n刽子手游戏其实是一款猜单词游戏，如图4-\n1所示。游戏规则是这样的：计算机想一个单词\n让你猜，你每次可以猜一个字母。如果单词里有\n那个字母，所有该字母会显示出来；如果没有那\n个字母，则计算机会在一幅“刽子手”画上填一\n笔。这幅画一共需要7笔就能完成，因此你最多\n只能错6次。注意，猜一个已经猜过的字母不！算\n错。\n在本题中，你的任务是编写一个“裁判”程\n序，输入单词和玩家的猜测，判断玩家赢了\n（You win.）、输了（You lose.）还是放弃了\n（You chickened out.）。每组数据包含3行，第1\n行是游戏编号（-1为输入结束标记），第2行是\n计算机想的单词，第3行是玩家的猜测。后两行\n保证只含小写字母。\n注意，猜一个已经猜过的字母不算\n错。！\nSample Input\n1\ncheese\nchese\n2\ncheese\nabcdefg\n3\ncheese\nabcdefgij\n-1\nSample Output\nRound 1\nYou win.\nRound 2\nYou chickened out.\nRound 3\nYou lose.\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=832\u0026amp;page=show_problem\u0026amp;problem=430\n用两个整型来记录当前还允许错的次数，和原始字符串的总字符数\n1，因为重复猜测不算错，所以我们先将guess字符串中的重复字符消去，用循环和string::erase()\n2，外循环猜测字符串，内循环原始字符串，如果相同，就将原始字符串的此元素变成‘ * ’。\n3，没猜中一次就记录，内循环结束后来更新记录。若果win或lose就return函数，否则循环都结束之后就说明是‘弃权’。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; string orig,guess; int hang(int num,int right) { for(int i=0;i\u0026lt;guess.","title":"uva 489 - Hangman Judge（吊人游戏）"},{"content":" 习题4-6 莫尔斯电码（Morse Mismatches, ACM/ICPC World Finals 1997, UVa508）\n输入每个字母的Morse编码，一个词典以及若干个编码。对于每个编码，判断它可能是\n哪个单词。如果有多个单词精确匹配，选取字典序第一个再加上“!”；如果无法精确匹\n配，可以在编码尾部增加或删除一些字符以后匹配某个单词（增加或删除的字符应尽量少）。如果有多个单词可以这样匹配上，选取字典序第一个输出并且在后面加上“?”。\n。\n提供一个样例\nSample Input\nA .-\nB -\u0026hellip;\nC -.-.\nD -..\nE .\nF ..-.\nG \u0026ndash;.\nH \u0026hellip;.\nI ..\nJ .\u0026mdash;\nK -.-\nL .-..\nM \u0026ndash;\nN -.\nO \u0026mdash;\nP .\u0026ndash;.\nQ \u0026ndash;.-\nR .-.\nS \u0026hellip;\nT -\nU ..-\nV \u0026hellip;-\nW .\u0026ndash;\nX -..-\nY -.\u0026ndash;\nZ \u0026ndash;..\n0 \u0026mdash;\u0026mdash;\n1 .\u0026mdash;\u0026ndash;\n2 ..\u0026mdash;\n3 \u0026hellip;\u0026ndash;\n4 \u0026hellip;.-\n5 \u0026hellip;..\n6 -\u0026hellip;.\n7 \u0026ndash;\u0026hellip;\n8 \u0026mdash;..\n9 \u0026mdash;-.\nAN\nEARTHQUAKE\nEAT\nGOD\nHATH\nIM\nREADY\nTO\nWHAT\nWROTH\n*\n.\u0026ndash;\u0026hellip;..\u0026ndash; \u0026hellip;..\u0026ndash;\u0026hellip;.\n\u0026ndash;.\u0026mdash;-.. .\u0026ndash;.-.\u0026mdash;-..\n.\u0026ndash;\u0026hellip;..\u0026ndash; .\u0026ndash;.\n..-.-.-\u0026hellip;.\u0026ndash;.-..-.\u0026ndash;.-.\n..\u0026ndash; .-\u0026hellip;\u0026ndash;..-.\u0026ndash;\n\u0026mdash;- ..\u0026ndash;\n*\nSample Output\nWHAT\nHATH\nGOD\nWROTH?\nWHAT\nAN\nEARTHQUAKE\nEAT!\nREADY\nTO\nEAT!\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=833\u0026amp;problem=449\u0026amp;mosmsg=Submission+received+with+ID+21190426\n解释一下阅读题：输入：\n先输入字符与摩斯码的对应，以 * 结束 ，\n再输入字典（字典的意思就是你解密的词语只能从这里选取），以 * 结束，\n在输入需要解密的摩斯码 ，以 * 结束。\n几个注意点：\n1、经过多方求证，第二个输入的字典，需要以字典序排列好，这样在查找词组时才能按照字典序查找。\n2、刘汝佳书中写的书错的，不是任意选取一个输出，是按照字典序选取\n3、udebug中有一个样例输出结果有问题\n4、只要是模糊匹配，就加上 ？ ，无论匹配到几个合适的\n思路：\n1、使用两个map映射，或者四个两对vector，来分别存储‘真实字符’和‘每个真实字符的摩斯码’，‘字典里的每个词组’和‘字典里每个词组对应的摩斯码’（这个需要经过加密运算后进行存储）\n（因为是要存的数组中每个元素都是字符串型，所以我选取了vector string\u0026gt;来进行存储）\n（可以使用map来进行存储，而且map默认字典序存储）\n2、一个函数加密，一个函数解密，通过遍历边比来进行比对出模糊匹配中最小的增删字符长度\n附赠样例对照表一份\n/* AN .--. EARTHQUAKE ..-.-.-....--.-..-.--.-. EAT ..-- GOD --.----.. HATH .....--.... IM ..-- READY .-...--..-.-- TO ---- WHAT .--.....-- WROTH .--.-.----.... */ //在匹配到的中，应选择字符最少的词组 //比如：A . B - C.- 那么.-xx就应该是C #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; char word[50]; //存真实字符 vector\u0026lt;string\u0026gt; morse; //存字符的摩斯码 vector\u0026lt;string\u0026gt; dict; //存词组的字典 vector\u0026lt;string\u0026gt; puzzle; //存字典对应的摩斯码 vector\u0026lt;string\u0026gt; question; //存要解的摩斯码 string zip(string str) //词组加密成摩斯码 { string ans; for(int i=0;i\u0026lt;str.size();i++) { for(int j=0;j\u0026lt;26+10;j++) { if(str[i]==word[j]) { ans = ans +morse[j]; break; } } } return ans; } string solove(string mos) //从摩斯解密为词组 { int jingzhun_n=-1,jingzhun=0; //精准匹配的下标，个数 int mohu_n=-1,mohu=0,mohu_len=999; //模糊匹配的下标，个数，模糊字符长度 int yes;//匹配位数 int length=mos.size(); int puzz_len; //遍历中的词组的长度 for(int i=0;i\u0026lt;puzzle.size();i++) //遍历所有的词语 { puzz_len=puzzle[i].size(); yes =0; //匹配的字符数量 //cout\u0026lt;\u0026lt;length\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;puzz_len\u0026lt;\u0026lt;endl; for(int j=0;j\u0026lt;puzz_len\u0026amp;\u0026amp;j\u0026lt;length;j++) //遍历每个词语摩斯码的每一位 { if(mos[j]==puzzle[i].at(j)) { yes++; //cout\u0026lt;\u0026lt;yes\u0026lt;\u0026lt;\u0026#34;||||\u0026#34;\u0026lt;\u0026lt;endl; } else break; }//for(j if(yes==puzz_len\u0026amp;\u0026amp;length==puzz_len) //精准匹配 { if(jingzhun\u0026lt;1) jingzhun_n=i; jingzhun++; } else if(yes==puzz_len\u0026amp;\u0026amp;length\u0026gt;yes|| //模糊匹配，mose长 yes\u0026lt;puzz_len\u0026amp;\u0026amp;yes==length) //当前词组长 { if(mohu_len\u0026gt;abs(puzz_len-length)) { mohu_len= abs(puzz_len-length); // cout\u0026lt;\u0026lt;\u0026#34;\\||||\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;mohu\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;dict[mohu_n]\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;endl; mohu_n= i; mohu++; } } }//for(i if(jingzhun\u0026gt;0) { if(jingzhun\u0026gt;1) return dict[jingzhun_n]+\u0026#34;!\u0026#34;; return dict[jingzhun_n]; } else if(mohu\u0026gt;0) { return dict[mohu_n]+\u0026#34;?\u0026#34;; } else return dict[0]; } int main() { //输入字符和对应的摩斯码 for(int i=0;;i++) { string temp; char c; cin\u0026gt;\u0026gt;c; if(c==\u0026#39;*\u0026#39;) break; word[i]=c; cin\u0026gt;\u0026gt;temp; morse.push_back(temp); } //输入词组的字典 string temp; while(cin\u0026gt;\u0026gt;temp\u0026amp;\u0026amp;temp!=\u0026#34;*\u0026#34;) { dict.push_back(temp); } sort(dict.begin(),dict.end()); //输入要解密的摩斯码 while(cin\u0026gt;\u0026gt;temp\u0026amp;\u0026amp;temp!=\u0026#34;*\u0026#34;) { question.push_back(temp); } //输入结束 //计算加密后的字典中的词组 for(int i=0;i\u0026lt;dict.size();i++) { string temp2 =zip(dict[i]); puzzle.push_back(temp2); } //开始解密 for(int i=0;i\u0026lt;question.size();i++) { //cout\u0026lt;\u0026lt;question[i]\u0026lt;\u0026lt;\u0026#34;????\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;solove(question[i])\u0026lt;\u0026lt;endl; } // cout\u0026lt;\u0026lt;dict.size()\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;puzzle.size()\u0026lt;\u0026lt;endl; // for(int i=0;i\u0026lt;puzzle.size();i++) // { // cout\u0026lt;\u0026lt;dict[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; // cout\u0026lt;\u0026lt;puzzle[i]\u0026lt;\u0026lt;endl; // } return 0; } //AC at 2018/4/23 （题外话：解出题目的时候是很高兴的，写出程序是很高兴的，不能写程序的话我就要死了，这道题我早上开始做，不知不觉占用了所有的空闲时间，导致别人分配给我的任务都没有做，我真的是。）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-508-morse-mismatches%E6%91%A9%E6%96%AF%E7%A0%81/","summary":"习题4-6 莫尔斯电码（Morse Mismatches, ACM/ICPC World Finals 1997, UVa508）\n输入每个字母的Morse编码，一个词典以及若干个编码。对于每个编码，判断它可能是\n哪个单词。如果有多个单词精确匹配，选取字典序第一个再加上“!”；如果无法精确匹\n配，可以在编码尾部增加或删除一些字符以后匹配某个单词（增加或删除的字符应尽量少）。如果有多个单词可以这样匹配上，选取字典序第一个输出并且在后面加上“?”。\n。\n提供一个样例\nSample Input\nA .-\nB -\u0026hellip;\nC -.-.\nD -..\nE .\nF ..-.\nG \u0026ndash;.\nH \u0026hellip;.\nI ..\nJ .\u0026mdash;\nK -.-\nL .-..\nM \u0026ndash;\nN -.\nO \u0026mdash;\nP .\u0026ndash;.\nQ \u0026ndash;.-\nR .-.\nS \u0026hellip;\nT -\nU ..-\nV \u0026hellip;-\nW .\u0026ndash;\nX -..-\nY -.\u0026ndash;\nZ \u0026ndash;..\n0 \u0026mdash;\u0026mdash;","title":"uva 508 - Morse Mismatches（摩斯码）"},{"content":" 习题4-7 RAID技术（RAID!, ACM/ICPC World Finals 1997, UVa509）\nRAID技术用多个磁盘保存数据。每份数据在不止一个磁盘上保存，因此在某个磁盘损\n坏时能通过其他磁盘恢复数据。本题讨论其中一种RAID技术。数据被划分成大小\n为s（1≤s≤64）比特的数据块保存在d（2≤d≤6）个磁盘上，如图4-9所示，每d-1个数据块都\n有一个校验块，使得每d个数据块的异或结果为全0（偶校验）或者全1（奇校验）。\n图4-9 数据保存情况\n例如，d=5，s=2，偶校验，数据6C7A79EDFC（二进制01101100 01111010 01111001\n11101101 11111100）的保存方式如图4-10所示。\n图4-10 数据6C7A79EDPC的保存方式\n其中加粗块是校验块。输入d、s、b、校验的种类（E表示偶校验，O表示奇校验）以\n及b（1≤b≤100）个数据块（其中“x”表示损坏的数据），你的任务是恢复并输出完整的数\n据。如果校验错或者由于损坏数据过多无法恢复，应报告磁盘非法。\nSample Input\n5 2 5\nE\n0001011111\n0110111011\n1011011111\n1110101100\n0010010111\n3 2 5\nE\n0001111111\n0111111011\nxx11011111\n3 5 1\nO\n11111\n11xxx\nx1111\n0\nSample Output\nDisk set 1 is valid, contents are: 6C7A79EDFC\nDisk set 2 is invalid.\nDisk set 3 is valid, contents are: FFC\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=833\u0026amp;problem=450\u0026amp;mosmsg=Submission+received+with+ID+21205211\n注意点：\n（行列块的顺序就按照图中的，一个磁盘道是一列）\n1、校验块是不加入十六进制运算的\n2、校验块的顺序是第一行的第一块，第二行的第二个，到了某行最后一个时，下一行就有从第一个开始算做校验块\n3、十六进制转换是 一个十六进制数字需要四个二进制数字，所以每四位二进制就是一位十六进制\n4、校验进行是一行中每个块的相同位进行校验\n5、奇校验就是每个数互相异或下来是1，偶校验就是0\n6、磁盘不合理有两种可能性：一是已知的位校验不符合，二是未知位有多位，无法判断其内容\n7、关于输入的内容：\n第一个数是磁盘道数，即列数，\n第二个数是每个数据块中包含的二进制位个数\n第三个数是有多少行数据，就是行数\n8、题输入的数据流的分段没有意义，需要后期排列\n9、数据存储是先存完一个磁道再存下一个，即按列的顺序竖的存（在这里栽过）\n思路：\n1、存储数据：使用三维数组，或二维向量vector（元素是string或int），我用的三维数组，可以想象成每个数据块就是在行和列组成的平面上拔地而起向上的01列\n2、整体分两部分：补全缺的位，以及转换十六进制\n3、补全：先循环行，再循环块里的位，用每一位循环列，每一列的当前位进行异或处理，结果和校验奇偶性即0，1一样即可，不一样就是错的，如果有 x ，那先记录下来 x 的下标，最后算完后的结果就是 x 的值。如果有多个 x ，就是错的。\n4、二进制转十六进制：可以十六行暴力解，也可以转成十进制，大于9的六个数罗列输出\n5、注意输入开始三个数的顺序\n6、可以使用一个函数来看存储的数据。\n没了\n这个代码我使用了动态分配的数组，网上查的，挺有意思，C语言的三重指针真的是很奇妙，指针这种东西本身也是个变量，他特别的就是里面存的值是别的变量的地址罢了，仅此而已，无论几重指针都是如此\n//uva 509 RAID（磁盘数据） #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; /* 1 0 1 1 1 0 0 0 0 0 1 1 */ //列个行 bca int a,b,c; //数据块（几行），磁盘（一行几个，列）,一单位数据几位 //一个显示三维表的函数，辅助，不用也可以 void show(char ***disk) { for(int i=0;i\u0026lt;a;i++) { for(int j=0;j\u0026lt;b;j++) { for(int k=0;k\u0026lt;c;k++) cout\u0026lt;\u0026lt;disk[i][j][k]; cout\u0026lt;\u0026lt;\u0026#34;_\u0026#34;; } cout\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;endl; } int repair(char ***disk,int od_ev)//od_ev直接传来0或1 { //应该先循环a，再循环c，后循环b //找到一位然后 循环一行中所有的这个位 //cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;a;i++) { for(int k=0;k\u0026lt;c;k++) { int yihuo=0; int x_num=-1; for(int j=0;j\u0026lt;b;j++) { // cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;k\u0026lt;\u0026lt;endl; // show(disk); if(disk[i][j][k]==\u0026#39;x\u0026#39;) { if(x_num!=-1) return 0;//disk invalid x_num=j; } else yihuo=yihuo^(disk[i][j][k]-\u0026#39;0\u0026#39;); } if(x_num!=-1) disk[i][x_num][k] = yihuo^od_ev+\u0026#39;0\u0026#39;; else if(yihuo!=od_ev) return -1; //数据错误 } } return 1; } char hex(string bin)//char b1,char b2,char b3,char b4) { //cout\u0026lt;\u0026lt;bin\u0026lt;\u0026lt;\u0026#34;----\u0026#34;\u0026lt;\u0026lt;endl; int n=(bin.at(0)-\u0026#39;0\u0026#39;)*2*2*2+ (bin.at(1)-\u0026#39;0\u0026#39;)*2*2 + (bin[2]-\u0026#39;0\u0026#39;)*2+ (bin[3]-\u0026#39;0\u0026#39;); if(n\u0026lt;10) return (n+\u0026#39;0\u0026#39;); switch(n) { case 10:return \u0026#39;A\u0026#39;; case 11:return \u0026#39;B\u0026#39;; case 12:return \u0026#39;C\u0026#39;; case 13:return \u0026#39;D\u0026#39;; case 14:return \u0026#39;E\u0026#39;; case 15:return \u0026#39;F\u0026#39;; } // 以下是暴力解233 // string h=\u0026#34;0000\u0026#34;; // h[0]=b1; // h[1]=b2; // h[2]=b3; // h[3]=b4; // if(h==\u0026#34;0000\u0026#34;) return \u0026#34;0\u0026#34;; // if(h==\u0026#34;0001\u0026#34;) return \u0026#34;1\u0026#34;; // if(h==\u0026#34;0010\u0026#34;) return \u0026#34;2\u0026#34;; // if(h==\u0026#34;0011\u0026#34;) return \u0026#34;3\u0026#34;; // if(h==\u0026#34;0100\u0026#34;) return \u0026#34;4\u0026#34;; // if(h==\u0026#34;0101\u0026#34;) return \u0026#34;5\u0026#34;; // if(h==\u0026#34;0110\u0026#34;) return \u0026#34;6\u0026#34;; // if(h==\u0026#34;0111\u0026#34;) return \u0026#34;7\u0026#34;; // if(h==\u0026#34;1000\u0026#34;) return \u0026#34;8\u0026#34;; // if(h==\u0026#34;1001\u0026#34;) return \u0026#34;9\u0026#34;; // if(h==\u0026#34;1010\u0026#34;) return \u0026#34;A\u0026#34;; // if(h==\u0026#34;1011\u0026#34;) return \u0026#34;B\u0026#34;; // if(h==\u0026#34;1100\u0026#34;) return \u0026#34;C\u0026#34;; // if(h==\u0026#34;1101\u0026#34;) return \u0026#34;D\u0026#34;; // if(h==\u0026#34;1110\u0026#34;) return \u0026#34;E\u0026#34;; // if(h==\u0026#34;1111\u0026#34;) return \u0026#34;F\u0026#34;; } int main() { int NUM =0; while(cin\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c\u0026gt;\u0026gt;a\u0026amp;\u0026amp;b!=0) //注意输入的顺序 { char ***disk; char od_ev; cin\u0026gt;\u0026gt;od_ev; disk = new char**[a]; //disk指向存着a个char**型的空间 //char **disk[a] for(int i=0;i\u0026lt;a;i++) disk[i] = new char*[b]; //disk里的每个元素指向存着b个char*型空间 //char *disk[i][b] for(int i=0;i\u0026lt;a;i++) for(int j=0;j\u0026lt;b;j++) disk[i][j] = new char[c]; for(int j=0;j\u0026lt;b;j++) for(int i=0;i\u0026lt;a;i++) for(int k=0;k\u0026lt;c;k++) cin\u0026gt;\u0026gt;disk[i][j][k]; NUM++; cout\u0026lt;\u0026lt;\u0026#34;Disk set \u0026#34;\u0026lt;\u0026lt;NUM\u0026lt;\u0026lt;\u0026#34; is \u0026#34;; int retu = repair(disk,od_ev==\u0026#39;E\u0026#39;?0:1); if(retu!=1) { cout\u0026lt;\u0026lt;\u0026#34;invalid.\u0026#34;\u0026lt;\u0026lt;endl; continue; //进行下一次大循环 } //cout\u0026lt;\u0026lt;retu\u0026lt;\u0026lt;endl; //show(disk); string result; string bin; //要转十六进制的四位二进制 int num=0; //间隔是4,代表四位二进制 int sum=a*b*c-a*c; //一共要过的字符量，除去校验位 for(int i=0;i\u0026lt;a;i++) for(int j=0;j\u0026lt;b;j++) { if((i+1)%b==(j+1)%b) //校验码 { //sum-=c; //将查过的这c个也要记录 continue; } for(int k=0;k\u0026lt;c;k++) { // cout\u0026lt;\u0026lt;\u0026#34;disk\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;k\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;(disk[i][j][k])\u0026lt;\u0026lt;endl;; bin.append(1,disk[i][j][k]); //这里的1代表加入1个处于第二个元素的字符，这里没处理好。 num++; // cout\u0026lt;\u0026lt;bin\u0026lt;\u0026lt;\u0026#34;__\u0026#34;\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;num\u0026lt;\u0026lt;endl; if(num%4==0) { result.append(1,hex(bin)); bin.erase(); } else if(sum%4!=0\u0026amp;\u0026amp;sum==num) result.append(1,hex(bin+\u0026#34;0000\u0026#34;)); } } cout\u0026lt;\u0026lt;\u0026#34;valid, contents are: \u0026#34;; cout\u0026lt;\u0026lt;result\u0026lt;\u0026lt;endl; }//while return 0; } //AC at 2018/4/25 （题外话：这个一不小心又花掉了一个晚上，过了样例后，第二天一次过，爽哈哈哈，我只能写写程序来找回点信心的意义了，每天写代码的时间也并不多啊，感觉还是写程序好，每天都能获得一点成就感。每天真的好麻烦的，我可能也仅限于此了）\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-509-raid%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE/","summary":"习题4-7 RAID技术（RAID!, ACM/ICPC World Finals 1997, UVa509）\nRAID技术用多个磁盘保存数据。每份数据在不止一个磁盘上保存，因此在某个磁盘损\n坏时能通过其他磁盘恢复数据。本题讨论其中一种RAID技术。数据被划分成大小\n为s（1≤s≤64）比特的数据块保存在d（2≤d≤6）个磁盘上，如图4-9所示，每d-1个数据块都\n有一个校验块，使得每d个数据块的异或结果为全0（偶校验）或者全1（奇校验）。\n图4-9 数据保存情况\n例如，d=5，s=2，偶校验，数据6C7A79EDFC（二进制01101100 01111010 01111001\n11101101 11111100）的保存方式如图4-10所示。\n图4-10 数据6C7A79EDPC的保存方式\n其中加粗块是校验块。输入d、s、b、校验的种类（E表示偶校验，O表示奇校验）以\n及b（1≤b≤100）个数据块（其中“x”表示损坏的数据），你的任务是恢复并输出完整的数\n据。如果校验错或者由于损坏数据过多无法恢复，应报告磁盘非法。\nSample Input\n5 2 5\nE\n0001011111\n0110111011\n1011011111\n1110101100\n0010010111\n3 2 5\nE\n0001111111\n0111111011\nxx11011111\n3 5 1\nO\n11111\n11xxx\nx1111\n0\nSample Output\nDisk set 1 is valid, contents are: 6C7A79EDFC\nDisk set 2 is invalid.\nDisk set 3 is valid, contents are: FFC","title":"uva 509 RAID!（磁盘数据）"},{"content":" 例题4-5 踪电子表格中的单元格（Spreadsheet Tracking, ACM/ICPC World Finals\n1997, UVa512）\n有一个r行c列（1≤r，c≤50）的电子表格，行从上到下编号为1～r，列从左到右编号为1\n～c。如图4-2（a）所示，如果先删除第1、5行，然后删除第3, 6, 7, 9列，结果如图4-2（b）\n所示。\n（a） （b）\n图4-2 删除行、列\n接下来在第2、3、5行前各插入一个空行，然后在第3列前插入一个空列，会得到如图4-\n3所示结果。\n图4-3 插入行、列\n你的任务是模拟这样的n个操作。具体来说一共有5种操作：\nEX r1 c1 r2 c2交换单元格(r1,c1),(r2,c2)。\nA x1 x2 … xA 插入或删除A行或列（DC-删除列，DR-删除行，IC-插入\n列，IR-插入行，1≤A≤10）。\n在插入／删除指令后，各个x值不同，且顺序任意。接下来是q个查询，每个查询格式\n为“r c”，表示查询原始表格的单元格(r,c)。对于每个查询，输出操作执行完后该单元格的新\n位置。输入保证在任意时刻行列数均不超过50。\nSample Input\n7 9\n5\nDR 2 1 5\nDC 4 3 6 7 9\nIC 1 3\nIR 2 2 4\nEX 1 2 6 5\n4\n4 8\n5 5\n7 8\n6 5\n0 0\nSample Output\nSpreadsheet #1\nCell data in (4,8) moved to (4,6)\nCell data in (5,5) GONE\nCell data in (7,8) moved to (7,6)\nCell data in (6,5) moved to (1,2)\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=832\u0026amp;problem=453\u0026amp;mosmsg=Submission+received+with+ID+20782890\n注意：\n输入注意以 0 0 结束，输出每两次输出间以一行空行隔开，最后一次输出后不能有空行\n移动前\n移动后\n这道题很繁琐，最后一直过不了参考了例题的代码，简单说一下思路。\n**-1、**我们先定义两个二维数组，一个用于操作（我们称其为 原始数组），另一个用于将操作完的数据拷贝过来（我们将其称为 临时数组），再将整理好的数据考回第一个数组，用于下次操作\n**0、*而且我们的每个元素的数值也是有蹊跷的，最好是要看着元素的值就能知道它起初的位置。我们可以用，\n① 第 i 行 第 j 列元素 =（i - 1） 总列数 + j - 1;之所以要减一是因为我的数组计数是从下标0开始，其实这样不太好，容易混乱，像书上一样从1开始就不错\n②书上是这个意思：先定义一个大数BIG=10000；第 i 行 第 j 列元素 = i * BIG +j ；这样的话 行数就是在万位以上了，和列数分开了。我们只要用 元素 / BIG 和 元素 % BIG 就能得到 行和列的序号。\n**1、**删除：先记录要删除的行（列）序号，再在原始数组中将这一行（列）的数据变成0，然后在复制给临时数组时，判断不是0的拷贝即可\n**2、**复制：这个方法是采用了书上的，之后我再说我的不好的方法。\n我们事先定义一个一维数组，用这个数组记录下要加的行（列），要加的行（列）序号就在 对应的一维数组的下标的元素记为1，然后在拷贝时，我们依次判断一维数组的各个元素是不是1，是则停止原始数组的拷贝，加入一行（列）元素都为0的行，否则拷贝一行（列）原始数组\n**3、**交换：直接交换\n**4、**判断坐标：\n①我一开始的方法是先通过原始坐标 算出那个位置上的原始元素值，然后依次遍历更改后的数组，找到了就输出当前所遍历到的行和列的序号，没找到就是GONE了\n②书上的意思是：又创建了一个二维数组用此数组记录改变的情况：\tans[此元素的][原始位置] = 代表“改变后的位置”的数值\n所以我们分析一个原始位置，就可以直接通过下标来找到改变后的位置。\n这两种方法各有好坏，前者费时节省空间，后者费空间省时；不过你也可以不用创建新的数组，用临时数组来记录应该也行。这样的话就不比前者方法费空间了\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;iomanip\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; const int MAX = 100; int oper_list[MAX][MAX],temp_list[MAX][MAX],ans_list[MAX][MAX]; int cols[MAX]; int rnum,cnum;//行数，列数 void Roper_to_temp(int T=0) { memset(temp_list,0,sizeof(temp_list)); int in=0;//记录增加到第几个了 int temp_r=0; for(int i=0;i\u0026lt;rnum;i++) { //cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; =?= \u0026#34;\u0026lt;\u0026lt;rnum+in\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;oper_list[rnum+in][0]\u0026lt;\u0026lt;endl; if(T\u0026amp;\u0026amp;cols[i]==1) { for(int j=0;j\u0026lt;cnum;j++) temp_list[temp_r][j]=0; temp_r++; } // if(T\u0026amp;\u0026amp;in\u0026lt;T\u0026amp;\u0026amp;i+1==oper_list[rnum+in][0])//若当前行是要增加的行 // { // in++; // //cout\u0026lt;\u0026lt;in\u0026lt;\u0026lt;\u0026#34; !! \u0026#34;\u0026lt;\u0026lt;temp_r\u0026lt;\u0026lt;endl; // for(int j=0;j\u0026lt;cnum;j++) // temp_list[temp_r][j] = 0; // temp_r++; // i--; // continue; // } if(oper_list[i][0]==-1)//代表这一行要删掉 continue; for(int j=0;j\u0026lt;cnum;j++) temp_list[temp_r][j] = oper_list[i][j]; temp_r++; } } //void Roper_to_temp(int T=0) //{ // int n=0; // for(int i=0;i\u0026lt;rnum+T;i++) // { // if(i==temp_list[rnum+n][0]) // { // n++; // ` i++; // continue; // } // for(int j=0;j\u0026lt;cnum;j++) // temp_list[i][j] = oper_list[i][j]; // } //} void Coper_to_temp(int T=0) { memset(temp_list,0,sizeof(temp_list)); int in=0; int temp_c=0; //cout\u0026lt;\u0026lt;\u0026#34;ttt \u0026#34;\u0026lt;\u0026lt;T\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;cnum;i++)//注意 +T { // cout\u0026lt;\u0026lt;\u0026#34;copy temp \u0026#34;\u0026lt;\u0026lt;temp_c\u0026lt;\u0026lt;endl; // cout\u0026lt;\u0026lt;\u0026#34;in \u0026#34;\u0026lt;\u0026lt;in\u0026lt;\u0026lt;\u0026#34; operlist \u0026#34;\u0026lt;\u0026lt;oper_list[0][cnum+in]\u0026lt;\u0026lt;endl; if(T\u0026amp;\u0026amp;cols[i]==1) { for(int j=0;j\u0026lt;rnum;j++) temp_list[j][temp_c]=0; temp_c++; } // if(T\u0026amp;\u0026amp;in\u0026lt;T\u0026amp;\u0026amp;i+1==oper_list[0][cnum+in])//若当前列是要增加的行 // { // in++; // for(int j=0;j\u0026lt;rnum;j++) // temp_list[j][temp_c] = 0; // temp_c++; // i--; // continue; // } if(oper_list[0][i]==-1)//代表这一列要删掉 continue; for(int j=0;j\u0026lt;rnum;j++) temp_list[j][temp_c] = oper_list[j][i]; temp_c++; } } void temp_to_oper() { memcpy(oper_list,temp_list,sizeof(temp_list)); // for(int i=0;i\u0026lt;rnum;i++) // for(int j=0;j\u0026lt;cnum;j++) // oper_list[i][j] = temp_list[i][j]; } void dr_oper() { int T; cin\u0026gt;\u0026gt;T;//增加的次数 int oper;//oper[15]; for(int i=0;i\u0026lt;T;i++) { cin\u0026gt;\u0026gt;oper;//[i]; for(int j=0;j\u0026lt;cnum;j++)//删除的行中的值变成 -1 oper_list[oper-1][j]= -1; } Roper_to_temp(); rnum-=T;//行数少T temp_to_oper(); } void dc_oper() { int T; cin\u0026gt;\u0026gt;T; int oper; for(int i=0;i\u0026lt;T;i++) { cin\u0026gt;\u0026gt;oper; for(int j=0;j\u0026lt;rnum;j++)//删除的列中值变成 -1 oper_list[j][oper-1]=-1; } Coper_to_temp(); cnum-=T;//列数少T temp_to_oper(); } void ir_oper() { memset(cols,0,sizeof(cols)); int T; cin\u0026gt;\u0026gt;T; int oper; for(int i=0;i\u0026lt;T;i++) { cin\u0026gt;\u0026gt;oper; cols[oper-1]=1; //oper_list[rnum+i][0]=oper;//最后加一行，第一个元素值是要加的行号 } Roper_to_temp(T); rnum+=T;//行数多T temp_to_oper(); } void ic_oper() { memset(cols,0,sizeof(cols)); int T; cin\u0026gt;\u0026gt;T; int oper; for(int i=0;i\u0026lt;T;i++) { cin\u0026gt;\u0026gt;oper; cols[oper-1]=1; //oper_list[0][cnum+i]=oper; //cout\u0026lt;\u0026lt;\u0026#34;oper \u0026#34;\u0026lt;\u0026lt;cnum+i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;oper_list[0][cnum+i]\u0026lt;\u0026lt;endl; } Coper_to_temp(T); cnum+=T;//列数多T temp_to_oper(); } void exc_oper() { int r1,c1,r2,c2; cin\u0026gt;\u0026gt;r1\u0026gt;\u0026gt;c1\u0026gt;\u0026gt;r2\u0026gt;\u0026gt;c2; int temp = oper_list[r1-1][c1-1]; oper_list[r1-1][c1-1] = oper_list[r2-1][c2-1]; oper_list[r2-1][c2-1] = temp; } void visit(int Cn)//遍历的方法 { int x,y; int iff=0; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; //cout\u0026lt;\u0026lt;\u0026#34;!!\u0026#34;\u0026lt;\u0026lt;(x-1)*Rn+y\u0026lt;\u0026lt;endl; for(int i=0;i\u0026lt;rnum;i++) for(int j=0;j\u0026lt;cnum;j++) { if(oper_list[i][j]==(x-1)*Cn+y) { iff=1; printf(\u0026#34;Cell data in (%d,%d) moved to (%d,%d)\\n\u0026#34;,x,y,i+1,j+1); return; } } if(iff==0) { printf(\u0026#34;Cell data in (%d,%d) GONE\\n\u0026#34;,x,y); } } const int BIG = 10000; void visit2()//数组按址索迹 { int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; printf(\u0026#34;Cell data in (%d,%d) \u0026#34;,x,y); if(ans_list[x][y]==0) cout\u0026lt;\u0026lt;\u0026#34;GONE\u0026#34;\u0026lt;\u0026lt;endl; else printf(\u0026#34;moved to (%d,%d)\\n\u0026#34;,ans_list[x][y]/BIG,ans_list[x][y]%BIG); } int main() { int T=1; while(cin\u0026gt;\u0026gt;rnum\u0026gt;\u0026gt;cnum\u0026amp;\u0026amp;rnum!=0\u0026amp;\u0026amp;cnum!=0) { memset(oper_list,0,sizeof(oper_list)); // if(rnum==0\u0026amp;\u0026amp;cnum==0) // break; int Cn=cnum;//用于遍历时留存的列数 for(int i=0;i\u0026lt;rnum;i++) for(int j=0;j\u0026lt;cnum;j++) oper_list[i][j]=(i+1)*BIG+j+1;//i*cnum+j+1;//从1开始依次给值 // for(int i=0;i\u0026lt;rnum;i++) // { // for(int j=0;j\u0026lt;cnum;j++) // cout\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;oper_list[i][j]; // cout\u0026lt;\u0026lt;endl; // } int T_DI;//操作数 cin\u0026gt;\u0026gt;T_DI; while(T_DI--) { string DIRC;//char DIRC[4]; //int DI_num; cin\u0026gt;\u0026gt;DIRC; if(DIRC==\u0026#34;DR\u0026#34;) dr_oper(); else if(DIRC==\u0026#34;DC\u0026#34;) dc_oper(); else if(DIRC==\u0026#34;IR\u0026#34;) ir_oper(); else if(DIRC==\u0026#34;IC\u0026#34;) ic_oper(); else if(DIRC==\u0026#34;EX\u0026#34;) exc_oper(); // cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;rnum\u0026lt;\u0026lt;\u0026#34; * \u0026#34;\u0026lt;\u0026lt;cnum\u0026lt;\u0026lt;endl; // for(int i=0;i\u0026lt;rnum;i++) // { // for(int j=0;j\u0026lt;cnum;j++) // cout\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;oper_list[i][j]; // cout\u0026lt;\u0026lt;endl; // } } memset(ans_list,0,sizeof(ans_list)); for(int i=1;i\u0026lt;=rnum;i++)//打表，记录元素先后位置 for(int j=1;j\u0026lt;=cnum;j++) ans_list[oper_list[i-1][j-1]/BIG][oper_list[i-1][j-1]%BIG]=(i)*BIG+j; //ans[此元素的][原始位置] = 代表’改变后的位置‘的 数值 if(T\u0026gt;1) cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;Spreadsheet #\u0026#34;\u0026lt;\u0026lt;T++\u0026lt;\u0026lt;endl; int T_xy; cin\u0026gt;\u0026gt;T_xy; while(T_xy--) visit2(); //visit(Cn);//认祖归宗 } return 0; } //AC at 2018/2/16 这篇文章就这吧，太累了，这道题遇到几个坎：1、不理解题，2、提交不过\n一旦理解题目，思路不难，写，然后通过样例改代码。\n最后就连udebug上面的100个案例都过了，还是通过不能，想死。后来采用忒休斯船法，将书上的代码一部分一部分换，看换成什么样的时候能通过，最后换了增加行列的函数时通过，喜极而嚎。\nudebug上的样例最大直到行列20，还是小。\nwww.udebug.com还是太棒了，不写了不写了，感冒头晕不想看见代码，时间不早还有英语要背\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-512-spreadsheet-trackingexcel%E8%A1%A8%E6%A0%BC/","summary":"例题4-5 踪电子表格中的单元格（Spreadsheet Tracking, ACM/ICPC World Finals\n1997, UVa512）\n有一个r行c列（1≤r，c≤50）的电子表格，行从上到下编号为1～r，列从左到右编号为1\n～c。如图4-2（a）所示，如果先删除第1、5行，然后删除第3, 6, 7, 9列，结果如图4-2（b）\n所示。\n（a） （b）\n图4-2 删除行、列\n接下来在第2、3、5行前各插入一个空行，然后在第3列前插入一个空列，会得到如图4-\n3所示结果。\n图4-3 插入行、列\n你的任务是模拟这样的n个操作。具体来说一共有5种操作：\nEX r1 c1 r2 c2交换单元格(r1,c1),(r2,c2)。\nA x1 x2 … xA 插入或删除A行或列（DC-删除列，DR-删除行，IC-插入\n列，IR-插入行，1≤A≤10）。\n在插入／删除指令后，各个x值不同，且顺序任意。接下来是q个查询，每个查询格式\n为“r c”，表示查询原始表格的单元格(r,c)。对于每个查询，输出操作执行完后该单元格的新\n位置。输入保证在任意时刻行列数均不超过50。\nSample Input\n7 9\n5\nDR 2 1 5\nDC 4 3 6 7 9\nIC 1 3\nIR 2 2 4\nEX 1 2 6 5\n4\n4 8","title":"uva 512 - Spreadsheet Tracking（Excel表格）"},{"content":" 例题6-2 铁轨（Rails, ACM/ICPC CERC 1997, UVa 514）\n某城市有一个火车站，铁轨铺设如图6-1所示。 有n节车厢从A方向驶入车站，按进站顺\n序编号为1～n。 你的任务是判断是否能让它们按照某种特定的顺序进入B方向的铁轨并驶出\n车站。 例如，出栈顺序(5 4 1 2 3)是不可能的，但(5 4 3 2 1)是可能的。\n为了重组车厢，你可以借助中转站C。 这是一个可以停放任意多节车厢的车站，但由于\n末端封顶，驶入C的车厢必须按照相反的顺序驶出C。 对于每个车厢，一旦从A移入C，就不\n能再回到A了；一旦从C移入B，就不能回到C了。 换句话说，在任意时刻，只有两种选择：\nA→C和C→B。\nSample Input\n5\n1 2 3 4 5\n5 4 1 2 3\n0\n6\n6 5 4 3 2 1\n0\n0\nSample Output\nYes\nNo\nYes\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=838\u0026amp;page=show_problem\u0026amp;problem=455\n和书上的思路一样\n车进入是先从1到n\n我们每进入一辆,就判断一下是不是要出去的那一辆, 如果是,这辆车就走了,然后判断一下下一辆\n如果不是就进入中转轨道中等的\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;stack\u0026gt; using namespace std; // [注意] 最后一组输出之后要有一个空行 int fun(int N){ stack\u0026lt;int\u0026gt; wait; // 等待通过的火车 stack\u0026lt;int\u0026gt; temp; // 中转轨道 for(int i=N;i\u0026gt;=1;i--){ wait.push(i); } int train; int no = 0; // 不能吗 for(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;train; if(train == 0) return 0; // 该退出了 if(no == 1) continue; // cout\u0026lt;\u0026lt;train\u0026lt;\u0026lt;\u0026#34; ??????????????\u0026#34;\u0026lt;\u0026lt;endl; // cout\u0026lt;\u0026lt;\u0026#34;wait: \u0026#34;; show(wait);cout\u0026lt;\u0026lt;\u0026#34;temp: \u0026#34;; show(temp);cout\u0026lt;\u0026lt;\u0026#34;---------------\u0026#34;\u0026lt;\u0026lt;endl; while(temp.empty() || temp.top() != train){ if(wait.empty()){ no = 1; // wait空了,中转的第一个却不能走,所以不行 break; } int out = wait.top(); // 车厢出等待区 wait.pop(); temp.push(out); // 车厢 进入中转区 } if(temp.top() == train) temp.pop(); // 中转的车走了 } if(temp.empty() \u0026amp;\u0026amp; wait.empty()){ cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; }else{ cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; } return 1; } int main() { int N; int index = 0; while(cin\u0026gt;\u0026gt;N \u0026amp;\u0026amp; N != 0){ // if(index != 0) index = 1; while(fun(N)!=0); cout\u0026lt;\u0026lt;endl; } return 0; } // AC at 2019/2/8 13:41 // spend about 1 hours 已经过了5天了有什么感想我也想不起来了,见鬼\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-514-rails-%E9%93%81%E8%BD%A8/","summary":"例题6-2 铁轨（Rails, ACM/ICPC CERC 1997, UVa 514）\n某城市有一个火车站，铁轨铺设如图6-1所示。 有n节车厢从A方向驶入车站，按进站顺\n序编号为1～n。 你的任务是判断是否能让它们按照某种特定的顺序进入B方向的铁轨并驶出\n车站。 例如，出栈顺序(5 4 1 2 3)是不可能的，但(5 4 3 2 1)是可能的。\n为了重组车厢，你可以借助中转站C。 这是一个可以停放任意多节车厢的车站，但由于\n末端封顶，驶入C的车厢必须按照相反的顺序驶出C。 对于每个车厢，一旦从A移入C，就不\n能再回到A了；一旦从C移入B，就不能回到C了。 换句话说，在任意时刻，只有两种选择：\nA→C和C→B。\nSample Input\n5\n1 2 3 4 5\n5 4 1 2 3\n0\n6\n6 5 4 3 2 1\n0\n0\nSample Output\nYes\nNo\nYes\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=838\u0026amp;page=show_problem\u0026amp;problem=455\n和书上的思路一样\n车进入是先从1到n\n我们每进入一辆,就判断一下是不是要出去的那一辆, 如果是,这辆车就走了,然后判断一下下一辆\n如果不是就进入中转轨道中等的\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;stack\u0026gt; using namespace std; // [注意] 最后一组输出之后要有一个空行 int fun(int N){ stack\u0026lt;int\u0026gt; wait; // 等待通过的火车 stack\u0026lt;int\u0026gt; temp; // 中转轨道 for(int i=N;i\u0026gt;=1;i--){ wait.","title":"UVA 514 - Rails ( 铁轨)"},{"content":" 例题5-6 团体队列(Team Queue,UVa540)\n有t个团队的人正在排一个长队。每次新来一个人时,如果他有队友在排队,那么这个\n新人会插队到最后一个队友的身后。如果没有任何一个队友排队,则他会排到长队的队尾。\n输入每个团队中所有队员的编号,要求支持如下3种指令(前两种指令可以穿插进\n行)。\nENQUEUEx:编号为x的人进入长队。\nDEQUEUE:长队的队首出队。\nSTOP:停止模拟。\n对于每个DEQUEUE指令,输出出队的人的编号。\nSample Input\n2\n3 101 102 103\n3 201 202 203\nENQUEUE 101\nENQUEUE 201\nENQUEUE 102\nENQUEUE 202\nENQUEUE 103\nENQUEUE 203\nDEQUEUE\nDEQUEUE\nDEQUEUE\nDEQUEUE\nDEQUEUE\nDEQUEUE\nSTOP\n2\n5 259001 259002 259003 259004 259005\n6 260001 260002 260003 260004 260005 260006\nENQUEUE 259001\nENQUEUE 260001\nENQUEUE 259002\nENQUEUE 259003\nENQUEUE 259004\nENQUEUE 259005\nDEQUEUE\nDEQUEUE\nENQUEUE 260002\nENQUEUE 260003\nDEQUEUE\nDEQUEUE\nDEQUEUE\nDEQUEUE\nSTOP\n0\nSample Output\nScenario #1\n101\n102\n103\n201\n202\n203\nScenario #2\n259001\n259002\n259003\n259004\n259005\n260001\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;category=835\u0026amp;problem=481\u0026amp;mosmsg=Submission+received+with+ID+21283631\n用map来映射每个人与其所在的组，组号码顺序记录\n用两个队列存，一个存组的顺序。\n另一个是队列数组，存的是没有顺序的组以及里面的人\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int T=1; int n; //几个组 while(cin\u0026gt;\u0026gt;n\u0026amp;\u0026amp;n!=0) { map\u0026lt;int,int\u0026gt; group; //每个人对应其所属的组 for(int i=0;i\u0026lt;n;i++) { int m;//每组几个 cin\u0026gt;\u0026gt;m; for(int j=0;j\u0026lt;m;j++) { int name; //每人号码 cin\u0026gt;\u0026gt;name; group[name] = i; //人的号码对应于组名 } } string str; queue\u0026lt;int\u0026gt; que;//存组的顺序 queue\u0026lt;int\u0026gt; per[1003];//存所有人的顺序,per[i]是第i组 cout\u0026lt;\u0026lt;\u0026#34;Scenario #\u0026#34;\u0026lt;\u0026lt;T++\u0026lt;\u0026lt;endl; while(cin\u0026gt;\u0026gt;str\u0026amp;\u0026amp;str!=\u0026#34;STOP\u0026#34;) { //cout\u0026lt;\u0026lt;\u0026#34;???\u0026#34;\u0026lt;\u0026lt;endl; if(str == \u0026#34;ENQUEUE\u0026#34;) { int name; cin\u0026gt;\u0026gt;name; int qn=group[name];//组名 if(per[qn].empty()) //说明这个组还没有在队列中 que.push(qn); //组名入组队列 per[qn].push(name); } else { int qn=que.front(); //获取组名 cout\u0026lt;\u0026lt;per[qn].front()\u0026lt;\u0026lt;endl; //输出出队列的 per[qn].pop(); //人出组 if(per[qn].empty())//如果此组空了 que.pop(); } } cout\u0026lt;\u0026lt;endl; } return 0; } //AC at 2018/5/9 ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-540-team-queue%E6%8F%92%E9%98%9F%E9%98%9F%E5%88%97/","summary":"例题5-6 团体队列(Team Queue,UVa540)\n有t个团队的人正在排一个长队。每次新来一个人时,如果他有队友在排队,那么这个\n新人会插队到最后一个队友的身后。如果没有任何一个队友排队,则他会排到长队的队尾。\n输入每个团队中所有队员的编号,要求支持如下3种指令(前两种指令可以穿插进\n行)。\nENQUEUEx:编号为x的人进入长队。\nDEQUEUE:长队的队首出队。\nSTOP:停止模拟。\n对于每个DEQUEUE指令,输出出队的人的编号。\nSample Input\n2\n3 101 102 103\n3 201 202 203\nENQUEUE 101\nENQUEUE 201\nENQUEUE 102\nENQUEUE 202\nENQUEUE 103\nENQUEUE 203\nDEQUEUE\nDEQUEUE\nDEQUEUE\nDEQUEUE\nDEQUEUE\nDEQUEUE\nSTOP\n2\n5 259001 259002 259003 259004 259005\n6 260001 260002 260003 260004 260005 260006\nENQUEUE 259001\nENQUEUE 260001\nENQUEUE 259002\nENQUEUE 259003\nENQUEUE 259004\nENQUEUE 259005\nDEQUEUE\nDEQUEUE","title":"uva 540 - Team Queue（插队队列）"},{"content":" 例题6-8 树（Tree, UVa 548）\n给一棵点带权（权值各不相同，都是小于10000的正整数）的二叉树的中序和后序遍\n历，找一个叶子使得它到根的路径上的权和最小。如果有多解，该叶子本身的权应尽量小。\n输入中每两行表示一棵树，其中第一行为中序遍历，第二行为后序遍历。\n样例输入：\n3 2 1 4 5 7 6\n3 1 2 5 6 7 4\n7 8 11 3 5 16 12 18\n8 3 11 7 16 18 12 5\n255\n255\n样例输出：\n1\n3\n255\n本家地址\n在根据中序和后序遍历进行构造的时候，同时计算叶子的权值和，比较选择最小的权值的叶子，记录最小权值和的叶子和权值和。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;sstream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; int inorder[10004]; int postorder[10004]; int inindex[10004]; int min_top_value = 100000004; // 最小的权和 int loft = -1; // 叶子本身的值, /* 参数: 当前子树的 中序前,后 后序前,后 */ int calcul(int in_begin, int in_end, int post_begin, int post_end, int alculate_root_value){ // in_end - in_begin == post_end - post_begin int root_value = postorder[post_end]; // 根, 从后序 int root_in_index = inindex[root_value];//fin_inorder(in_begin, in_end, root_value); alculate_root_value = alculate_root_value + root_value; // 新的累计根值, 加上自己身上的 if(in_end \u0026lt;= in_begin){ // 叶子了 if(loft == -1 || // 第一个叶子 (alculate_root_value \u0026lt; min_top_value) || (alculate_root_value == min_top_value \u0026amp;\u0026amp; inorder[in_begin] \u0026lt; loft) ) { min_top_value = alculate_root_value; loft = inorder[in_begin]; } return 0; } int len = root_in_index-1-in_begin; if(root_in_index \u0026gt; in_begin){ calcul(in_begin, root_in_index-1, post_begin, post_begin + len, alculate_root_value); // 左枝 } len = in_end - root_in_index-1; if(root_in_index \u0026lt; in_end){ calcul(root_in_index+1, in_end, post_end-1-len , post_end-1, alculate_root_value); // 右枝 } return 0; } void init(){ memset(inorder,0,sizeof(inorder)); memset(postorder,0,sizeof(postorder)); memset(inindex,0,sizeof(inindex)); min_top_value = 100000004; // 最小的权和 loft = -1; // 叶子本身的值 } int main() { int row = 0; string line; while(getline(cin,line)){ // cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#34; \u0026#34;; stringstream ss(line); int i=0; int n; if(row==0){ // 新的一组, 要初始化 // 代表是一组中的第一行,即中序遍历 init(); while(ss\u0026gt;\u0026gt;n){ inorder[i] = n; inindex[n] = i; i++; } row = 1; }else{ // 一组中的第二行, 即后序遍历 while(ss\u0026gt;\u0026gt;n){ postorder[i++] = n; } row = 0; calcul(0,i-1,0,i-1,0); cout\u0026lt;\u0026lt;loft\u0026lt;\u0026lt;endl; } return 0; } // AC at 2020/03/21 ps：债还清了，这个代码提交了12次数，uva因为赞助商跑路的关系（不知道也没有关系），感觉现在更加慢了。网站首页筹集代码贡献。也想做点贡献，但是C++的网站。。。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-548-tree%E6%A0%91-by-sucicada/","summary":"例题6-8 树（Tree, UVa 548）\n给一棵点带权（权值各不相同，都是小于10000的正整数）的二叉树的中序和后序遍\n历，找一个叶子使得它到根的路径上的权和最小。如果有多解，该叶子本身的权应尽量小。\n输入中每两行表示一棵树，其中第一行为中序遍历，第二行为后序遍历。\n样例输入：\n3 2 1 4 5 7 6\n3 1 2 5 6 7 4\n7 8 11 3 5 16 12 18\n8 3 11 7 16 18 12 5\n255\n255\n样例输出：\n1\n3\n255\n本家地址\n在根据中序和后序遍历进行构造的时候，同时计算叶子的权值和，比较选择最小的权值的叶子，记录最小权值和的叶子和权值和。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;sstream\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; int inorder[10004]; int postorder[10004]; int inindex[10004]; int min_top_value = 100000004; // 最小的权和 int loft = -1; // 叶子本身的值, /* 参数: 当前子树的 中序前,后 后序前,后 */ int calcul(int in_begin, int in_end, int post_begin, int post_end, int alculate_root_value){ // in_end - in_begin == post_end - post_begin int root_value = postorder[post_end]; // 根, 从后序 int root_in_index = inindex[root_value];//fin_inorder(in_begin, in_end, root_value); alculate_root_value = alculate_root_value + root_value; // 新的累计根值, 加上自己身上的 if(in_end \u0026lt;= in_begin){ // 叶子了 if(loft == -1 || // 第一个叶子 (alculate_root_value \u0026lt; min_top_value) || (alculate_root_value == min_top_value \u0026amp;\u0026amp; inorder[in_begin] \u0026lt; loft) ) { min_top_value = alculate_root_value; loft = inorder[in_begin]; } return 0; } int len = root_in_index-1-in_begin; if(root_in_index \u0026gt; in_begin){ calcul(in_begin, root_in_index-1, post_begin, post_begin + len, alculate_root_value); // 左枝 } len = in_end - root_in_index-1; if(root_in_index \u0026lt; in_end){ calcul(root_in_index+1, in_end, post_end-1-len , post_end-1, alculate_root_value); // 右枝 } return 0; } void init(){ memset(inorder,0,sizeof(inorder)); memset(postorder,0,sizeof(postorder)); memset(inindex,0,sizeof(inindex)); min_top_value = 100000004; // 最小的权和 loft = -1; // 叶子本身的值 } int main() { int row = 0; string line; while(getline(cin,line)){ // cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#34; \u0026#34;; stringstream ss(line); int i=0; int n; if(row==0){ // 新的一组, 要初始化 // 代表是一组中的第一行,即中序遍历 init(); while(ss\u0026gt;\u0026gt;n){ inorder[i] = n; inindex[n] = i; i++; } row = 1; }else{ // 一组中的第二行, 即后序遍历 while(ss\u0026gt;\u0026gt;n){ postorder[i++] = n; } row = 0; calcul(0,i-1,0,i-1,0); cout\u0026lt;\u0026lt;loft\u0026lt;\u0026lt;endl; } return 0; } // AC at 2020/03/21 ps：债还清了，这个代码提交了12次数，uva因为赞助商跑路的关系（不知道也没有关系），感觉现在更加慢了。网站首页筹集代码贡献。也想做点贡献，但是C++的网站。。。","title":"UVA 548 - Tree(树) By SuCicada"},{"content":" 例题6-12 油田（Oil Deposits, UVa 572）\n输入一个m行n列的字符矩阵，统计字符“@”组成多少个八连块。如果两个字符“@”所在\n的格子相邻（横、竖或者对角线方向），就说它们属于同一个八连块。例如，图6-9中有两\n个八连块。\nSample Input\n1 1\n*\n3 5\n@@*\n@\n@@*\n1 8\n@@***@\n5 5\n****@\n@@@\n@**@\n@@@@\n@@**@\n0 0\nSample Output\n0\n1\n2\n2\n本家连接\n恩，嘛，遍历跑呗。反正到处都有。\n#include\u0026lt;iostream\u0026gt; using namespace std; char oil[110][110]; int sum=0; int length,width; int isOil=0; void show(){ for(int i=0;i\u0026lt;length;i++){ for(int j=0;j\u0026lt;width;j++) cout\u0026lt;\u0026lt;oil[i][j]; cout\u0026lt;\u0026lt;endl; } // cout\u0026lt;\u0026lt;\u0026#34;========================\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;endl; } int dfs(int x,int y){ char plot = oil[x][y]; if(x\u0026lt;0 || x\u0026gt;=length || y\u0026lt;0 || y\u0026gt;=width || plot!=\u0026#39;@\u0026#39;){ return 0; }else if(plot==\u0026#39;@\u0026#39;){ // cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; -------------------- \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; // show(); oil[x][y] = \u0026#39;-\u0026#39;; if(!isOil){ sum++; isOil = 1; } dfs(x-1,y-1); dfs(x-1,y); dfs(x-1,y+1); dfs(x,y-1); dfs(x,y+1); dfs(x+1,y-1); dfs(x+1,y); dfs(x+1,y+1); // show(); // cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34; res \u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 1; } } int main(){ while(1){ sum = 0; isOil = 0; cin\u0026gt;\u0026gt;length\u0026gt;\u0026gt;width; // cout\u0026lt;\u0026lt;length\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;width\u0026lt;\u0026lt;endl; if(length==0 \u0026amp;\u0026amp; width==0){ break; } for(int i=0;i\u0026lt;length;i++){ for(int j=0;j\u0026lt;width;j++){ cin\u0026gt;\u0026gt;oil[i][j]; } } for(int i=0;i\u0026lt;length;i++){ for(int j=0;j\u0026lt;width;j++){ dfs(i,j); isOil = 0; } } cout\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; } return 0; } // AC at 2020/07/28 ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-572-oil-deposits-%E6%B2%B9%E7%94%B0-by-sucicada/","summary":"例题6-12 油田（Oil Deposits, UVa 572）\n输入一个m行n列的字符矩阵，统计字符“@”组成多少个八连块。如果两个字符“@”所在\n的格子相邻（横、竖或者对角线方向），就说它们属于同一个八连块。例如，图6-9中有两\n个八连块。\nSample Input\n1 1\n*\n3 5\n@@*\n@\n@@*\n1 8\n@@***@\n5 5\n****@\n@@@\n@**@\n@@@@\n@@**@\n0 0\nSample Output\n0\n1\n2\n2\n本家连接\n恩，嘛，遍历跑呗。反正到处都有。\n#include\u0026lt;iostream\u0026gt; using namespace std; char oil[110][110]; int sum=0; int length,width; int isOil=0; void show(){ for(int i=0;i\u0026lt;length;i++){ for(int j=0;j\u0026lt;width;j++) cout\u0026lt;\u0026lt;oil[i][j]; cout\u0026lt;\u0026lt;endl; } // cout\u0026lt;\u0026lt;\u0026#34;========================\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;endl; } int dfs(int x,int y){ char plot = oil[x][y]; if(x\u0026lt;0 || x\u0026gt;=length || y\u0026lt;0 || y\u0026gt;=width || plot!","title":"UVA 572 - Oil Deposits (油田) By SuCicada"},{"content":" 例题6-6 小球下落（Dropping Balls, UVa 679）\n有一棵二叉树，最大深度为D，且所有叶子的深度都相同。所有结点从上到下从左到右\n编号为1, 2, 3,…, 2D-1。在结点1处放一个小球，它会往下落。每个内结点上都有一个开关，\n初始全部关闭，当每次有小球落到一个开关上时，状态都会改变。当小球到达一个内结点\n时，如果该结点上的开关关闭，则往左走，否则往右走，直到走到叶子结点，如图所\n示。\n一些小球从结点1处依次开始下落，最后一个小球将会落到哪里呢？输入叶子深度D和\n小球个数I，输出第I个小球最后所在的叶子编号。假设I不超过整棵树的叶子个数。D≤20。\n输入最多包含1000组数据。\n样例输入：\n6\n4 2\n3 4\n10 1\n2 2\n8 128\n16 12345\n-1\n样例输出：\n12\n7\n512\n3\n255\n36358\n本家链接\n最简单能想到的就是模拟，模拟球的下落，但是输入一旦大了就超时了。 所以我们可以，找规律。 首先假设有6层，我们来扔球看看情况\n球数 落下位置（最后一行,第一个为0计数） 0 0 1 16 2 8 3 24 4 4 5 20 6 12 7 28 8 2 9 18 10 10 11 26 12 6 13 22 14 14 15 30 --- 16 1 17 17 18 9 19 25 20 5 21 21 22 13 23 29 24 3 25 19 26 11 27 27 28 7 29 23 30 15 31 31 ==== 第33开始轮回 === 32 0 33 16 34 8 35 24 36 4 37 20 38 12 39 28 发现规律了吧。\n因为按照扔球数量，32为一个大轮回，这缘于底层数32。\n再次基础上我们可以按照16个一组进行再分组，然后可见第二组比起第一组，相对扔球数的结果位置数字要大1。比如：17球结果17，比1球结果16，结果大1。23球结果29，比7求结果28，大1。\n然后我们再次更小尺度分组，8个一组，可见后一组的结果位置数大前一组2。\n总结规律如下：\n底层数量 分组按照的大小 当前尺度的分组的答案偏移量 N M P 32 16 1 8 2 4 4 2 8 1 16 所以假设要求30球的值，就是\n首先减一，对齐从0开始： 30 - 1\n被减数 组大小 组对应的偏移值 29 16 1 13 8 2 5 4 4 1 1 16 0 0 res = (1+2+4+16) + 2^5（底层数） = 23 + 32 = 55\n所以公式如下：\n假设层数d，球数n\n$$\nT(m,0)=0\n$$\n$$\nT(n,d) = (T(\\lfloor (n/2) \\rfloor,d-1) + (n \\mod 2) ) \\times 2\n$$\n或者用循环表示\nres = 0 for ( i = 0 to d ): res = res * 2 + mod(n,2) n = floor(n / 2) 代码\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int main() { int T; cin\u0026gt;\u0026gt;T; while(T--){ int depth,index; cin\u0026gt;\u0026gt;depth\u0026gt;\u0026gt;index; int res = 0; int bottom = pow(2,depth-1); // 底层数量 int waitReverse = (index-1) % bottom; for(int i=0;i\u0026lt;depth-1;i++){ res \u0026lt;\u0026lt;= 1; // 乘 2 res += (waitReverse \u0026amp; 1); // 模2, 取奇偶 waitReverse \u0026gt;\u0026gt;= 1; // 除2, 向下取整 } cout\u0026lt;\u0026lt;res + bottom\u0026lt;\u0026lt;endl; } int end; cin\u0026gt;\u0026gt;end; return 0; } // AC at 2020/03/11 ps：拖了4个月了。再拖下去我就没了。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-679-dropping-balls-%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD-by-sucicada/","summary":"例题6-6 小球下落（Dropping Balls, UVa 679）\n有一棵二叉树，最大深度为D，且所有叶子的深度都相同。所有结点从上到下从左到右\n编号为1, 2, 3,…, 2D-1。在结点1处放一个小球，它会往下落。每个内结点上都有一个开关，\n初始全部关闭，当每次有小球落到一个开关上时，状态都会改变。当小球到达一个内结点\n时，如果该结点上的开关关闭，则往左走，否则往右走，直到走到叶子结点，如图所\n示。\n一些小球从结点1处依次开始下落，最后一个小球将会落到哪里呢？输入叶子深度D和\n小球个数I，输出第I个小球最后所在的叶子编号。假设I不超过整棵树的叶子个数。D≤20。\n输入最多包含1000组数据。\n样例输入：\n6\n4 2\n3 4\n10 1\n2 2\n8 128\n16 12345\n-1\n样例输出：\n12\n7\n512\n3\n255\n36358\n本家链接\n最简单能想到的就是模拟，模拟球的下落，但是输入一旦大了就超时了。 所以我们可以，找规律。 首先假设有6层，我们来扔球看看情况\n球数 落下位置（最后一行,第一个为0计数） 0 0 1 16 2 8 3 24 4 4 5 20 6 12 7 28 8 2 9 18 10 10 11 26 12 6 13 22 14 14 15 30 --- 16 1 17 17 18 9 19 25 20 5 21 21 22 13 23 29 24 3 25 19 26 11 27 27 28 7 29 23 30 15 31 31 ==== 第33开始轮回 === 32 0 33 16 34 8 35 24 36 4 37 20 38 12 39 28 发现规律了吧。","title":"UVA 679 - Dropping Balls (小球下落) By SuCicada"},{"content":" 例题6-10 下落的树叶（The Falling Leaves, UVa 699）\n给一棵二叉树，每个结点都有一个水平位\n置：左子结点在它左边1个单位，右子结点在右\n边1个单位。从左向右输出每个水平位置的所有\n结点的权值之和。如图6-7所示，从左到右的3个\n位置的权和分别为7，11，3。按照递归（先序）\n方式输入，用-1表示空树。\n样例输入：\n5 7 -1 6 -1 -1 3 -1 -1\n8 2 9 -1 -1 6 5 -1 -1 12 -1\n-1 3 7 -1 -1 -1\n-1\n样例输出：\nCase 1:\n7 11 3\nCase 2:\n9 7 21 15\n【注意】 一棵树的输[入可能分为多行。输出最多一行80个（代表树最多80列）\n本家地址\n一边输入一边记录左右结点的值，放在数组中叠加。唯一的问题就是存在左右子树，无法确定左右范围具体为多少，所以可以采用两种方法：\n设定一个最大的范围，80*2-1 范围，选择最中点为root结点，然后左右放置子节点。 将左右子树分开存放，右子树包含根节点，放置一个数组，下标递增代表结点向右扩增。将左子树放置另一个数组，下标递增代表结点向左扩增。如果以根节点为坐标轴0，那么左子树放置的坐标中就是反坐标轴，只是方向相反。 我采用第2种，因为一开始不知道范围（貌似）\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; int leftTree[100] = {0}; int rightTree[100] = {0}; /* include root */ int leftIndex = 0; int rightIndex = 0; char c; int tree(int index){ int n; cin\u0026gt;\u0026gt;n; if(n!=-1){ if(index\u0026lt;0){ leftTree[-1-index] += n; leftIndex = max(leftIndex,-1-index); }else{ rightTree[index] += n; rightIndex = max(rightIndex,index); } tree(index-1); tree(index+1); } return n; } int main(){ int T=1; int n; do{ leftIndex=0; rightIndex=0; memset(leftTree,0,sizeof(leftTree)); memset(rightTree,0,sizeof(rightTree)); n = tree(0); if(n!=-1){ cout\u0026lt;\u0026lt;\u0026#34;Case \u0026#34;\u0026lt;\u0026lt;T++\u0026lt;\u0026lt;\u0026#34;:\u0026#34;\u0026lt;\u0026lt;endl; int first = 1; for(int i=leftIndex;i\u0026gt;=0;i--){ if(leftTree[i]){ if(!first){ cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; }else{ first = 0; } cout\u0026lt;\u0026lt;leftTree[i]; } } for(int i=0;i\u0026lt;=rightIndex;i++){ if(rightTree[i]){ if(!first){ cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; }else{ first = 0; } cout\u0026lt;\u0026lt;rightTree[i]; } } cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;endl; } }while(n!=-1); return 0; } // AC at 2020/07/25 ps：一开始以为输入是每一行一个树，导致耽误了很久，还一致以为刘汝佳写错了（指代码）。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-699-the-falling-leaves-%E8%90%BD%E5%8F%B6-by-sucicada/","summary":"例题6-10 下落的树叶（The Falling Leaves, UVa 699）\n给一棵二叉树，每个结点都有一个水平位\n置：左子结点在它左边1个单位，右子结点在右\n边1个单位。从左向右输出每个水平位置的所有\n结点的权值之和。如图6-7所示，从左到右的3个\n位置的权和分别为7，11，3。按照递归（先序）\n方式输入，用-1表示空树。\n样例输入：\n5 7 -1 6 -1 -1 3 -1 -1\n8 2 9 -1 -1 6 5 -1 -1 12 -1\n-1 3 7 -1 -1 -1\n-1\n样例输出：\nCase 1:\n7 11 3\nCase 2:\n9 7 21 15\n【注意】 一棵树的输[入可能分为多行。输出最多一行80个（代表树最多80列）\n本家地址\n一边输入一边记录左右结点的值，放在数组中叠加。唯一的问题就是存在左右子树，无法确定左右范围具体为多少，所以可以采用两种方法：\n设定一个最大的范围，80*2-1 范围，选择最中点为root结点，然后左右放置子节点。 将左右子树分开存放，右子树包含根节点，放置一个数组，下标递增代表结点向右扩增。将左子树放置另一个数组，下标递增代表结点向左扩增。如果以根节点为坐标轴0，那么左子树放置的坐标中就是反坐标轴，只是方向相反。 我采用第2种，因为一开始不知道范围（貌似）\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;cmath\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; int leftTree[100] = {0}; int rightTree[100] = {0}; /* include root */ int leftIndex = 0; int rightIndex = 0; char c; int tree(int index){ int n; cin\u0026gt;\u0026gt;n; if(n!","title":"UVA 699 - The Falling Leaves (落叶) By SuCicada"},{"content":" 例题6-14 Abbott的复仇（Abbott\u0026rsquo;s Revenge, ACM/ICPC World Finals 2000, UVa 816）\n有一个最多包含9*9个交叉点的迷宫。输入起点、离开起点时的朝向和终点，求一条最\n短路（多解时任意输出一个即可）。\n图6-14 迷宫及走向\n这个迷宫的特殊之处在于：进入一个交叉点\n的方向（用NEWS这4个字母分别表示北东西\n南，即上右左下）不同，允许出去的方向也不\n同。例如，1 2 WLF NR ER 表示交叉点(1,2)\n（上数第1行，左数第2列）有3个路标（字\n符“”只是结束标志），如果进入该交叉点时的\n朝向为W（即朝左），则可以左转（L）或者直\n行（F）；如果进入时朝向为N或者E则只能右转\n（R），如图6-14所示。\n注意：初始状态是“刚刚离开入口”，所以即\n使出口和入口重合，最短路也不为空。例如，图\n6-14中的一条最短路为(3,1) (2,1) (1,1) (1,2)\n(2,2) (2,3) (1,3) (1,2) (1,1) (2,1) (2,2) (1,2) (1,3) (2,3) (3,3)。\nSample Input\nSAMPLE\n3 1 N 3 3\n1 1 WL NR *\n1 2 WLF NR ER *\n1 3 NL ER *\n2 1 SL WR NF *\n2 2 SL WF ELF *\n2 3 SFR EL *\n0\nNOSOLUTION\n3 1 N 3 2\n1 1 WL NR *\n1 2 NL ER *\n2 1 SL WR NFR *\n2 2 SR EL *\n0\nEND\nSample Output\nSAMPLE\n(3,1) (2,1) (1,1) (1,2) (2,2) (2,3) (1,3) (1,2) (1,1) (2,1)\n(2,2) (1,2) (1,3) (2,3) (3,3)\nNOSOLUTION\nNo Solution Possible\n本家地址\n思路和刘汝佳的如出一辙。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;sstream\u0026gt; #include\u0026lt;queue\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; class Site{ public: int x,y,inDir; Site(){} Site(int x,int y,int i):x(x),y(y),inDir(i){} friend ostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;out, Site \u0026amp;site){ out\u0026lt;\u0026lt;site.x\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;site.y\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;site.inDir; return out; } }; /* 9*9*4(direction)*4(direction) */ /* | ^ */ /* |-------------| */ int maz[11][11][6][6]; /* 9*9*4(direction)*3(x,y,dir) */ /* log[i][j][k] 值 site, 记录 i,y, dir(进入方向) 点由site*/ Site log[11][11][6]; int dis[11][11][6]; /* up, right, down, left */ char dirMap[4] = {\u0026#39;N\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;S\u0026#39;,\u0026#39;W\u0026#39;}; int getInDirMapIndex(char c){ /* 进入方向 */ for(int i=0;i\u0026lt;4;i++){ if(dirMap[i] == c){ return i; } } return -1; } /* in L R 0 3 1 1 0 2 2 1 3 3 2 0 */ int getOutDirMapIndex(int inIndex,char dir){ /* 出向方向 */ if(dir == \u0026#39;F\u0026#39;){ return inIndex; }else if(dir == \u0026#39;L\u0026#39;){ return (inIndex-1+4)%4; }else if(dir == \u0026#39;R\u0026#39;){ return (inIndex +1)%4; } return -1; } void show(){ cout\u0026lt;\u0026lt;\u0026#34; N \\nW E\\n S \u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; for(int i=1;i\u0026lt;=9;i++){ cout\u0026lt;\u0026lt;\u0026#34; NESW\u0026#34;; } cout\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=9;i++){ for(int k=0;k\u0026lt;4;k++){ cout\u0026lt;\u0026lt;dirMap[k]; for(int j=1;j\u0026lt;=9;j++){ cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; for(int p=0;p\u0026lt;4;p++){ cout\u0026lt;\u0026lt;maz[i][j][k][p]; } } cout\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;endl; } } void addRule(int x,int y,string rule){ for(int i=1;i\u0026lt;rule.size();i++){ /* x,y 位置的 rule[0] -\u0026gt; rule[i] 走向的规则建立了 */ int inIndex = getInDirMapIndex(rule[0]); int outIndex = getOutDirMapIndex(inIndex, rule[i]); maz[x][y][inIndex][outIndex] = 1; } } int beginX,beginY; char beginDir; int endX,endY; void showLog(){ for(int i=1;i\u0026lt;=3;i++){ for(int k=0;k\u0026lt;4;k++){ for(int j=1;j\u0026lt;=3;j++){ Site site = log[i][j][k]; cout\u0026lt;\u0026lt;site.x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;site.y\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;site.inDir\u0026lt;\u0026lt;\u0026#34; | \u0026#34;; }cout\u0026lt;\u0026lt;endl; }cout\u0026lt;\u0026lt;endl; }cout\u0026lt;\u0026lt;endl; } void showDis(){ for(int i=1;i\u0026lt;=3;i++){ for(int j=1;j\u0026lt;=3;j++){ for(int k=0;k\u0026lt;4;k++){ int n = dis[i][j][k]; cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#34; \u0026#34;; }cout\u0026lt;\u0026lt;\u0026#34; | \u0026#34;; }cout\u0026lt;\u0026lt;endl; }cout\u0026lt;\u0026lt;endl; } Site getNextSite(int x,int y,int outDir){ /* x y n 0 -1 0 e 1 0 1 s 2 1 0 w 3 0 -1 */ return Site( x+(outDir%2?0:outDir-1), y+(outDir%2?2-outDir:0), outDir); } void bfs(){ queue\u0026lt;Site\u0026gt; que; int beginDirN = getInDirMapIndex(beginDir); Site beginSite(beginX,beginY,beginDirN); Site nextSite = getNextSite(beginX,beginY,beginDirN); que.push(nextSite); log[nextSite.x][nextSite.y][nextSite.inDir] = beginSite; dis[nextSite.x][nextSite.y][nextSite.inDir] = 0; /* 一步跨到 */ int isSolu=0; int overDir; while(!que.empty()){ Site site = que.front(); que.pop();/* 当前块块 */ int x = site.x; int y = site.y; int inDir = site.inDir; if(x == endX \u0026amp;\u0026amp; y==endY){ isSolu = 1; overDir = inDir; break; } for(int i=0;i\u0026lt;4;i++){ if(maz[x][y][inDir][i]==1){ /* 这个出方向 能走 */ Site newSite = getNextSite(x,y,i); /* 下一步必须是一个新步才行 */ Site newLogSite = log[newSite.x][newSite.y][newSite.inDir]; if(newSite.x \u0026gt;=1 \u0026amp;\u0026amp; newSite.x \u0026lt;=9 \u0026amp;\u0026amp; newSite.y \u0026gt;= 1 \u0026amp;\u0026amp; newSite.y \u0026lt;=9 \u0026amp;\u0026amp; dis[newSite.x][newSite.y][newSite.inDir] == -1 /* 未被走过 */ ){ /* 记录从哪里过来的 */ log[newSite.x][newSite.y][newSite.inDir] = site; /* 记录距离 */ dis[newSite.x][newSite.y][newSite.inDir] = dis[x][y][inDir] + 1; que.push(newSite); } } } } if(isSolu){ vector\u0026lt;Site\u0026gt; res; Site lastSite = Site(endX,endY,overDir); while(1){ res.push_back(lastSite); if(!dis[lastSite.x][lastSite.y][lastSite.inDir]){ break; } lastSite = log[lastSite.x][lastSite.y][lastSite.inDir]; } res.push_back(Site(beginX,beginY,beginDirN)); int sum = 0; for(int i=res.size()-1;i\u0026gt;=0;i--){ if(sum % 10 ==0){ if(sum){ cout\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } printf(\u0026#34; (%d,%d)\u0026#34;,res[i].x,res[i].y); sum++; } cout\u0026lt;\u0026lt;endl; }else{ cout\u0026lt;\u0026lt;\u0026#34; No Solution Possible\u0026#34;\u0026lt;\u0026lt;endl;; } } int main(){ while(1){ memset(maz,0,sizeof(maz)); memset(log,0,sizeof(log)); memset(dis,-1,sizeof(dis)); beginX = beginY = endX = endY = 0; string name; cin\u0026gt;\u0026gt;name; if(name == \u0026#34;END\u0026#34;){ break; } cin\u0026gt;\u0026gt;beginX\u0026gt;\u0026gt;beginY\u0026gt;\u0026gt;beginDir\u0026gt;\u0026gt;endX\u0026gt;\u0026gt;endY; while(1){ /* 一个点 */ int x,y; cin\u0026gt;\u0026gt;x; if(x==0){ break; } cin\u0026gt;\u0026gt;y; while(1){ /* 一个规则 */ string rule; cin\u0026gt;\u0026gt;rule; if(rule==\u0026#34;*\u0026#34;){ break; } addRule(x,y,rule); } } cout\u0026lt;\u0026lt;name\u0026lt;\u0026lt;endl; bfs(); } return 0; } // AC at 2020/08/02 ps：太傻了，居然想要手动实现队列和栈，然后还给写错了，本地调试没有任何问题。但是一提交就是WA。昨天的一个下午，要疯了。\n最近台风要来了，云都被吹散了在晚上，月亮特别圆特别亮特别好看。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-816-abbotts-revenge-abbott%E7%9A%84%E5%A4%8D%E4%BB%87-by-sucicada/","summary":"例题6-14 Abbott的复仇（Abbott\u0026rsquo;s Revenge, ACM/ICPC World Finals 2000, UVa 816）\n有一个最多包含9*9个交叉点的迷宫。输入起点、离开起点时的朝向和终点，求一条最\n短路（多解时任意输出一个即可）。\n图6-14 迷宫及走向\n这个迷宫的特殊之处在于：进入一个交叉点\n的方向（用NEWS这4个字母分别表示北东西\n南，即上右左下）不同，允许出去的方向也不\n同。例如，1 2 WLF NR ER 表示交叉点(1,2)\n（上数第1行，左数第2列）有3个路标（字\n符“”只是结束标志），如果进入该交叉点时的\n朝向为W（即朝左），则可以左转（L）或者直\n行（F）；如果进入时朝向为N或者E则只能右转\n（R），如图6-14所示。\n注意：初始状态是“刚刚离开入口”，所以即\n使出口和入口重合，最短路也不为空。例如，图\n6-14中的一条最短路为(3,1) (2,1) (1,1) (1,2)\n(2,2) (2,3) (1,3) (1,2) (1,1) (2,1) (2,2) (1,2) (1,3) (2,3) (3,3)。\nSample Input\nSAMPLE\n3 1 N 3 3\n1 1 WL NR *\n1 2 WLF NR ER *\n1 3 NL ER *\n2 1 SL WR NF *","title":"UVA 816 - Abbott‘s Revenge (Abbott的复仇) By SuCicada"},{"content":" 例题6-9 天平（Not so Mobile, UVa 839）\n输入一个树状天平，根据力矩相等原则判断是否平衡。如图6-5所示，所谓力矩相等，\n就是WlDl=WrDr，其中Wl和Wr分别为左右两边砝码的重量，D为距离。\n采用递归（先序）方式输入：每个天平的格式为Wl，Dl，Wr，Dr，当Wl或Wr为0时，表\n示该“砝码”实际是一个子天平，接下来会描述这个子天平。当Wl=Wr=0时，会先描述左子天\n平，然后是右子天平。\n样例输入：\n1\n0 2 0 4\n0 3 0 1\n1 1 1 1\n2 4 4 2\n1 6 3 2\nSample Output\nYES\n【注意】 输出结果之间空一行\n本家地址\n递归走，一边输入每一结点，一边递归判断这个结点的左结点结果（左子树重量总和）和右结点结果（右子树重量总和）是否满足要求。\n这样的话在建立树的时候也就直接计算结束了。\n#include\u0026lt;iostream\u0026gt; using namespace std; int lair(){ int wl,dl,wr,dr; cin\u0026gt;\u0026gt;wl\u0026gt;\u0026gt;dl\u0026gt;\u0026gt;wr\u0026gt;\u0026gt;dr; if(wl == 0){ /* have left branch */ wl = lair(); } if(wr == 0){ wr = lair(); } if(wl==0 || wr==0 || wl*dl != wr*dr){ return 0; }else{ return wl+wr; } } int main(){ int T; cin\u0026gt;\u0026gt;T; while(T--){ int res = lair(); if(res == 0){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; }else{ cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; } if(T\u0026gt;0){ cout\u0026lt;\u0026lt;endl; } } } // AC at 2020/07/21 23:58 ps：诸君，我喜欢代码。\n20200725\n最近还真是喜怒不定，感觉我已经没有容身之所了，开玩笑，那也是自以为的。\n睡眠不足，精神紧张，导致大脑开始痛了，紧着着就是心痛了。连锁反应。\n最近又想起了DELA大的【我对孤独一无所知 】。如今重温，感受深同。\n本周听完了盗墓笔记十年（广播剧）。那真是一个终点，时隔五年之久，终于补上了欠缺的一页。能够粉身碎骨万箭穿心之后，能够抵达终点，那是一种幸运，仍能不忘天真，那是一种强大。桃李春风一杯酒，江湖夜雨十年灯。\n所有的一切又回到了原点，如今我才明白，从来也没有人会自愿来真正拯救你。他们每个人都在生死线上挣扎不能脱身，这是一个人人自危的时代，每个人都脆弱无比，他们比你还要害怕危险，害怕受到伤害。依靠他们是不可取的，在真正找到归宿之前不要选择盛放，那会让你沉溺于倾诉的毒瘾之中不能自拔，轻则痛彻心扉，重则伤筋断骨。\n我们只要能够活下去就是一大胜利，这是第一步，第二步就是控制自己的活法，这样才能使得我们不会再回想起凝望深渊时的情景。但这远远还比不上直面旧日支配者吧，だぶん，哈哈。不过心理世界之深渊，着实诡秘莫测。\n看来我依仗的也只能是这个了，算法救我实属不假。这其实是很危险的，将精神寄居于一个事物上，也就要要背负上不可预测之概率 of 流离失所之打击感。\n等到什么时候我不会再将自己的生死寄托于不可获得之物上，我便安全了。\nWhen I no longer need the psychological placebo for other people to give, I can reach my own paradise.\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-839-not-so-mobile-%E5%A4%A9%E5%B9%B3by-sucicada/","summary":"例题6-9 天平（Not so Mobile, UVa 839）\n输入一个树状天平，根据力矩相等原则判断是否平衡。如图6-5所示，所谓力矩相等，\n就是WlDl=WrDr，其中Wl和Wr分别为左右两边砝码的重量，D为距离。\n采用递归（先序）方式输入：每个天平的格式为Wl，Dl，Wr，Dr，当Wl或Wr为0时，表\n示该“砝码”实际是一个子天平，接下来会描述这个子天平。当Wl=Wr=0时，会先描述左子天\n平，然后是右子天平。\n样例输入：\n1\n0 2 0 4\n0 3 0 1\n1 1 1 1\n2 4 4 2\n1 6 3 2\nSample Output\nYES\n【注意】 输出结果之间空一行\n本家地址\n递归走，一边输入每一结点，一边递归判断这个结点的左结点结果（左子树重量总和）和右结点结果（右子树重量总和）是否满足要求。\n这样的话在建立树的时候也就直接计算结束了。\n#include\u0026lt;iostream\u0026gt; using namespace std; int lair(){ int wl,dl,wr,dr; cin\u0026gt;\u0026gt;wl\u0026gt;\u0026gt;dl\u0026gt;\u0026gt;wr\u0026gt;\u0026gt;dr; if(wl == 0){ /* have left branch */ wl = lair(); } if(wr == 0){ wr = lair(); } if(wl==0 || wr==0 || wl*dl !","title":"UVA 839 - Not so Mobile （天平）By SuCicada"},{"content":"udebug使用在后面\nhttps://uva.onlinejudge.org/\n1、这是主界面，如果你还没有账号，那么就点击图中的register。\n2、然后就是填写信息，邮箱要用gmail，信息填写完成后点击下方的register\n3、之后打开邮箱查看接受的邮件，并点击其中的链接完成注册确认，之后会转到uva oj，如果页面显示 your account is now active.You may now log in!则表示注册完成。\n4、然后输入用户名密码登录\n5、然后在左边的栏目中，点击Browse Problems 就可以找到有关刘汝佳以及其他一些著名套题了。\n6、然后是关于如何答题，现在我们打开了一道题目，看图上红框住的左上角，\n（1）其中我们点击PDF，会下载下来本道题的pdf格式文件\n（2）我们点击submit就是提交代码了。\n其中如果是用的C语言或C++选择第一个c++，提交结果没有ac，如果不是代码问题，那么试试选择c++11吧。\n参考了UVAOJ的注册和评测入门\n（3）最后我想说一下在看题界面的那个Debug选项，就是旁边有个红色的甲虫的。\n若果打不开udebug就挂vpn试试吧\nhttps://www.udebug.com/UVa/1589 （当前是1589号题）\n我们点进去后，一共四部分。上左边就是一些用户上传的关于本题的一些样例。点击其中一个，这些样例就会显示在右边的框中。\n然后我们点击下方写着Get Accepted Output蓝格，就会在下方的左边出现这些样例的正确输出结果。我们可以把这些样例用我们的代码输出的结果粘到右边的框中。之后点击Compare Outputs 进行对比。\n这样我就能很方便的知道我们的代码在处理哪一个样例上出现里问题，更改起来也更有方向性。还有如果出现了图中的情况，明明都对但还是显示不对，那是因为他的输出默认多了一个空行，这个一般和代码没有关系。默认为对就行了。\n我们还可以在上面快速搜索你需要的题号。\n目前支持这些oj\n这是主页https://www.udebug.com/\n可以去他的Twitter和Facebook上看看，网上关于udegug的信息不多。\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva-online-judge-%E8%A5%BF%E7%8F%AD%E7%89%99valladolid-%E5%9C%A8%E7%BA%BF%E5%88%A4%E5%AE%98-%E5%92%8C-udebug%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/","summary":"udebug使用在后面\nhttps://uva.onlinejudge.org/\n1、这是主界面，如果你还没有账号，那么就点击图中的register。\n2、然后就是填写信息，邮箱要用gmail，信息填写完成后点击下方的register\n3、之后打开邮箱查看接受的邮件，并点击其中的链接完成注册确认，之后会转到uva oj，如果页面显示 your account is now active.You may now log in!则表示注册完成。\n4、然后输入用户名密码登录\n5、然后在左边的栏目中，点击Browse Problems 就可以找到有关刘汝佳以及其他一些著名套题了。\n6、然后是关于如何答题，现在我们打开了一道题目，看图上红框住的左上角，\n（1）其中我们点击PDF，会下载下来本道题的pdf格式文件\n（2）我们点击submit就是提交代码了。\n其中如果是用的C语言或C++选择第一个c++，提交结果没有ac，如果不是代码问题，那么试试选择c++11吧。\n参考了UVAOJ的注册和评测入门\n（3）最后我想说一下在看题界面的那个Debug选项，就是旁边有个红色的甲虫的。\n若果打不开udebug就挂vpn试试吧\nhttps://www.udebug.com/UVa/1589 （当前是1589号题）\n我们点进去后，一共四部分。上左边就是一些用户上传的关于本题的一些样例。点击其中一个，这些样例就会显示在右边的框中。\n然后我们点击下方写着Get Accepted Output蓝格，就会在下方的左边出现这些样例的正确输出结果。我们可以把这些样例用我们的代码输出的结果粘到右边的框中。之后点击Compare Outputs 进行对比。\n这样我就能很方便的知道我们的代码在处理哪一个样例上出现里问题，更改起来也更有方向性。还有如果出现了图中的情况，明明都对但还是显示不对，那是因为他的输出默认多了一个空行，这个一般和代码没有关系。默认为对就行了。\n我们还可以在上面快速搜索你需要的题号。\n目前支持这些oj\n这是主页https://www.udebug.com/\n可以去他的Twitter和Facebook上看看，网上关于udegug的信息不多。","title":"UVa Online Judge 西班牙Valladolid 在线判官 和 uDebug使用简单教程"},{"content":" 如果x加上x的各个数字之和得到y，就说x是y的生成元。给出n（1≤n≤100000），求最小\n生成元。无解输出0。例如，n=216，121，2005时的解分别为198，0，1979。\nSample Input\n3\n216\n121\n2005\nSample Output\n198\n0\n1979\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=829\u0026amp;page=show_problem\u0026amp;problem=4458\n//先算出所有的生成元x的原数y，以s[y]=x的形式将其存起，在求y的解x的时候，直接输出是s[y]即可 //所以为了求最小生成元也就是x，就要从尾到头的循环算y。 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; int const N = 100000; int sn[N+5]={0}; int main() { memset(sn,0,sizeof(sn)); for(int i=N;i\u0026gt;=0;i--) { int n=i; int s=i; while(n\u0026gt;0) { s+=n%10; n/=10; } sn[s]=i; } //for(int i=0;i\u0026lt;N;i++) // cout\u0026lt;\u0026lt;sn[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; // cout\u0026lt;\u0026lt;endl; int n,T; cin\u0026gt;\u0026gt;T; while(T--) { int i; cin\u0026gt;\u0026gt;n; cout\u0026lt;\u0026lt;sn[n]\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/7 以下算法虽然一样可以算出正确答案，但是超时，oj不通过。\n//Time limit exceeded //先算出所有的原数y，将其以s[x]=y;的形式存起，然后循环对比：要求的数和s中哪个元素相等，输出此元素的下标即可 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; using namespace std; int const N = 100000; int main() { int sn[N+5]={0}; for(int i=1;i\u0026lt;=N;i++) { int n=i; sn[i]=i; while(n\u0026gt;0) { sn[i]+=n%10; n/=10; } } //for(int i=0;i\u0026lt;N;i++) // cout\u0026lt;\u0026lt;sn[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; // cout\u0026lt;\u0026lt;endl; int n,T; cin\u0026gt;\u0026gt;T; while(T--) { int i; cin\u0026gt;\u0026gt;n; for(i=1;i\u0026lt;=N;i++) { if(n==sn[i]) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; break; } } if(i\u0026gt;N) cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; } return 0; } 总结：\n第一种还是刘汝佳给的思路，只循环了N次，而后者循环2*N次。思维不能太死板，就如同那句警言：\nKEEP IT SIMPLE AND STUPID\n","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva1583-digit-generator-%E7%94%9F%E6%88%90%E5%85%83/","summary":"如果x加上x的各个数字之和得到y，就说x是y的生成元。给出n（1≤n≤100000），求最小\n生成元。无解输出0。例如，n=216，121，2005时的解分别为198，0，1979。\nSample Input\n3\n216\n121\n2005\nSample Output\n198\n0\n1979\nhttps://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=829\u0026amp;page=show_problem\u0026amp;problem=4458\n//先算出所有的生成元x的原数y，以s[y]=x的形式将其存起，在求y的解x的时候，直接输出是s[y]即可 //所以为了求最小生成元也就是x，就要从尾到头的循环算y。 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; int const N = 100000; int sn[N+5]={0}; int main() { memset(sn,0,sizeof(sn)); for(int i=N;i\u0026gt;=0;i--) { int n=i; int s=i; while(n\u0026gt;0) { s+=n%10; n/=10; } sn[s]=i; } //for(int i=0;i\u0026lt;N;i++) // cout\u0026lt;\u0026lt;sn[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; // cout\u0026lt;\u0026lt;endl; int n,T; cin\u0026gt;\u0026gt;T; while(T--) { int i; cin\u0026gt;\u0026gt;n; cout\u0026lt;\u0026lt;sn[n]\u0026lt;\u0026lt;endl; } return 0; } //AC at 2017/12/7 以下算法虽然一样可以算出正确答案，但是超时，oj不通过。","title":"uva1583 - Digit Generator （生成元）"},{"content":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=829\u0026amp;page=show_problem\u0026amp;problem=208\nTEX is a typesetting language developed by Donald Knuth. It takes source text together with a few\ntypesetting instructions and produces, one hopes, a beautiful document. Beautiful documents use “\nand ” to delimit quotations, rather than the mundane \u0026quot; which is what is provided by most keyboards.\nKeyboards typically do not have an oriented double-quote, but they do have a left-single-quote and a right-single-quote '. Check your keyboard now to locate the left-single-quote key (sometimes\ncalled the “backquote key”) and the right-single-quote key \u0026rsquo; (sometimes called the “apostrophe” or\njust “quote”). Be careful not to confuse the left-single-quote with the “backslash” key \\. TEX lets the user type two left-single-quotes `` to create a left-double-quote “ and two right-single-quotes '' to create a right-double-quote ”. Most typists, however, are accustomed to delimiting their quotations with the un-oriented double-quote \u0026quot;. If the source contained \u0026quot;To be or not to be,\u0026quot; quoth the bard, \u0026quot;that is the question.\u0026quot; then the typeset document produced by TEX would not contain the desired form: “To be or not to be,” quoth the bard, “that is the question.” In order to produce the desired form, the source file must contain the sequence: ``To be or not to be,'' quoth the bard, ``that is the question.'' You are to write a program which converts text containing double-quote (\u0026quot;) characters into text that is identical except that double-quotes have been replaced by the two-character sequences required by TEX for delimiting quotations with oriented double-quotes. The double-quote (\u0026quot;) characters should be replaced appropriately by either `` if the \u0026quot; opens a quotation and by '' if the \u0026quot; closes a quotation. Notice that the question of nested quotations does not arise: The first \u0026quot; must be replaced by ``, the next by '', the next by ``, the next by '', the next by ``, the next by '', and so on. Input Input will consist of several lines of text containing an even number of double-quote (\u0026quot;) characters. Input is ended with an end-of-file character. Output The text must be output exactly as it was input except that: • the first \u0026quot; in each pair is replaced by two characters: and • the second \u0026quot; in each pair is replaced by two ' characters: ''. Sample Input \u0026quot;To be or not to be,\u0026quot; quoth the Bard, \u0026quot;that is the question\u0026quot;. The programming contestant replied: \u0026quot;I must disagree. To `C' or not to `C', that is The Question!\u0026quot; Sample OutputTo be or not to be,\u0026rsquo;\u0026rsquo; quoth the Bard, that is the question''. The programming contestant replied: I must disagree.\nTo C' or not to C\u0026rsquo;, that is The Question!''\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { int o=1; char c; while((c=getchar())!=EOF) { if(c==\u0026#39;\u0026#34;\u0026#39;) { printf(\u0026#34;%s\u0026#34;,o?\u0026#34;``\u0026#34;:\u0026#34;\u0026#39;\u0026#39;\u0026#34;); o=!o; } else printf(\u0026#34;%c\u0026#34;,c); } return 0; } ","permalink":"https://sucicada.github.io/blog/posts/uvaoj/uva272-tex/","summary":"https://uva.onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;category=829\u0026amp;page=show_problem\u0026amp;problem=208\nTEX is a typesetting language developed by Donald Knuth. It takes source text together with a few\ntypesetting instructions and produces, one hopes, a beautiful document. Beautiful documents use “\nand ” to delimit quotations, rather than the mundane \u0026quot; which is what is provided by most keyboards.\nKeyboards typically do not have an oriented double-quote, but they do have a left-single-quote and a right-single-quote '. Check your keyboard now to locate the left-single-quote key (sometimes","title":"uva272 （TeX）"}]