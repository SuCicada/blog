<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>SuCicada</title>
    <link>https://sucicada.github.io/blog/</link>
    <description>Recent content on SuCicada</description>
    <image>
      <url>https://sucicada.github.io/blog/papermod-cover.png</url>
      <link>https://sucicada.github.io/blog/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 10 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://sucicada.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>role</title>
      <link>https://sucicada.github.io/blog/posts/role/</link>
      <pubDate>Tue, 10 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/role/</guid>
      <description>遇到一些事情的时候，分心，因为总想要以一个好的状态来办事，所以当有一些坏感觉出现的时候，就分心去想办法解决坏感觉。最终一事无成。
目前自己想到并接受的方法：不管这些坏感觉，出现就出现吧，难受就难受吧，办事情更重要。一边难受一边办事也不是办不了。
绝对不要拖延，越拖遗憾越多，要勇敢的去验证，去实践。不能错失良机。不能害怕。</description>
    </item>
    
    <item>
      <title>使用多巴胺原理解释并解决成瘾性行为，并利用多巴胺追求爱好使之成为信仰</title>
      <link>https://sucicada.github.io/blog/posts/%E6%97%A5%E8%A8%98/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%B7%B4%E8%83%BA%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E5%B9%B6%E8%A7%A3%E5%86%B3%E6%88%90%E7%98%BE%E6%80%A7%E8%A1%8C%E4%B8%BA/</link>
      <pubDate>Wed, 04 Jan 2023 00:49:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/%E6%97%A5%E8%A8%98/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%B7%B4%E8%83%BA%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E5%B9%B6%E8%A7%A3%E5%86%B3%E6%88%90%E7%98%BE%E6%80%A7%E8%A1%8C%E4%B8%BA/</guid>
      <description>有很多诱惑，比如晚上睡前看视频，虽然这个能带来力量，就是学习的时候或者白天想到晚上可以放松，就会给精神加分，但是成瘾性很难解决。
关于多巴胺。多巴胺和成瘾。奖赏机制。多巴胺是一种对快乐的渴望，而不是快乐本身。
多巴胺欲望回路。脑回路会被多巴胺重塑。多巴胺喜欢意外。
要警惕会导致多巴胺大起大落的一切行为。
多巴胺带来的是想象，对美好的想象。想象和现实的偏差，是让人痛苦的。
多巴胺，成瘾是有规律的。
用享受当下来代替美好幻想。追求和拥有。
比如刷视频，刷图片，刷帖子。这是因为多巴胺制作了对未来的美好想象，多巴胺想要更多，如果不被及时满足，就会继续幻想并追求下一个。
因为当前的多巴胺应对的事物结束时，多巴胺跌落，人会十分难受，所以便会立马带动多巴胺，激发想象，追求下一段“美好”。
解决方法：在当前的美好进行中时，及时满足，在进行到一半的时候察觉，在即将结束时降低多巴胺，进行满足。并尝试找代替。
比如：从刷视频，刷文字 -&amp;gt; 听音乐，看书
引申思考：利用多巴胺来激励深层研究、学习、考究、收集、思考。</description>
    </item>
    
    <item>
      <title>hugo建站感想</title>
      <link>https://sucicada.github.io/blog/posts/%E6%97%A5%E8%A8%98/hugo%E5%BB%BA%E7%AB%99%E6%84%9F%E6%83%B3/</link>
      <pubDate>Thu, 22 Dec 2022 23:17:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/%E6%97%A5%E8%A8%98/hugo%E5%BB%BA%E7%AB%99%E6%84%9F%E6%83%B3/</guid>
      <description>初次尝试使用hugo建站，已经管不了那么多了，不能再继续耽误下去了。
然后</description>
    </item>
    
    <item>
      <title>UVA 1103 - Ancient Messages（古代象形符号） By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1103-ancient-messages%E5%8F%A4%E4%BB%A3%E8%B1%A1%E5%BD%A2%E7%AC%A6%E5%8F%B7-by-sucicada/</link>
      <pubDate>Sat, 01 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1103-ancient-messages%E5%8F%A4%E4%BB%A3%E8%B1%A1%E5%BD%A2%E7%AC%A6%E5%8F%B7-by-sucicada/</guid>
      <description>本题的目的是识别3000年前古埃及用到的6种象形文字，如图6-10所示。
图6-10 古代象形符号
每组数据包含一个H行W列的字符矩阵（H≤200，W≤50），每个字符为4个相邻像素点的
十六进制（例如，10011100对应的字符就是9c）。转化为二进制后1表示黑点，0表示白点。
输入满足：
不会出现上述6种符号之外的其他符号。
输入至少包含一个符号，且每个黑像素都属于一个符号。
每个符号都是一个四连块，并且不同符号不会相互接触，也不会相互包含。
如果两个黑像素有公共顶点，则它们一定有一个相同的相邻黑像素（有公共边）。
符号的形状一定和表6-9中的图形拓扑等价（可以随意拉伸但不能拉断）。
要求按照字典序输出所有符号。例如，图6-11中的输出应为AKW。
样例参见 https://www.udebug.com/UVa/1103
本家连接
分为以下几个步骤：
关键在于辨识每个图形中的空白四连块的数量。就是UVA 572 - Oil Deposits (油田) By SuCicada的升级版。
好就好在每个图形的白块数量不同，然而如何区分图形内的空白和图形外的空白是个问题。所以我在一开始就把外面的空白都涂黑了。
然后遍历，遍历到文字就将其当作油田求内部连通白块。
（最后的排序是手动实现的插入（:P）
/*
1. 16进制 转 2进制
2. 从最外围开始融化 白纸
3. 遍历到文字黑色边缘,
4. 向内遍历找&amp;quot;油田&amp;quot;, 即4连块
5. 计算每个文字的4连块数量
6. 结束文字们, 根据4连块数量映射文字, 排序
*/
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;cstring&amp;gt; using namespace std; /* 1. 16进制 转 2进制 2. 从最外围开始融化 白纸 3. 遍历到文字黑色边缘, 4. 向内遍历找&amp;#34;油田&amp;#34;, 即4连块 5. 计算每个文字的4连块数量 6.</description>
    </item>
    
    <item>
      <title>（C语言）换热器报价生成器设计报告</title>
      <link>https://sucicada.github.io/blog/posts/soft/c%E8%AF%AD%E8%A8%80%E6%8D%A2%E7%83%AD%E5%99%A8%E6%8A%A5%E4%BB%B7%E7%94%9F%E6%88%90%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/c%E8%AF%AD%E8%A8%80%E6%8D%A2%E7%83%AD%E5%99%A8%E6%8A%A5%E4%BB%B7%E7%94%9F%E6%88%90%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[leetcode][Algorithm] -13. Roman to Integer with [Java]</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcodealgorithm-13.-roman-to-integer-with-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcodealgorithm-13.-roman-to-integer-with-java/</guid>
      <description>problem
class Solution { public int romanToInt(String s) { int N = s.length(); int sum = 0; char a = 0; int b = 0; int c = 0; for(int i=0;i&amp;lt;N;i++){ c = b; a = s.charAt(i); if(a == &amp;#39;I&amp;#39;){ b = 1; }else if(a == &amp;#39;V&amp;#39;){ b = 5; }else if(a == &amp;#39;X&amp;#39;){ b = 10; }else if(a == &amp;#39;L&amp;#39;){ b = 50; }else if(a == &amp;#39;C&amp;#39;){ b = 100; }else if(a == &amp;#39;D&amp;#39;){ b = 500; }else if(a == &amp;#39;M&amp;#39;){ b = 1000; } // System.</description>
    </item>
    
    <item>
      <title>[leetcode][DataBase] - 175. Combine Two Tables with MySQL</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcodedatabase-175.-combine-two-tables-with-mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcodedatabase-175.-combine-two-tables-with-mysql/</guid>
      <description>题目
select FirstName, LastName, City, State from Person left join Address using (PersonId); or
select FirstName, LastName, City, State from Person left join Address on Person.PersonId=Address.PersonId; </description>
    </item>
    
    <item>
      <title>[leetcode][DataBase] - 176. Second Highest Salary with [MySQL]</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcodedatabase-176.-second-highest-salary-with-mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcodedatabase-176.-second-highest-salary-with-mysql/</guid>
      <description>problem
select ifnull((select distinct Salary from Employee order by Salary desc limit 1,1), null) as SecondHighestSalary; or other
select max(Salary) as SecondHighestSalary from employee where Salary &amp;lt; (select max(Salary) from employee); </description>
    </item>
    
    <item>
      <title>[leetcode][DataBase] - 177. Nth Highest Salary with [MySQL]</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcodedatabase-177.-nth-highest-salary-with-mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcodedatabase-177.-nth-highest-salary-with-mysql/</guid>
      <description>problem
# 184ms select min(aa.Salary) from (select distinct Salary from employee order by Salary desc limit N) as aa where (select count(distinct Salary) from employee) &amp;gt;= N or
# 188ms select aa.Salary as ass from (select distinct Salary from employee order by Salary desc limit N) as aa where (select count(distinct Salary) from employee) &amp;gt;= N order by ass limit 1 </description>
    </item>
    
    <item>
      <title>[leetcode][DataBase] - 178. Rank Scores with [MySQL]</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcodedatabase-178.-rank-scores-with-mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcodedatabase-178.-rank-scores-with-mysql/</guid>
      <description>problem
select inn.Score,inn.Rank from ( select ss.Score,@row:=@row+1 as Rank from (select @row:=0) a, (select Score from Scores group by Score) as ss order by ss.Score desc ) as inn right join Scores as sss on inn.Score = sss.Score order by inn.Score desc ; </description>
    </item>
    
    <item>
      <title>[Solve Error] Install g&#43;&#43; in Ubuntu20.04 :  g&#43;&#43; : Depends: g&#43;&#43;-7 (＞= 7.4.0-1~)</title>
      <link>https://sucicada.github.io/blog/posts/soft/solve-error-install-g&#43;&#43;-in-ubuntu20.04-g&#43;&#43;-depends-g&#43;&#43;-7-7.4.0-1~/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/solve-error-install-g&#43;&#43;-in-ubuntu20.04-g&#43;&#43;-depends-g&#43;&#43;-7-7.4.0-1~/</guid>
      <description>这是在Windows10上的Ubuntu WSL环境中遇到的问题。
目前的Ubuntu版本是Ubuntu 20.04.1 LTS。并且使用了阿里的apt镜像源。
先说结论，Ubuntu版本之高使得本机使用apt源中没有所需的库版本。所以可以尝试将apt源换回官方源。然后apt update再安装g++。
以下是断案过程。
在使用命令sudo apt install g++遇到了依赖问题。整个依赖链排查结果如下：
sucicada@20200702-143805:/etc/apt/sources.list.d$ sudo apt install g++ Reading package lists... Done Building dependency tree Reading state information... Done Some packages could not be installed. This may mean that you have requested an impossible situation or if you are using the unstable distribution that some required packages have not yet been created or been moved out of Incoming. The following information may help to resolve the situation: The following packages have unmet dependencies: g++ : Depends: g++-7 (&amp;gt;= 7.</description>
    </item>
    
    <item>
      <title>8086汇编   在屏幕上显现动态菱形图案</title>
      <link>https://sucicada.github.io/blog/posts/assmbly/8086%E6%B1%87%E7%BC%96-%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%98%BE%E7%8E%B0%E5%8A%A8%E6%80%81%E8%8F%B1%E5%BD%A2%E5%9B%BE%E6%A1%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/assmbly/8086%E6%B1%87%E7%BC%96-%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%98%BE%E7%8E%B0%E5%8A%A8%E6%80%81%E8%8F%B1%E5%BD%A2%E5%9B%BE%E6%A1%88/</guid>
      <description> 在屏幕上显现动态菱形图案。
* * * * * * * * * * *	* * * * * * * * * * * * * * * * * * * * * * * * &amp;lt;图一&amp;gt; &amp;lt;图二&amp;gt; &amp;lt;图三&amp;gt; &amp;lt;图四&amp;gt; &amp;lt;图五&amp;gt; 思路示例：
&amp;lt;1&amp;gt;编写程序p1:
显示一个字符
&amp;lt;2&amp;gt;把程序p1做成子程序，调用子程序编写程序p2:
显示一个菱形&amp;lt;图三&amp;gt;
&amp;lt;3&amp;gt;把p2做成一个子程序，调用子程序编写程序p3:
循环显示出如图五种图形
&amp;lt;4&amp;gt;修改程序p2,实现动态效果:
添加清屏子程序和延时子程序,完成完整程序。
注意点：
要求以统一逻辑实现全部的五个图形。
第三层的公式见代码
assume cs:code code segment start: ; [ input: al: row ] ; [ ah: column ] mov cx,10 start_s: mov di,0 mov si,1 call p3 mov di,4 mov si,-1 call p3 loop start_s mov ax,4c00h int 21h p3: ; -- input: di (index of p2) si (1 or -1) push ax push bx push cx push dx push di ; mov cx,5 ; times ; cmp di,3 ; jne p3_di_not_4 ; p3_di_not_4: mov cx,4 ; times ; mov di,0 p3_s: push cx mov cx,di mov dl,&amp;#39;*&amp;#39; call p2 pop cx ; bx ax lay time mov ax,0 mov bx,1 push cx p3_layout: sub ax,1 sbb bx,0 mov cx,ax or cx,bx cmp cx,0 jne p3_layout pop cx push cx mov cx,di mov dl,&amp;#39; &amp;#39; call p2 pop cx add di,si loop p3_s pop di pop dx pop cx pop bx pop ax ret p2: push ax push bx push cx ; ----- [1] ----------- mov al,10 mov ah,10 mov bl,al mov bh,ah call p1 add bl,1 ; ----- [2] ----------- push cx cmp cx,0 je p2_2_cx_is_0 sub cx,1 p2_2_cx_is_0: mov al,bl mov ah,bh sub ah,cl call p1 mov ah,bh add ah,cl call p1 pop cx add bl,1 ; ----- [3] ----------- ; left:ah = bh-1-(1+1+(cl-2))*(cl-1)/2 ; = bh-1-cl*(cl-1)/2 = bh-segdis ; right: bh+1+cl*(cl-1)/2 = bh+segdis ; segdis = 1+cl*(cl-1)/2 push cx cmp cx,0 je p2_3_cx_is_0 mov al,cl ; cl sub cl,1 ; cl-1 mul cl ; cl*(cl-1) -&amp;gt; ax mov cl,2 ; 2 div cl ; cl*(cl-1)/2 -&amp;gt; al add al,1 ; cl*(cl-1)/2+1 mov cl,al ; segdis p2_3_cx_is_0: mov al,bl mov ah,bh sub ah,cl ; bh - segdis call p1 mov ah,bh add ah,cl ; bh + segdis call p1 pop cx add bl,1 ; ----- [4] ----------- push cx cmp cx,0 je p2_4_cx_is_0 sub cx,1 p2_4_cx_is_0: mov al,bl mov ah,bh sub ah,cl call p1 mov ah,bh add ah,cl call p1 pop cx add bl,1 ; ----- [5] ----------- mov al,bl mov ah,bh call p1 pop cx pop bx pop ax ret p1: ; ----- input: al: row ah: column dl:char push ax push bx push es mov bx,0b800h mov es,bx mov bl,ah mov bh,al mov al,160 mul bh add bl,bl mov bh,0 add ax,bx mov bx,ax mov byte ptr es:[bx],dl mov byte ptr es:[bx+1],2 pop es pop bx pop ax ret code ends end start ; -------*------- 7 ; -------*------- 7 7 ; -------*------- 7 7 ; -------*------- ; -------*------- ; -------*------- 7 ; -------*------- 7 7 ; ------*-*------ 6 8 ; -------*------- ; -------*------- ; 7-1-(1+1+(n-2))*(n-1)/2 ; 2 ; -------*------- 7 ; ------*-*------ 6 8 ; -----*---*----- 5 9 ; ------*-*------ ; -------*------- ; 3 ; -------*------- 7 ; -----*---*----- 5 9 ; ---*-------*--- 3 11 ; -----*---*----- ; -------*------- ; -------*------- 7 ; ----*-----*---- 4 10 ; *-------------* 0 14 ; ----*-----*---- ; -------*------- </description>
    </item>
    
    <item>
      <title>8086汇编：在安全空间画金字塔</title>
      <link>https://sucicada.github.io/blog/posts/assmbly/8086%E6%B1%87%E7%BC%96%E5%9C%A8%E5%AE%89%E5%85%A8%E7%A9%BA%E9%97%B4%E7%94%BB%E9%87%91%E5%AD%97%E5%A1%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/assmbly/8086%E6%B1%87%E7%BC%96%E5%9C%A8%E5%AE%89%E5%85%A8%E7%A9%BA%E9%97%B4%E7%94%BB%E9%87%91%E5%AD%97%E5%A1%94/</guid>
      <description>assume cs:code code segment mov ax,20h mov ds,ax mov cx,8 s: mov dx,cx mov bx,cx sub bx,1 ; -------------------- mov cx,9 sub cx,dx ; mov cx,bx add cx,cx sub cx,1 j: mov al,&amp;#39;a&amp;#39; mov [bx],al inc bx loop j ; mov cx,dx ; add bx,10h mov ax,ds add ax,1 mov ds,ax ; mov bx,cx loop s mov ax,4c00h int 21h code ends end 。。。。</description>
    </item>
    
    <item>
      <title>8086汇编：清空0020:0 到0020:0ff空间</title>
      <link>https://sucicada.github.io/blog/posts/assmbly/8086%E6%B1%87%E7%BC%96%E6%B8%85%E7%A9%BA00200-%E5%88%B000200ff%E7%A9%BA%E9%97%B4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/assmbly/8086%E6%B1%87%E7%BC%96%E6%B8%85%E7%A9%BA00200-%E5%88%B000200ff%E7%A9%BA%E9%97%B4/</guid>
      <description>assume cs:code code segment ; This code is used to clear the memory ; of the safe area from 0020:0 to 0020:ff mov ax,20 mov ds,ax mov cx,0ffh mov bx,0 s: mov ax,0 mov ds:[bx],ax inc bx loop s mov ax,4c00h int 21h code ends end </description>
    </item>
    
    <item>
      <title>8086汇编：自动编译链接脚本</title>
      <link>https://sucicada.github.io/blog/posts/assmbly/8086%E6%B1%87%E7%BC%96%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/assmbly/8086%E6%B1%87%E7%BC%96%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AC/</guid>
      <description>@echo off echo code: %1 echo masm..... masm %1; echo link....... link %1; del %1.obj echo delete %1.obj echo finish 起个名 比如 run.bat 放到环境变量下，很方便</description>
    </item>
    
    <item>
      <title>8086汇编语言王爽  17.3 字符串的输入 (含输入溢出问题分析)</title>
      <link>https://sucicada.github.io/blog/posts/assmbly/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%8E%8B%E7%88%BD-17.3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5-%E5%90%AB%E8%BE%93%E5%85%A5%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/assmbly/8086%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%8E%8B%E7%88%BD-17.3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5-%E5%90%AB%E8%BE%93%E5%85%A5%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</guid>
      <description>如果直接使用书上的代码, 会发现输入一定字符就会卡死
先上代码, 或者跳到问题 assume cs:code ; dsstack segment ; db 16 dup(0) ; dsstack ends code segment start: ; mov ax,dsstack ; mov ds,ax ; mov si,13 ; mov sp,160 call getstr mov ax,4c00h int 21h getstr: push ax getstrs: mov ah,0 int 16h cmp al,20h jb nochar mov ah,0 call charstack mov ah,2 call charstack jmp getstrs nochar: cmp ah,0eh je backspace cmp ah,1ch je enter jmp getstrs backspace: mov ah,1 call charstack mov ah,2 call charstack jmp getstrs enter: mov al,0 mov ah,0 call charstack mov ah,2 call charstack pop ax ret ; ================================== charstack: jmp short charstart table dw charpush,charpop,charshow top dw 0 ; top of stack charstart: push bx push dx push di push es cmp ah,2 ja charret mov bl,ah mov bh,0 add bx,bx jmp word ptr table[bx] charpush: mov bx,top mov ds:[si][bx],al add top,1 jmp charret charpop: cmp top,0 je charret dec top mov bx,top mov al,[si][bx] jmp charret charshow: mov bx,0b800h mov es,bx mov al,160 mov ah,0 mul dh mov di,ax add dl,dl mov dh,0 add di,dx mov bx,0 charshows: cmp bx,top jne noempty mov byte ptr es:[di],&amp;#39;+&amp;#39; ; 结束符 jmp charret noempty: mov al,[si][bx] mov es:[di],al mov byte ptr es:[di+2],&amp;#39;+&amp;#39; ; 结束符 inc bx add di,2 jmp charshows charret: pop es pop di pop dx pop bx ret code ends end start 问题 问题现象:</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://sucicada.github.io/blog/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/about/</guid>
      <description>自己紹介がありません
有人和我一块玩代码吗。目前想要一起的：
stable diffusion 部署与学习使用 多端设备的图片、音乐自动同步：IOS, Android, Mac，Linux 音乐库的搭建：将2000首歌曲分类存储 hugo 博客优化 nginx 部署，通过域名转发请求 操作系统编写，即将开始：tty，文件系统，进程管理 MoeTTS 的融入日常的运行
有2台本地服务器，可提供 Nvidia 1080, 有域名, 国外云服务器 </description>
    </item>
    
    <item>
      <title>APG -- Algorithm PlayGround 基于Phaser 的算法游戏（类rpg）框架</title>
      <link>https://sucicada.github.io/blog/posts/soft/apg--algorithm-playground-%E5%9F%BA%E4%BA%8Ephaser-%E7%9A%84%E7%AE%97%E6%B3%95%E6%B8%B8%E6%88%8F%E7%B1%BBrpg%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/apg--algorithm-playground-%E5%9F%BA%E4%BA%8Ephaser-%E7%9A%84%E7%AE%97%E6%B3%95%E6%B8%B8%E6%88%8F%E7%B1%BBrpg%E6%A1%86%E6%9E%B6/</guid>
      <description>APG——Algorithm PlayGround 项目地址 一个有趣，智能和简单的HTML5游戏框架
简单的开发方式，将你的算法变成游戏
对PhaserCE库的封装开发
70+个函数接口可供使用，通过配置文件智能优化游戏
提供可视化的地图编辑方案
官网 官网(备用)
Demo 演示 git page(可能会慢) 国内使用
使用在线地图编辑器 APG MapEditor 下载 APG.js
MapEditor
使用在线库 github直连 https://sucicada.github.io/Algorithm-PlayGround/dist/APG.js 国内使用（更快） http://sucicada.tk:39/APG/dist/APG.js 最后 十分感谢 @llwwdbd, @lesen-bee 在开发期间所提供的帮助 </description>
    </item>
    
    
    <item>
      <title>assmbly 8086汇编：判断奇数偶数</title>
      <link>https://sucicada.github.io/blog/posts/soft/assmbly-8086%E6%B1%87%E7%BC%96%E5%88%A4%E6%96%AD%E5%A5%87%E6%95%B0%E5%81%B6%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/assmbly-8086%E6%B1%87%E7%BC%96%E5%88%A4%E6%96%AD%E5%A5%87%E6%95%B0%E5%81%B6%E6%95%B0/</guid>
      <description>如果ax中的数是奇数：bx为0
否则bx为1
; judge which the number in ax is odd or even assume cs:code code segment mov ax,[bx] mov cx,ax mov bx,0 s: loop i ; if can&amp;#39;t loop , cx is 1 ; every loop, cx -= 2 ; odd mov bx,0 loop k i: ; sub cx,1 loop s ; even mov bx,1 ; loop k k: ;over mov ax,4c00h int 21h code ends end </description>
    </item>
    
    <item>
      <title>atom删除文件: The following file couldn&#39;t be moved to trash (is gvfs-trash installed?)</title>
      <link>https://sucicada.github.io/blog/posts/soft/atom%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6-the-following-file-couldnt-be-moved-to-trash-is-gvfs-trash-installed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/atom%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6-the-following-file-couldnt-be-moved-to-trash-is-gvfs-trash-installed/</guid>
      <description>参考这个
在使用加环境变量无果
环境
ubuntu 16
atom 1.4
执行以下命令
sudo mkdir -p /.Trash-1000/{expunged,files,info} sudo chown -R $USER /.Trash-1000 </description>
    </item>
    
    <item>
      <title>cin、cin.get()、cin.getline()、getline()、gets()等函数的用法</title>
      <link>https://sucicada.github.io/blog/posts/soft/cincin.getcin.getlinegetlinegets%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/cincin.getcin.getlinegetlinegets%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
      <description>参考于cin、cin.get()、cin.getline()、getline()、gets()等函数的用法
cin&amp;raquo;
(1) &amp;raquo; 是会过滤掉不可见字符（如 空格 回车，TAB 等） cin.get()
(1) cin.get(char);//接受一个字符
(2) cin.get(char*,接收字符数目);//可以接收空格，接收数目=实际接收字符+1个&amp;rsquo;\0&#39; cin.getline()
(1) cin.getline(char*,接收数目);
//可以接收空格，接收数目=实际接收字符+1个&amp;rsquo;\0&#39;
(2) cin.getline(char*,接收数目,结束字符)
//当第三个参数省略时，系统默认为&amp;rsquo;\0&amp;rsquo;
//cin.getline(str,5,&amp;lsquo;a&amp;rsquo;);当输入abcdef时输出abcd，输入jkaljkljkl时，输出jk #include&amp;lt;string&amp;gt;
1.getline(cin,string str);//可以接收空格
2.gets(char *str);//可以接收空格
3.getchar()//getchar()是C语言的函数，C++也可以兼容，但是尽量不用或少用；</description>
    </item>
    
    <item>
      <title>clion 代码补全很慢 ( clion code completion slow)  clangd 配置</title>
      <link>https://sucicada.github.io/blog/posts/soft/clion-%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E5%BE%88%E6%85%A2-clion-code-completion-slow-clangd-%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/clion-%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E5%BE%88%E6%85%A2-clion-code-completion-slow-clangd-%E9%85%8D%E7%BD%AE/</guid>
      <description>查看官网
https://www.jetbrains.com/help/clion/settings-languages-cpp-clangd.html中 关于code completion 的说明
以下配置开启路径：
File | Settings | Languages and Frameworks | C/C++ | Clangd for Windows and Linux
CLion | Preferences | Languages and Frameworks | C/C++ | Clangd for macOS
我们得知 CLion 提供了两种代码提示引擎一种内置，一种是 Clangd。
默认的选择是只用Clangd，而不会优先用内置引擎。我们选择剩下两个会发现代码提示的速度快了很多。
这个现象能初步判断内置引擎比Clangd要快。至于更深层的原因还待研究。</description>
    </item>
    
    <item>
      <title>DFS的递归实现</title>
      <link>https://sucicada.github.io/blog/posts/soft/dfs%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/dfs%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/</guid>
      <description>对一个例子的理解，以下是关系图的关系矩阵，求从1开始能到哪个数
#include&amp;lt;iostream&amp;gt; #include&amp;lt;queue&amp;gt; # e&amp;lt;cstdio&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;stack&amp;gt; using namespace std; int const N =5; int maze[N][N]={ {0,1,1,0,0}, {0,0,1,0,1}, {0,0,1,0,0}, {1,1,0,0,1}, {0,0,1,0,0} }; int visit[N+1]={0}; //循环的思路： //用递归，一旦有更深的点就产生新的循环，当深的点操作完了，就结束了这个陷得最深的循环。 void dfs1(int start) { visit[start]=1; for(int i=1;i&amp;lt;=N;i++) { if(!visit[i]&amp;amp;&amp;amp;maze[start-1][i-1]==1) { dfs1 (i); } } cout&amp;lt;&amp;lt;start&amp;lt;&amp;lt;&amp;#34; &amp;#34;; } void dfs2(int start) { stack&amp;lt;int&amp;gt;s; s.push(start); visit[start]=1; int iff=0; while(!s.empty()) { iff=0; int v=s.top(); for(int i=1;i&amp;lt;=N;i++) { if(visit[i]==0&amp;amp;&amp;amp;maze[v-1][i-1]==1) { iff=1;//代表if了 visit[i]=1;//第一层 s.push(i); break;//保证当前只走一条路 } } if(iff==0)//到头不if才执行 { cout&amp;lt;&amp;lt;v&amp;lt;&amp;lt;&amp;#34; &amp;#34;; s.</description>
    </item>
    
    <item>
      <title>Flink 内存模型的分配策略 主公式推导</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/flink-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-%E4%B8%BB%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/flink-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5-%E4%B8%BB%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/</guid>
      <description>结论: 启动flink设定的 ytm数值 与实际监控展示的JVM_Heap数值关系是 (ytm大于1920的简化公式)
JVM_Heap = ytm * 0.45 - 256
啓動參數: -ytm 设定的实际是 进程总内存,相当于yarn容器大小
Total_Process_Memory: ytm JVM_Metaspace: 默認 256m JVM_Overhead: 默認 jtm * 0.1 (必須在 192m ~ 1g (默認)) Total_Flink_Memory: Total_Process_Memory - JVM_Overhead - JVM_Metaspace Framework_Heap: 默認 128m Managed_Memory: 默認 Total_Flink_Memory * 0.4 Framework_Off-Heap: 默認 128m Task_Off-Heap: 默認 0 Network: 默認 Total_Flink_Memory * 0.1 (必須在 64m ~ 1g (默認)) 所以 Task_Heap = Total_Flink_Memory - Framework_Heap - Managed_Memory - Framework_Off-Heap - Task_Off-Heap - Network 如果都用默认配置,那么代入化简就是</description>
    </item>
    
    <item>
      <title>Flink 算子Function实例化的坑</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/flink-%E7%AE%97%E5%AD%90function%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%9D%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/flink-%E7%AE%97%E5%AD%90function%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%9D%91/</guid>
      <description>问题回顾 关于一段代码：
object MySingleObj{ // 陷阱： // 单例对象中一个是可变引用，一个是可变数组 var str:String = _ val list = new ListBuffer[String] } ... dataStream .map(new RichMapFunction(){ // 问题1：obj1 和 obj2 的实例方式有什么区别。 // 问题2：考虑参数0的作用以及是否会得到预期效果。 val obj1:MyClass = new MyClass(参数0) var obj2:MyClass = _ override def open(paramation:Configuration): Unit = { obj2 = new MyClass(参数0) } override def map(value, ....) = { // 问题3：如果在这里使用 obj1 和 obj2 会有什么区别。 // 问题4：单个slot中对单例对象中的变量修改，造成的影响是。 MySingleObj.str = value MySingleObj.list += value } }) .</description>
    </item>
    
    <item>
      <title>Flume 数据流的处理过程 从源码看 Source Channel Sink</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/flume-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B-%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8B-source-channel-sink/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/flume-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B-%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8B-source-channel-sink/</guid>
      <description>Event 构成 Source Flume的三个部分：Source，Channel，Sink
数据是存储在Event对象中在这三部分之间传递
Event 构成 Event 接口
public interface Event { public Map&amp;lt;String, String&amp;gt; getHeaders(); public void setHeaders(Map&amp;lt;String, String&amp;gt; headers); public byte[] getBody(); public void setBody(byte[] body); } 以 最简单的实现类 SimpleEvent 为例子
public class SimpleEvent implements Event { private Map&amp;lt;String, String&amp;gt; headers; private byte[] body; ... } 可见
header 以 Map&amp;lt;String, String&amp;gt; 的形式存储键值对信息
body 二进制形式存储，从Source接收到的数据会存储在这里
Source 带着问题 header 里有什么 一些实现类 ExecSource ExecRunnable 主要处理 通过 EventBuilder.withBody 基础创建 Event ， 一行一个 Event header 为空 flushEventBatch 中 ChannelProcessor :: processEventBatch</description>
    </item>
    
    <item>
      <title>fuck</title>
      <link>https://sucicada.github.io/blog/posts/%E6%97%A5%E8%A8%98/fuck/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/%E6%97%A5%E8%A8%98/fuck/</guid>
      <description>&amp;ldquo;火山般的怒火燃烧着我的心，我的思绪如暴风般激荡，不断地翻涌着。我的身体紧张得像弦张到极限的琴弦，随时都可能爆裂。我的心跳如鼓舞，我的呼吸急促不安。我的脑海中充满了迷雾，我无法让自己冷静下来。我的身体像一个沸腾的锅，压抑不住的爆发。我的怒气如烈焰般燃烧，烧焦了我内心深处的一切。我是烦躁，焦虑和
暴躁的火山，永远不知道什么时候会喷发。我像一阵狂风，吹得人们无法立足。我是一道闪电，瞬间点燃所有的希望。我是一颗炸弹，随时都可能爆炸。我是一段痛苦的乐章，让人难受的和声。我是不安定的海洋，无尽的汹涌。我是烦躁，焦虑和暴躁的火山，永远不知道什么时候会喷发。&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Hbase2 没有org.apache.hadoop.hbase.mapreduce.TableInputFormat</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/hbase2-%E6%B2%A1%E6%9C%89org.apache.hadoop.hbase.mapreduce.tableinputformat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/hbase2-%E6%B2%A1%E6%9C%89org.apache.hadoop.hbase.mapreduce.tableinputformat/</guid>
      <description>导入
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.hbase&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hbase-mapreduce&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${hbase.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 参考链接：https://juejin.cn/post/6844903959585374221</description>
    </item>
    
    <item>
      <title>hdu 1022 栈</title>
      <link>https://sucicada.github.io/blog/posts/hduoj/hdu-1022-%E6%A0%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/hduoj/hdu-1022-%E6%A0%88/</guid>
      <description>久违的ac，真是艰难。第一次提交的竟然是直接判断b字符串是否为a的倒序。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;string&amp;gt; using namespace std; int main() { int t; string a,b; while(cin&amp;gt;&amp;gt;t&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b) { stack&amp;lt;char&amp;gt;s; string p; int i=0; t=a.size(); while(t--) { s.push(a[a.size()-t-1]); p+=&amp;#34;in\n&amp;#34;;//cout&amp;lt;&amp;lt;s.top()&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;b[i]; while(!s.empty()&amp;amp;&amp;amp;s.top()==b[i]) { //cout&amp;lt;&amp;lt;&amp;#34;i&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;endl; s.pop(); p+=&amp;#34;out\n&amp;#34;; i++; //cout&amp;lt;&amp;lt;s.size()&amp;lt;&amp;lt;&amp;#34;!!&amp;#34;&amp;lt;&amp;lt;endl; } } if(s.size()==0) cout&amp;lt;&amp;lt;&amp;#34;Yes.&amp;#34;&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;p; else cout&amp;lt;&amp;lt;&amp;#34;No.&amp;#34;&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;&amp;#34;FINISH&amp;#34;&amp;lt;&amp;lt;endl; } return 0; } </description>
    </item>
    
    <item>
      <title>hdu 1062（倒置句中单词）&lt;未戳破的玄学&gt;</title>
      <link>https://sucicada.github.io/blog/posts/hduoj/hdu-1062%E5%80%92%E7%BD%AE%E5%8F%A5%E4%B8%AD%E5%8D%95%E8%AF%8D%E6%9C%AA%E6%88%B3%E7%A0%B4%E7%9A%84%E7%8E%84%E5%AD%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/hduoj/hdu-1062%E5%80%92%E7%BD%AE%E5%8F%A5%E4%B8%AD%E5%8D%95%E8%AF%8D%E6%9C%AA%E6%88%B3%E7%A0%B4%E7%9A%84%E7%8E%84%E5%AD%A6/</guid>
      <description>pe诅咒，多人见证的玄学，终有一天能破解
初回进阶版
#include&amp;lt;stdio.h&amp;gt; #include&amp;lt;string.h&amp;gt; int main() { int T,i,j,t; char a[1000];//=&amp;#34;123 4567&amp;#34;; while(scanf(&amp;#34;%d&amp;#34;,&amp;amp;T)==1) { while(T--) { getchar(); //setbuf(stdin,NULL);//失败了，暂不知为什么 scanf(&amp;#34;%[^\n]&amp;#34;,a); i=0;////j是大移动位，i是执行位 //xprintf(&amp;#34;origin %s\n&amp;#34;); for(j=0;j&amp;lt;strlen(a);j++) { //printf(&amp;#34;!!%s\n&amp;#34;,a); if(a[j+1]==&amp;#39; &amp;#39;||a[j+1]==&amp;#39;\0&amp;#39;) { //printf(&amp;#34;a[] %c\n&amp;#34;,a[j]); t=i; for(;i&amp;lt;(j+t+1)/2;i++) { a[i]+=a[j-i+t]; a[j-i+t]=a[i]-a[j-i+t]; a[i]=a[i]-a[j-i+t]; //printf(&amp;#34;!%s\n&amp;#34;,a); } i=j+2; } } printf(&amp;#34;%s\n&amp;#34;,a); } //printf(&amp;#34;end\n&amp;#34;); } } 临终版
#include&amp;lt;stdio.h&amp;gt; #include&amp;lt;string.h&amp;gt; int main() { int T,i,j,t; char a[1003]; scanf(&amp;#34;%d&amp;#34;,&amp;amp;T); while(T--) { getchar(); scanf(&amp;#34;%[^\n]&amp;#34;,a); i=0; for(j=0;j&amp;lt;strlen(a);j++) { if(a[j+1]==&amp;#39; &amp;#39;||(j+1)==strlen(a))) { t=j; while(t&amp;gt;=i) printf(&amp;#34;%c&amp;#34;,a[t--]); if(a[j+1]==&amp;#39; &amp;#39;) printf(&amp;#34; &amp;#34;); i=j+2; } } printf(&amp;#34;\n&amp;#34;); } return 0; } </description>
    </item>
    
    <item>
      <title>hdu1002（超超长数字相加）</title>
      <link>https://sucicada.github.io/blog/posts/hduoj/hdu1002%E8%B6%85%E8%B6%85%E9%95%BF%E6%95%B0%E5%AD%97%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/hduoj/hdu1002%E8%B6%85%E8%B6%85%E9%95%BF%E6%95%B0%E5%AD%97%E7%9B%B8%E5%8A%A0/</guid>
      <description>差点gg，用的是字符串数组来存数，加数，下面是原题
*保留了所有的注释
*没有进行代码缩减
Input
The first line of the input contains an integer T(1&amp;lt;=T&amp;lt;=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000.
Output
For each test case, you should output two lines.</description>
    </item>
    
    <item>
      <title>istringstream、ostringstream、stringstream 类介绍 .</title>
      <link>https://sucicada.github.io/blog/posts/soft/istringstreamostringstreamstringstream-%E7%B1%BB%E4%BB%8B%E7%BB%8D-./</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/istringstreamostringstreamstringstream-%E7%B1%BB%E4%BB%8B%E7%BB%8D-./</guid>
      <description>见以下链接
istringstream、ostringstream、stringstream 类介绍 .
0、C++的输入输出分为三种：
(1)基于控制台的I/O
#include&amp;lt;iostream&amp;gt; (2)基于文件的I/O
#include&amp;lt;fstream&amp;gt; (3)基于字符串的I/O
#include&amp;lt;sstream&amp;gt; str()：使istringstream对象返回一个string字符串
stringstream::clear()//多次使用，先清空此对象的流，不能使用stream.str(&amp;#34;&amp;#34;); //实际上，它并不清空任何内容，它只是重置了流的状态标志而已 ps:但如果你要在程序中用同一个流，反复读写大量的数据，将会造成大量的内存消耗， 这时候，需要适时地清除一下缓冲 (用 stream.str(&amp;quot;&amp;quot;) )。</description>
    </item>
    
    <item>
      <title>Jetty 报错 Tomcat不报错 maven jetty插件不报错, 可能是jetty版本不统一造成</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/jetty-%E6%8A%A5%E9%94%99-tomcat%E4%B8%8D%E6%8A%A5%E9%94%99-maven-jetty%E6%8F%92%E4%BB%B6%E4%B8%8D%E6%8A%A5%E9%94%99-%E5%8F%AF%E8%83%BD%E6%98%AFjetty%E7%89%88%E6%9C%AC%E4%B8%8D%E7%BB%9F%E4%B8%80%E9%80%A0%E6%88%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/jetty-%E6%8A%A5%E9%94%99-tomcat%E4%B8%8D%E6%8A%A5%E9%94%99-maven-jetty%E6%8F%92%E4%BB%B6%E4%B8%8D%E6%8A%A5%E9%94%99-%E5%8F%AF%E8%83%BD%E6%98%AFjetty%E7%89%88%E6%9C%AC%E4%B8%8D%E7%BB%9F%E4%B8%80%E9%80%A0%E6%88%90/</guid>
      <description>要在服务器上部署, jetty报错找不见hibernate某个函数, 然而此函数存在.
开发环境为 Intellij
jetty插件版本: 9.2.6.v20141205
外置jetty版本: 9.4.21.v20190926
如果你也有类似问题, 不妨试试将jetty版本统一
我将外置jetty降版本后成功
来自这里的启发</description>
    </item>
    
    <item>
      <title>js 生成当前日期时间</title>
      <link>https://sucicada.github.io/blog/posts/soft/js-%E7%94%9F%E6%88%90%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/js-%E7%94%9F%E6%88%90%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/</guid>
      <description>精简版
var date = new Date(); datetime = date.toLocaleDateString().split(&amp;#39;/&amp;#39;).slice(2,3).concat( date.toLocaleDateString().split(&amp;#39;/&amp;#39;).splice(0,2)).join(&amp;#39;-&amp;#39;) + &amp;#34; &amp;#34; + ( date.toLocaleTimeString().split(&amp;#39; &amp;#39;)[1]==&amp;#39;AM&amp;#39; ? date.toLocaleTimeString().split(&amp;#39; &amp;#39;)[0] : [parseInt(date.toLocaleTimeString().split(&amp;#39; &amp;#39;)[0].split(&amp;#39;:&amp;#39;)[0]) + 12].concat( date.toLocaleTimeString().split(&amp;#39; &amp;#39;)[0].split(&amp;#39;:&amp;#39;).splice(1,3)).join(&amp;#39;:&amp;#39;) ); 人看的版
var date = new Date(); var dd = date.toLocaleDateString().split(&amp;#39;/&amp;#39;); var dd = dd.slice(2,3).concat( dd.splice(0,2)).join(&amp;#39;-&amp;#39;); var time = date.toLocaleTimeString().split(&amp;#39; &amp;#39;); var time = time[1]==&amp;#39;AM&amp;#39; ? time[0] : [parseInt(time[0].split(&amp;#39;:&amp;#39;)[0]) + 12].concat(time[0].split(&amp;#39;:&amp;#39;).splice(1,3)).join(&amp;#39;:&amp;#39;); var datetime = dd + &amp;#34; &amp;#34; + time; </description>
    </item>
    
    <item>
      <title>leetcode  - 12. Integer to Roman with Java</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcode-12.-integer-to-roman-with-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcode-12.-integer-to-roman-with-java/</guid>
      <description>problem
方法一，一位一位判断。
class Solution { public String intToRoman1(int num) { StringBuilder sb = new StringBuilder(); char ooo[] = new char[]{&amp;#39;I&amp;#39;,&amp;#39;V&amp;#39;,&amp;#39;X&amp;#39;,&amp;#39;L&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;D&amp;#39;,&amp;#39;M&amp;#39;}; int wei = 0; while(num&amp;gt;0){ int n = num %10; if(n&amp;lt;4){ for(int i=0;i&amp;lt;n;i++){ sb.append(ooo[wei*2]); } }else if(n==4){ sb.append(ooo[wei*2+1]); sb.append(ooo[wei*2]); }else if(n==5){ sb.append(ooo[wei*2+1]); }else if(n&amp;gt;5 &amp;amp;&amp;amp; n&amp;lt;9){ for(int i=0;i&amp;lt;n-5;i++){ sb.append(ooo[wei*2]); } sb.append(ooo[wei*2+1]); }else if(n==9){ sb.append(ooo[wei*2+1+1]); sb.append(ooo[wei*2]); } wei++; num = num/10; } return sb.reverse().toString(); } 方法二，因为知道最多4位数，所以打表暴力。
public String intToRoman(int num) { String s1[] = new String[]{&amp;#34;&amp;#34;,&amp;#34;I&amp;#34;,&amp;#34;II&amp;#34;,&amp;#34;III&amp;#34;,&amp;#34;IV&amp;#34;,&amp;#34;V&amp;#34;,&amp;#34;VI&amp;#34;,&amp;#34;VII&amp;#34;,&amp;#34;VIII&amp;#34;,&amp;#34;IX&amp;#34;}; String s2[] = new String[]{&amp;#34;&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;XX&amp;#34;,&amp;#34;XXX&amp;#34;,&amp;#34;XL&amp;#34;,&amp;#34;L&amp;#34;,&amp;#34;LX&amp;#34;,&amp;#34;LXX&amp;#34;,&amp;#34;LXXX&amp;#34;,&amp;#34;XC&amp;#34;}; String s3[] = new String[]{&amp;#34;&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;CC&amp;#34;,&amp;#34;CCC&amp;#34;,&amp;#34;CD&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;DC&amp;#34;,&amp;#34;DCC&amp;#34;,&amp;#34;DCCC&amp;#34;,&amp;#34;CM&amp;#34;}; String s4[] = new String[]{&amp;#34;&amp;#34;,&amp;#34;M&amp;#34;,&amp;#34;MM&amp;#34;,&amp;#34;MMM&amp;#34;}; // return s4[(num/1000)%10]+s3[(num/100)%10]+s2[(num/10)%10]+s1[num%10]; return new StringBuilder().</description>
    </item>
    
    <item>
      <title>leetcode - 1. Two Sum with Java</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcode-1.-two-sum-with-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcode-1.-two-sum-with-java/</guid>
      <description>https://leetcode.com/problems/two-sum/submissions/
import java.util.*; class Main { public int[] fun(int []nums,int target) { Map&amp;lt;Integer,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for(int i=0;i&amp;lt;nums.length;i++){ int f = target - nums[i]; if(map.get(f)!=null){ return new int[]{map.get(f),i}; }else{ map.put(nums[i],i); } } return null; } public static void main(String[] args) { int []nums = {12,3,3,53,45,7,7,3}; int []res = new Main().fun(nums,10); System.out.println(Arrays.toString(nums)); System.out.println(Arrays.toString(res)); } } </description>
    </item>
    
    <item>
      <title>leetcode - 11. Container With Most Water with Java</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcode-11.-container-with-most-water-with-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcode-11.-container-with-most-water-with-java/</guid>
      <description>problem
import java.lang.reflect.Method; import java.util.*; class Solution { public int maxArea(int[] height) { int max = 0; int left = 0; int right = height.length-1; int a,b; while(left&amp;lt;right){ a = height[left]; b = height[right]; max = Math.max(max, Math.min(a,b)*(right-left)); if(a &amp;gt; b){ right -- ; }else{ left ++; } System.out.println(left+&amp;#34; &amp;#34;+right+&amp;#34; &amp;#34;); } return max; } } class Main { public static void main(String[] args) throws Exception{ Solution solution = new Solution(); int i = solution.</description>
    </item>
    
    <item>
      <title>leetcode - 2. Add Two Numbers with Java</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcode-2.-add-two-numbers-with-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcode-2.-add-two-numbers-with-java/</guid>
      <description>https://leetcode.com/problems/add-two-numbers/submissions/
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode res = new ListNode(0); ListNode head = res; int flag = 0; while(l1!=null || l2!=null || flag!=0){ int num = (l1==null?0:l1.val) + (l2==null? 0: l2.val) + flag; res.next = new ListNode(num%10); flag = num/10; res = res.</description>
    </item>
    
    <item>
      <title>leetcode - 3. Longest Substring Without Repeating Characters with Java</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcode-3.-longest-substring-without-repeating-characters-with-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcode-3.-longest-substring-without-repeating-characters-with-java/</guid>
      <description>题目链接
import java.lang.reflect.Method; class Solution { /*两个方法都是：end无所谓的在一个一个移动，begin则是追寻之前的循环体留下的信标 关键在于信标是怎么设置下的，第一种方法是每一次都从序列中寻找信标。 第二种直接记录了下来。 一个用时间换空间，一个用空间换时间。 */ public int lengthOfLongestSubstring1(String s) { int sum = 0; int begin = 0; int end = 0; for(end = begin;end&amp;lt;s.length();end++){ /*每次都移动尾指针*/ for(int i = begin;i&amp;lt;end;i++){ /*验证重复，和end处比较，如果没有重复，说明这个子串可以加入end处的字符 而无论是否重复，都不影响移动尾指针end，影响的只是begin的位置。 */ if(s.charAt(i) == s.charAt(end)){ sum = Math.max(sum,end-begin); begin = i+1; break; } } } /*最后的end会指向最后一个的下一个，所以需要再判断一下夹住的是不是大的， eg: ab or aab */ return Math.max(sum,end-begin); } public int lengthOfLongestSubstring2(String s) { int ascii[] = new int[128]; int sum = 0; int begin = 0; for(int i=0;i&amp;lt;s.</description>
    </item>
    
    <item>
      <title>leetcode - 4. Median of Two Sorted Arrays with Java</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcode-4.-median-of-two-sorted-arrays-with-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcode-4.-median-of-two-sorted-arrays-with-java/</guid>
      <description>简单做法, 左边哪一些, 右边拿一下, 看谁小拿谁.
但是时间复杂度达不到要求, 虽然在leetcode上也是很快
public double findMedianSortedArrays1(int[] A,int[] B){ /* time complexity: O((m+n)/2+1) */ int m = A.length; int n = B.length; int index1 = 0; int index2 = 0; int num1=0; int num2=0; for(int i=0;i&amp;lt;(m+n)/2+1;i++){ num2 = num1; if(index1 == m){ num1 = B[index2]; index2 ++; }else if(index2 == n){ num1 = A[index1]; index1++; }else if(A[index1] &amp;lt; B[index2]){ num1 = A[index1]; index1++; }else{ num1 = B[index2]; index2++; } } System.</description>
    </item>
    
    <item>
      <title>leetcode - 5. Longest Palindromic Substring with Java</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcode-5.-longest-palindromic-substring-with-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcode-5.-longest-palindromic-substring-with-java/</guid>
      <description>题目在我这里
方法一，大暴力
public String longestPalindrome1(String s) { /* very force: O(s.length()^2) 空间复杂度 O(1) */ int i=0; int j=0; boolean flag = false; int maxi = i; int maxj = j; for(i=0;i&amp;lt;s.length();i++){ for(j=s.length()-1;j&amp;gt;i;j--){ if(s.charAt(i)==s.charAt(j)){ int ii = i; int jj = j; for(jj=j;jj&amp;gt;ii;jj--,ii++){ if(s.charAt(ii)!=s.charAt(jj)){ // flag = true; break; } } System.out.println(ii+&amp;#34; - &amp;#34;+jj); if(ii&amp;gt;=jj){ flag = true; break; } } } if(flag){ if(j-i &amp;gt; maxj-maxi){ maxj = j; maxi = i; } } } if(s.</description>
    </item>
    
    <item>
      <title>leetcode - 6. ZigZag Conversion with Java</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcode-6.-zigzag-conversion-with-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcode-6.-zigzag-conversion-with-java/</guid>
      <description>题目地址
这道题涉及到String, StringBuffer, StringBuilder的知识点
String在拼接时需要new新的String对象, 而它除了hash之外都是final属性, 分配空间会造成时间损耗.
所以String不适合大量拼接. 使用String可是耗时18ms呢
StringBuffer解决了这个问题, 它提升了速度, 是线程安全.
而StringBuilder 和StringBuffer类似, 但它是线程不安全, 这也使得它比StringBuffer拼接更快. 本题只需3ms
有没有更快的呢, 当然有, 还就是它了 char[], 只需2ms(笑)
import java.lang.reflect.Method; import java.util.*; class Solution { public String convert(String s, int numRows) { int N = s.length(); // StringBuilder res = new StringBuilder(); char res[] = new char[N]; int cycle = (numRows-1)*2; int index = 0; if(numRows==1){ return s; } for(int row=0;row&amp;lt;numRows;row++){ /* row 0 6 1 4 2 2 2 4 3 0 */ for(int i=row;i&amp;lt;N;i+=cycle){ /* 一个锯齿*/ // res.</description>
    </item>
    
    <item>
      <title>leetcode - 7. Reverse Integer with Java</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcode-7.-reverse-integer-with-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcode-7.-reverse-integer-with-java/</guid>
      <description>where is problem 搞笑的空间复杂度
使用long，最后进行比较会更小，不知道为什么
class Solution { public int reverse(int x) { boolean minus = x&amp;lt;0; x *= minus?-1:1; int res = 0; while(x&amp;gt;0){ if(res*10/10 != res){ return 0; } res = res*10 + x%10; x = x/10; } return res * (minus?-1:1); } } </description>
    </item>
    
    <item>
      <title>leetcode - 8. String to Integer (atoi) with Java</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcode-8.-string-to-integer-atoi-with-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcode-8.-string-to-integer-atoi-with-java/</guid>
      <description>题目
class Solution { public int myAtoi(String str) { int N = str.length(); int minus = 0; long res = 0; for(int i=0;i&amp;lt;N;i++){ char ch = str.charAt(i); System.out.println(ch+&amp;#34; &amp;#34;+minus); if((ch == &amp;#39;-&amp;#39; || ch == &amp;#39;+&amp;#39;) &amp;amp;&amp;amp; minus == 0){ minus = ch==&amp;#39;+&amp;#39;?1:-1; }else if(ch ==&amp;#39; &amp;#39; &amp;amp;&amp;amp; minus==0){ }else if(ch &amp;lt;=&amp;#39;9&amp;#39; &amp;amp;&amp;amp; ch&amp;gt;=&amp;#39;0&amp;#39;){ if(minus == 0){ minus = 1; } res = res*10 + ch-&amp;#39;0&amp;#39;; if(res != (int)res){ return minus==1?</description>
    </item>
    
    <item>
      <title>leetcode - 9. Palindrome Number with Java</title>
      <link>https://sucicada.github.io/blog/posts/leetcode/leetcode-9.-palindrome-number-with-java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/leetcode/leetcode-9.-palindrome-number-with-java/</guid>
      <description>题目
class Solution { public boolean isPalindrome(int x) { if(x&amp;lt;0){ return false; } int a = 0; int b = x; while(x&amp;gt;0){ a = a * 10 + x%10; x = x/10; } return a==b; } } </description>
    </item>
    
    <item>
      <title>linux  通过  openconnect  来连接学校内网</title>
      <link>https://sucicada.github.io/blog/posts/soft/linux-%E9%80%9A%E8%BF%87-openconnect-%E6%9D%A5%E8%BF%9E%E6%8E%A5%E5%AD%A6%E6%A0%A1%E5%86%85%E7%BD%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/linux-%E9%80%9A%E8%BF%87-openconnect-%E6%9D%A5%E8%BF%9E%E6%8E%A5%E5%AD%A6%E6%A0%A1%E5%86%85%E7%BD%91/</guid>
      <description>参考
http://xingda1989.iteye.com/blog/1969908
https://blog.csdn.net/edin_blackpoint/article/details/70860101
sudo apt install openconnect
在/etc/vpc/目录下新建vpnc-script 文件
文件内容可以到此处拷贝
http://git.infradead.org/users/dwmw2/vpnc-scripts.git/blob_plain/HEAD:/vpnc-script
sudo openconnect --juniper -u [你的学号] --script /etc/vpnc/vpnc-script [你学校的提供的vpn的url]</description>
    </item>
    
    <item>
      <title>Linux Mint 使用 VNC Server (x11vnc) 进行远程屏幕</title>
      <link>https://sucicada.github.io/blog/posts/soft/linux-mint-%E4%BD%BF%E7%94%A8-vnc-server-x11vnc-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%B1%8F%E5%B9%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/linux-mint-%E4%BD%BF%E7%94%A8-vnc-server-x11vnc-%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%B1%8F%E5%B9%95/</guid>
      <description>https://community.linuxmint.com/tutorial/view/2334
This tutorial was adapted from here.
Remove the default Vino server: sudo apt-get -y remove vino
Install x11vnc: sudo apt-get -y install x11vnc
Create the directory for the password file: sudo mkdir /etc/x11vnc
Create the encrypted password file: sudo x11vnc --storepasswd /etc/x11vnc/vncpwd
You will be asked to enter and verify the password. Then press Y to
save the password file.
Create the systemd service file for the x11vnc service: sudo xed /lib/systemd/system/x11vnc.</description>
    </item>
    
    <item>
      <title>linux mint系统 cinnamon桌面 发大镜功能</title>
      <link>https://sucicada.github.io/blog/posts/soft/linux-mint%E7%B3%BB%E7%BB%9F-cinnamon%E6%A1%8C%E9%9D%A2-%E5%8F%91%E5%A4%A7%E9%95%9C%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/linux-mint%E7%B3%BB%E7%BB%9F-cinnamon%E6%A1%8C%E9%9D%A2-%E5%8F%91%E5%A4%A7%E9%95%9C%E5%8A%9F%E8%83%BD/</guid>
      <description>让我来告诉迷途中的你cinnamon桌面一个好用的功能.
选择设置
选择窗口 -&amp;gt; 选择行为
看那个窗口移动和调整大小的特殊键 Alt
好了按住alt在滑动滑轮 世界不一样了
对于小屏幕高分辨率电脑极为友好</description>
    </item>
    
    <item>
      <title>linux remmina 使用rdp协议连接windows显示Failed to startup SSH session:connection refused解决</title>
      <link>https://sucicada.github.io/blog/posts/soft/linux-remmina-%E4%BD%BF%E7%94%A8rdp%E5%8D%8F%E8%AE%AE%E8%BF%9E%E6%8E%A5windows%E6%98%BE%E7%A4%BAfailed-to-startup-ssh-sessionconnection-refused%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/linux-remmina-%E4%BD%BF%E7%94%A8rdp%E5%8D%8F%E8%AE%AE%E8%BF%9E%E6%8E%A5windows%E6%98%BE%E7%A4%BAfailed-to-startup-ssh-sessionconnection-refused%E8%A7%A3%E5%86%B3/</guid>
      <description>https://cn.aliyun.com/jiaocheng/165641.html
删除~/.freerdp/known_hosts
但是我找不见这个文件
尝试删除~/.remmina/remmina.pref 文件 成功</description>
    </item>
    
    <item>
      <title>linux 下安装 Cisco Packet Tracer 7.11以及一些注意(辛酸史)</title>
      <link>https://sucicada.github.io/blog/posts/soft/linux-%E4%B8%8B%E5%AE%89%E8%A3%85-cisco-packet-tracer-7.11%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E8%BE%9B%E9%85%B8%E5%8F%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/linux-%E4%B8%8B%E5%AE%89%E8%A3%85-cisco-packet-tracer-7.11%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E8%BE%9B%E9%85%B8%E5%8F%B2/</guid>
      <description>https://blog.csdn.net/qq_35882901/article/details/77652571
https://linux.cn/article-5576-1.html
开启登录问题
https://blog.csdn.net/u012321131/article/details/78587383
到软件的根目录下 执行以下脚本
sudo ./set_ptenv.sh sudo ./set_qtenv.sh
**一定按步骤走 **
安装在默认的/opt/pt 如果因为安装在家目录而导致闪退 就重新安装在默认路径下
一些依赖库
sudo apt install libqt5scripttools5
sudo apt-get install libqt5multimedia5-plugins
2018/9/18
因为3560的三层交换机的端口信息不显示,忍不了linux的bug,下了6版本的linux版本.
安装失败,
换回7版本,(核心已转储)&amp;hellip;..made?
一个晚上的尝试,发现只是在当前的这个用户下运行不了,&amp;hellip;..放弃了,
那么用wine吧
满心欢喜的安装好了,然后打算慢慢的把7版本的实验在6版本上重打一遍,
但是,cpu占用28,温度81&amp;hellip;&amp;hellip;.耗不起
那么赞颂我们伟大的虚拟机吧
virtualbox的无缝模式太强大了,wine什么的掰掰吧,</description>
    </item>
    
    <item>
      <title>linux 下的torrent下载器qBitTorrent</title>
      <link>https://sucicada.github.io/blog/posts/soft/linux-%E4%B8%8B%E7%9A%84torrent%E4%B8%8B%E8%BD%BD%E5%99%A8qbittorrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/linux-%E4%B8%8B%E7%9A%84torrent%E4%B8%8B%E8%BD%BD%E5%99%A8qbittorrent/</guid>
      <description>BT下载利器&amp;ndash;Qbittorrent完全攻
Ubuntu使用命令安装qBittorrent的方法
源码下载</description>
    </item>
    
    <item>
      <title>mysql workbench闪退解决办法</title>
      <link>https://sucicada.github.io/blog/posts/soft/mysql-workbench%E9%97%AA%E9%80%80%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/mysql-workbench%E9%97%AA%E9%80%80%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>感谢google，感谢csdn
linux下：
rm -rf .mysql/workbench/
windows下：
删除C:\Users\Administrator\AppData\Roaming\MySQL\Workbench
这个问题没有社区的帮助，我就真的没辙了</description>
    </item>
    
    <item>
      <title>mysql数据库连接以及执行的java类</title>
      <link>https://sucicada.github.io/blog/posts/soft/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E7%9A%84java%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E7%9A%84java%E7%B1%BB/</guid>
      <description>应该使用json等配置文件来保存要连接的数据库信息,密码等.
先存一下,以后再说
DB_connection.java
/* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ package com; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; /** * * @author peng */ public class DB_connection { // JDBC 驱动名及数据库 URL String JDBC_DRIVER = &amp;#34;com.mysql.jdbc.Driver&amp;#34;; String DB_URL = &amp;#34;jdbc:mysql://localhost:3306/javabbs?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;#34;; // 数据库的用户名与密码，需要根据自己的设置 String USER = &amp;#34;root&amp;#34;; String PASS = &amp;#34;mysql&amp;#34;; Connection conn = null; // private static DB_connection dB_connection =null; // public static DB_connection getInstance(){ // if(DB_connection == null){ // DB_connection = new DB_connection; // } // return DB_connection; // } public Connection connect(){ try{ Class.</description>
    </item>
    
    <item>
      <title>NYOJ-1204 魔法少女</title>
      <link>https://sucicada.github.io/blog/posts/soft/nyoj-1204-%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/nyoj-1204-%E9%AD%94%E6%B3%95%E5%B0%91%E5%A5%B3/</guid>
      <description>http://nyoj.top/problem/1204
#include&amp;lt;iostream&amp;gt; using namespace std; int h[10006]; int d[10006][2]; // 每一 //int fun(int a,int b){ // if(a&amp;lt;0) // return 0; // if(b==0){ // if(d[a-1][0]&amp;lt;d[a-1][1]){ // cout&amp;lt;&amp;lt;d[a-1][0]&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;a-1&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl; // fun(a-1,0); // }else{ // cout&amp;lt;&amp;lt;d[a-1][1]&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;a-1&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;1&amp;lt;&amp;lt;endl; // fun(a-1,1); // } // }else{ // if(d[a-1][0] &amp;lt; d[a-2][0]){ // cout&amp;lt;&amp;lt;d[a-1][0]&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;a-1&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl; // fun(a-1,0); // }else{ // cout&amp;lt;&amp;lt;d[a-2][0]&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;a-2&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl; // fun(a-2,0); // } // } //} int main(){ int n; while(cin&amp;gt;&amp;gt;n){ for(int i=0;i&amp;lt;n;i++){ cin&amp;gt;&amp;gt;h[i]; } // 0 not // 1 do d[0][0] = h[0]; d[0][1] = 0; d[1][0] = h[1]; d[1][1] = 0; for(int i=2;i&amp;lt;n;i++){ d[i][0] = min(d[i-1][1], d[i-1][0]) + h[i]; d[i][1] = min(d[i-1][0], d[i-2][0]); // 这一层飞了的时间数，和上一层没有飞，以及上上一层没有飞花费的时间数是一样的 } // for(int j=0;j&amp;lt;2;j++){ // for(int i=0;i&amp;lt;n;i++){ // cout&amp;lt;&amp;lt; d[i][j]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; // } // cout&amp;lt;&amp;lt;endl; // } // // if((d[n-1][0]&amp;lt;d[n-1][1])){ // cout&amp;lt;&amp;lt;d[n-1][0]&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;n-1&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;0&amp;lt;&amp;lt;endl; // fun(n-1,0); // }else{ // cout&amp;lt;&amp;lt;d[n-1][1]&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;n-1&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;1&amp;lt;&amp;lt;endl; // fun(n-1,1); // } cout&amp;lt;&amp;lt; min(d[n-1][0],d[n-1][1]) &amp;lt;&amp;lt;endl; } } 伟大的动态规划，我真是愚蠢</description>
    </item>
    
    <item>
      <title>Phaser 引擎 中TiledMap 的 json地图配置文件的格式</title>
      <link>https://sucicada.github.io/blog/posts/soft/phaser-%E5%BC%95%E6%93%8E-%E4%B8%ADtiledmap-%E7%9A%84-json%E5%9C%B0%E5%9B%BE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/phaser-%E5%BC%95%E6%93%8E-%E4%B8%ADtiledmap-%E7%9A%84-json%E5%9C%B0%E5%9B%BE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F/</guid>
      <description>官方推荐Tiled 地图编辑器,
https://www.mapeditor.org/
所以查看地图格式直接看Tiled 的官方帮助文档
http://doc.mapeditor.org/en/stable/reference/json-map-format/</description>
    </item>
    
    <item>
      <title>phaser 按键表 keyboard keycode</title>
      <link>https://sucicada.github.io/blog/posts/soft/phaser-%E6%8C%89%E9%94%AE%E8%A1%A8-keyboard-keycode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/phaser-%E6%8C%89%E9%94%AE%E8%A1%A8-keyboard-keycode/</guid>
      <description>https://photonstorm.github.io/phaser-ce/Phaser.KeyCode.html
帮助文档里都有,但就是没人说</description>
    </item>
    
    <item>
      <title>PhaserCE 使用 create.texture 出错  Phaser.Cache.addImage: Image &#34;xx&#34; is not complete 并且图形没有显示</title>
      <link>https://sucicada.github.io/blog/posts/soft/phaserce-%E4%BD%BF%E7%94%A8-create.texture-%E5%87%BA%E9%94%99-phaser.cache.addimage-image-xx-is-not-complete-%E5%B9%B6%E4%B8%94%E5%9B%BE%E5%BD%A2%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/phaserce-%E4%BD%BF%E7%94%A8-create.texture-%E5%87%BA%E9%94%99-phaser.cache.addimage-image-xx-is-not-complete-%E5%B9%B6%E4%B8%94%E5%9B%BE%E5%BD%A2%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA/</guid>
      <description>首先参看官网文档的写法 https://photonstorm.github.io/phaser-ce/Phaser.Create.html#texture
var game = new Phaser.Game(800, 600, Phaser.CANVAS, &amp;#39;game&amp;#39;, { preload: preload, create: create, }); function preload(){ var data = [ &amp;#39; 333 &amp;#39;, &amp;#39; 777 &amp;#39;, &amp;#39;E333E&amp;#39;, &amp;#39; 333 &amp;#39;, &amp;#39; 3 3 &amp;#39;]; game.create.texture(&amp;#39;bob&amp;#39;, data); } function create() { game.add.sprite(0, 0, &amp;#39;bob&amp;#39;); } 控制台警告
Phaser.Cache.addImage: Image &amp;#34;xx&amp;#34; is not complete 改为
...... game.create.texture(&amp;#39;bob&amp;#39;, data,100,10,0,true,function(f){}); ...... 警告
Phaser.Cache.getImage: Key &amp;#34;xx&amp;#34; not found in Cache. 查找资料无果，实验之后发现
使用
game.load.imageFromTexture(&amp;#39;bob&amp;#39;,data,100,1); 替换</description>
    </item>
    
    <item>
      <title>pyhton 下 使用getch(), 输入字符无需回车</title>
      <link>https://sucicada.github.io/blog/posts/soft/pyhton-%E4%B8%8B-%E4%BD%BF%E7%94%A8getch-%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E6%97%A0%E9%9C%80%E5%9B%9E%E8%BD%A6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/pyhton-%E4%B8%8B-%E4%BD%BF%E7%94%A8getch-%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E6%97%A0%E9%9C%80%E5%9B%9E%E8%BD%A6/</guid>
      <description>#原代码来自
https://code.activestate.com/recipes/134892-getch-like-unbuffered-character-reading-from-stdin/
同时支持windows和unix平台
class _Getch: &amp;#34;&amp;#34;&amp;#34;Gets a single character from standard input. Does not echo to the screen.&amp;#34;&amp;#34;&amp;#34; def __init__(self): try: self.impl = _GetchWindows() except ImportError: self.impl = _GetchUnix() def __call__(self): return self.impl() class _GetchUnix: def __init__(self): import tty, sys def __call__(self): import sys, tty, termios fd = sys.stdin.fileno() old_settings = termios.tcgetattr(fd) try: tty.setraw(sys.stdin.fileno()) ch = sys.stdin.read(1) finally: termios.tcsetattr(fd, termios.TCSADRAIN, old_settings) return ch class _GetchWindows: def __init__(self): import msvcrt def __call__(self): import msvcrt return msvcrt.</description>
    </item>
    
    <item>
      <title>python matplotlibmat 包mplot3d工具   三维视图透视取消</title>
      <link>https://sucicada.github.io/blog/posts/soft/python-matplotlibmat-%E5%8C%85mplot3d%E5%B7%A5%E5%85%B7-%E4%B8%89%E7%BB%B4%E8%A7%86%E5%9B%BE%E9%80%8F%E8%A7%86%E5%8F%96%E6%B6%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/python-matplotlibmat-%E5%8C%85mplot3d%E5%B7%A5%E5%85%B7-%E4%B8%89%E7%BB%B4%E8%A7%86%E5%9B%BE%E9%80%8F%E8%A7%86%E5%8F%96%E6%B6%88/</guid>
      <description>https://stackoverflow.com/questions/23840756/how-to-disable-perspective-in-mplot3d
简单的解决方法是
ax = fig.add_subplot(111, projection=&amp;#39;3d&amp;#39;, proj_type=&amp;#39;ortho&amp;#39;) 注意111 和 proj_type=&amp;lsquo;ortho&amp;rsquo;
辛亏在打算转用Mayavi 前找到了解决方法</description>
    </item>
    
    <item>
      <title>python pip安装不成功 在windows下</title>
      <link>https://sucicada.github.io/blog/posts/soft/python-pip%E5%AE%89%E8%A3%85%E4%B8%8D%E6%88%90%E5%8A%9F-%E5%9C%A8windows%E4%B8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/python-pip%E5%AE%89%E8%A3%85%E4%B8%8D%E6%88%90%E5%8A%9F-%E5%9C%A8windows%E4%B8%8B/</guid>
      <description>我用的是windows。你可以试试以管理员模式运行终端。
我在用python安装第三方库时，使用如下方式
pip install xxxx.whl 但是无论如何都只显示到
Installing collected packages: xxxx
然后就没了，和网上说的出来什么success提示完全不，然后我通过import来验证，也是没有安装上的。
一定要出现
Successful installed xxxx
才算成功。
如果你的问题不是这样的，请查查看别的家的博客。
花了一个晚上都没有安上pygame。
于是第二天在整整一个下午琢磨了两个小时为什么。重启电脑，将python卸载再安装，卸载再安装，卸载再安装。删除easy_install 重装ez。删除pip，重装pip。重装wheel，但是如上面那样也失败了。然后我终于发现问题所在了。
我把powershell当成了是默认的管理员模式，于是我就一直处于安装不成功的地步。
所以说，如果你也安装不上，试试管理员模式运行终端。
真的是气，那些三步安装库的人根本不说。</description>
    </item>
    
    <item>
      <title>python Tkinter 的 Text 保持焦点在行尾</title>
      <link>https://sucicada.github.io/blog/posts/soft/python-tkinter-%E7%9A%84-text-%E4%BF%9D%E6%8C%81%E7%84%A6%E7%82%B9%E5%9C%A8%E8%A1%8C%E5%B0%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/python-tkinter-%E7%9A%84-text-%E4%BF%9D%E6%8C%81%E7%84%A6%E7%82%B9%E5%9C%A8%E8%A1%8C%E5%B0%BE/</guid>
      <description>https://bbs.csdn.net/topics/390712532
text.see(END)</description>
    </item>
    
    <item>
      <title>Python3 urllib 爬取 花瓣网图片</title>
      <link>https://sucicada.github.io/blog/posts/soft/python3-urllib-%E7%88%AC%E5%8F%96-%E8%8A%B1%E7%93%A3%E7%BD%91%E5%9B%BE%E7%89%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/python3-urllib-%E7%88%AC%E5%8F%96-%E8%8A%B1%E7%93%A3%E7%BD%91%E5%9B%BE%E7%89%87/</guid>
      <description>点我去我的github上看源码
**花瓣网是动态的,所以要抓包分析,,但我真的累的不行,不想写教程了,我源码里有注释</description>
    </item>
    
    <item>
      <title>python3 urllib爬取wallhalla网站图片</title>
      <link>https://sucicada.github.io/blog/posts/soft/python3-urllib%E7%88%AC%E5%8F%96wallhalla%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/python3-urllib%E7%88%AC%E5%8F%96wallhalla%E7%BD%91%E7%AB%99%E5%9B%BE%E7%89%87/</guid>
      <description>点我去我的github上看源码
简单使用静态方法爬取https://wallhalla.com/网站的图片
参考:
https://blog.csdn.net/cquptcmj/article/details/53526137
https://www.cnblogs.com/zhouxuchen/p/4341034.html</description>
    </item>
    
    <item>
      <title>python3.5  安装twisted</title>
      <link>https://sucicada.github.io/blog/posts/soft/python3.5-%E5%AE%89%E8%A3%85twisted/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/python3.5-%E5%AE%89%E8%A3%85twisted/</guid>
      <description>https://blog.csdn.net/caimouse/article/details/77647952
下载地址：http://www.lfd.uci.edu/~gohlke/pythonlibs/
下载到文件：Twisted-18.7.0-cp35-cp35m-win_amd64.whl
然后安装：pip install Twisted-18.7.0-cp35-cp35m-win_amd64.whl
如果不行 下载win32版本试试
如果不行
提示Python.h: No such file or directory compilation terminated.
那么就 sudo apt-get install python-dev
然后试试 上面步骤
如果还不行
sudo pip3 install twisted</description>
    </item>
    
    
    <item>
      <title>Spark 2.4.0 cdh6.3.2连接 Hive 2.1.1 cdh6.3.2</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/spark-2.4.0-cdh6.3.2%E8%BF%9E%E6%8E%A5-hive-2.1.1-cdh6.3.2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/spark-2.4.0-cdh6.3.2%E8%BF%9E%E6%8E%A5-hive-2.1.1-cdh6.3.2/</guid>
      <description>以下maven配置能正确读取hive.
不该加的不要加. spark版本用cdh的.
&amp;lt;properties&amp;gt; &amp;lt;maven.compiler.source&amp;gt;8&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;spark.version&amp;gt;2.4.0-cdh6.3.2&amp;lt;/spark.version&amp;gt; &amp;lt;hive.version&amp;gt;2.1.1-cdh6.3.2&amp;lt;/hive.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.spark&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spark-sql_2.11&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spark.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.spark&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spark-core_2.11&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spark.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.spark&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spark-hive_2.11&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${spark.version}&amp;lt;/version&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;artifactId&amp;gt;hive-metastore&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;org.spark-project.hive&amp;lt;/groupId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;artifactId&amp;gt;hive-exec&amp;lt;/artifactId&amp;gt; &amp;lt;groupId&amp;gt;org.spark-project.hive&amp;lt;/groupId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- &amp;lt;dependency&amp;gt;--&amp;gt; &amp;lt;!-- &amp;lt;groupId&amp;gt;org.apache.hive&amp;lt;/groupId&amp;gt;--&amp;gt; &amp;lt;!-- &amp;lt;artifactId&amp;gt;hive-metastore&amp;lt;/artifactId&amp;gt;--&amp;gt; &amp;lt;!-- &amp;lt;version&amp;gt;${hive.version}&amp;lt;/version&amp;gt;--&amp;gt; &amp;lt;!-- &amp;lt;/dependency&amp;gt;--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.hive&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hive-exec&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${hive.version}&amp;lt;/version&amp;gt; &amp;lt;exclusions&amp;gt; &amp;lt;exclusion&amp;gt; &amp;lt;groupId&amp;gt;*&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;*&amp;lt;/artifactId&amp;gt; &amp;lt;/exclusion&amp;gt; &amp;lt;/exclusions&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; </description>
    </item>
    
    <item>
      <title>Spark2 Sql 遇到 Caused by: java.lang.NoSuchFieldError: HIVE_STATS_JDBC_TIMEOUT</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/spark2-sql-%E9%81%87%E5%88%B0-caused-by-java.lang.nosuchfielderror-hive_stats_jdbc_timeout/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/spark2-sql-%E9%81%87%E5%88%B0-caused-by-java.lang.nosuchfielderror-hive_stats_jdbc_timeout/</guid>
      <description>问题版本：
Spark：2.14.0
Hive：2.1.0
原因参见spark hive java.lang.NoSuchFieldError: HIVE_STATS_JDBC_TIMEOUT
解决方案：
使用 cdh版本的包，比如
&amp;lt;spark.version&amp;gt;2.4.0-cdh6.3.2&amp;lt;/spark.version&amp;gt; &amp;lt;hive.version&amp;gt;2.1.1-cdh6.3.2&amp;lt;/hive.version&amp;gt; 如果遇到有关 apache的log4j包缺失，加入
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;log4j-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.8.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 注意版本
相关问题参见I&amp;rsquo;m getting “NoClassDefFoundError: org/apache/logging/log4j/util/ReflectionUtil”
掰掰</description>
    </item>
    
    <item>
      <title>sublime 自定义主题(linux版)</title>
      <link>https://sucicada.github.io/blog/posts/soft/sublime-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98linux%E7%89%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/sublime-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98linux%E7%89%88/</guid>
      <description>先ctrl+`安装packa：
import urllib.request,os; pf = &amp;lsquo;Package Control.sublime-package&amp;rsquo;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &amp;lsquo;wb&amp;rsquo;).write(urllib.request.urlopen( &amp;lsquo;http://sublime.wbond.net/&#39; + pf.replace(&amp;rsquo; &amp;lsquo;,&amp;rsquo;%20&amp;rsquo;)).read())
使用快捷键ctrl+shift+p，输入packet control install package
这个网站上可以自制主题
http://tmtheme-editor.herokuapp.com/#!/editor/local/undefined
之后将文件放到home/peng/.config/sublime-text-3/Packages
从preferences里的theme选项可以换了</description>
    </item>
    
    <item>
      <title>ubuntu 18.04 使用 Docker 安装 kiwenlau版Hadoop</title>
      <link>https://sucicada.github.io/blog/posts/soft/ubuntu-18.04-%E4%BD%BF%E7%94%A8-docker-%E5%AE%89%E8%A3%85-kiwenlau%E7%89%88hadoop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/ubuntu-18.04-%E4%BD%BF%E7%94%A8-docker-%E5%AE%89%E8%A3%85-kiwenlau%E7%89%88hadoop/</guid>
      <description>1. docker 安装 参考
sudo apt-get update sudo dpkg --configure -a sudo apt-get install apt-transport-https ca-certificates curl software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository &amp;#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&amp;#34; sudo apt-get update sudo apt-get install docker-ce 1.5 docker换源（可选） 参考
2. docker验证 docker --version sudo docker run hello-world 3. docker非root使用 参考
sudo usermod -aG docker $USER sudo service docker restart newgrp docker 4. hadoop的docker image 参考：基于Docker搭建Hadoop集群之升级版</description>
    </item>
    
    <item>
      <title>UUA 506 - System Dependencies(系统依赖) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uua-506-system-dependencies%E7%B3%BB%E7%BB%9F%E4%BE%9D%E8%B5%96-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uua-506-system-dependencies%E7%B3%BB%E7%BB%9F%E4%BE%9D%E8%B5%96-by-sucicada/</guid>
      <description>例题6-21 系统依赖（System Dependencies, ACM/ICPC World Finals 1997, UVa506）
软件组件之间可能会有依赖关系，例如，TELNET和FTP都依赖于TCP/IP。你的任务是
模拟安装和卸载软件组件的过程。首先是一些DEPEND指令，说明软件之间的依赖关系（保
证不存在循环依赖），然后是一些INSTALL、REMOVE和LIST指令，如表6-1所示。
表6-1 指令说明
指令 说明 DEPEND item1 item2 [item3 …] item1依赖组件item2, item3, … INSTALL item1 安装item1和它的依赖（已安装过的不用重新安装） REMOVE item1 卸载item1和它的依赖（如果某组件还被其他显式安装的组件所依赖，则不能卸载这个组件） LIST 输出所有已安装组件 在INSTALL指令中提到的组件称为显式安装，这些组件必须用REMOVE指令显式删除。
同样地，被这些显式安装组件所直接或间接依赖的其他组件也不能在REMOVE指令中删除。
每行指令包含不超过80个字符，所有组件名称都是大小写敏感的。指令名称均为大写字母。
Sample Input
DEPEND TELNET TCPIP NETCARD
DEPEND TCPIP NETCARD
DEPEND DNS TCPIP NETCARD
DEPEND BROWSER TCPIP HTML
INSTALL NETCARD
INSTALL TELNET
INSTALL foo
REMOVE NETCARD
INSTALL BROWSER
INSTALL DNS
LIST
REMOVE TELNET
REMOVE NETCARD
REMOVE DNS</description>
    </item>
    
    <item>
      <title>uva 10082 WERTYU（错位键）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-10082-wertyu%E9%94%99%E4%BD%8D%E9%94%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-10082-wertyu%E9%94%99%E4%BD%8D%E9%94%AE/</guid>
      <description>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=829&amp;amp;problem=1023&amp;amp;mosmsg=Submission+received+with+ID+20388214
A common typing error is to place the
hands on the keyboard one row to the
right of the correct position. So ‘Q’ is
typed as ‘W’ and ‘J’ is typed as ‘K’ and
so on. You are to decode a message typed in this manner.
Input
Input consists of several lines of text. Each line may contain digits, spaces, upper case letters (except
Q, A, Z), or punctuation shown above [except back-quote (‘)].</description>
    </item>
    
    <item>
      <title>UVA 10129 - Play on Words (单词) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-10129-play-on-words-%E5%8D%95%E8%AF%8D-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-10129-play-on-words-%E5%8D%95%E8%AF%8D-by-sucicada/</guid>
      <description>例题6-16 单词（Play On Words, UVa 10129）
输入n（n≤100000）个单词，是否可以把所有这些单词排成一个序列，使得每个单词的
第一个字母和上一个单词的最后一个字母相同（例如acm、malform、mouse）。每个单词最多包含1000个小写字母。输入中可以有重复单词。
Sample Input
3
2
acm
ibm
3
acm
malform
mouse
2
ok
ok
Sample Output
The door cannot be opened.
Ordering is possible.
The door cannot be opened.
本家链接
将一个单词看做是首字母到尾字母的一条路，所以这条路我们只关心头尾，即首尾两个字母，不关心中间字母。
所以我们可以构造一个图，26*26的图，有向的。其中的边即是一个单词。由此我们便无需关心重复以及首尾字母相同的具体单词了，只关心具有同样首尾的单词的数量。
所以这道题就成为了：构造了一个图，是否存在欧拉回路。
存在欧拉回路条件：
图连通 除了起点和终点，其余每个点的出入度都必须一样。 起点和终点的出入度之差为0或各为1。 用dfs判断连通，用数组记录各个点的出入度。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;cstring&amp;gt; using namespace std; /* x --&amp;gt; y */ int dict[33][33]; int inDegree[33]; int outDegree[33]; int N; int SUM = 26; int dfs(int w){ /* start at w */ int road = 0; for(int i=0;i&amp;lt;SUM;i++){ /* 找到了对应的尾字母，即存在一个单词，一条路 */ if(dict[w][i]==1){ dict[w][i] = 2; /* 走过了 */ road = 1; /* 路标记 */ dfs(i); /* 找下一个 */ } return road; } int main(){ int T; cin&amp;gt;&amp;gt;T; while(T--){ cin&amp;gt;&amp;gt;N; int n=N; memset(dict,0,sizeof(dict)); memset(inDegree,0,sizeof(inDegree)); memset(outDegree,0,sizeof(outDegree)); string s; while(n--){ cin&amp;gt;&amp;gt;s; int x = s[0]-&amp;#39;a&amp;#39;; int y = s[s.</description>
    </item>
    
    <item>
      <title>UVA 1030  Delta-wave</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1030-delta-wave/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1030-delta-wave/</guid>
      <description>两格子之间的距离
http://acm.hdu.edu.cn/showproblem.php?pid=1030
走一步判断一下 下一步走哪里
是走下面呢（前提要能走）
还是走左边
还是走右边
设定一个格子，代表当前走到的地方
如果能直接向下走，就向下走
不能的话：
如果终点在当前格子的哪一边（只看左右方向，不看上下），就走哪一边
#include&amp;lt;iostream&amp;gt; #include&amp;lt;cmath&amp;gt; using namespace std; // 同一行 相邻的能通过 // 上下行 上行的第奇数个能和下行中第偶数个过 //1 3 5 7 //1 2*1-1 2*n-1 //(1+ 2*n-1)*n/2 = int(a) //第 sqrt(a) +1 行 //第 a - sqrt(a)^2 个 // 向左走，向右走？ int which(int a){ int n = sqrt(a-1); int ge = a-n*n; n ++; return n; } int getmid(int a){ int n = which(a); return pow(n-1,2) + n; } int main(){ int a,b; while(cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b){ if(a&amp;gt;b) a^=b^=a^=b; int go = a; int b_n = which(b);// 行 int b_mid = getmid(b); int go_mid; int go_n; int sum = 0; while(go !</description>
    </item>
    
    <item>
      <title>UVA 10305 - Ordering Tasks (给任务排序) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-10305-ordering-tasks-%E7%BB%99%E4%BB%BB%E5%8A%A1%E6%8E%92%E5%BA%8F-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-10305-ordering-tasks-%E7%BB%99%E4%BB%BB%E5%8A%A1%E6%8E%92%E5%BA%8F-by-sucicada/</guid>
      <description>例题6-15 给任务排序（Ordering Tasks, UVa 10305）
假设有n个变量，还有m个二元组(u, v)，分别表示变量u小于v。那么，所有变量从小到
大排列起来应该是什么样子的呢？例如，有4个变量a, b, c, d，若已知a &amp;lt; b，c &amp;lt; b，d &amp;lt; c，则
这4个变量的排序可能是a &amp;lt; d &amp;lt; c &amp;lt; b。尽管还有其他可能（如d &amp;lt; a &amp;lt; c &amp;lt; b），你只需找出其
中一个即可。
Sample Input
5 4
1 2
2 3
1 3
1 5
0 0
Sample Output
1 4 2 5 3
本家连接
dfs(n) 从n开始找上级
循环找上级
如果没有上级，break
如果有上级，
if 上级 is execute: continue
else if 上级 not execute. then dfs(上级),</description>
    </item>
    
    <item>
      <title>uva 10340 - All in All（子序列）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-10340-all-in-all%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-10340-all-in-all%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>习题3-9 子序列（All in All, UVa 10340）
输入两个字符串s和t，判断是否可以从t中删除0个或多个字符（其他字符顺序不变），
得到字符串s。例如，abcde可以得到bce，但无法得到dc。
Sample Input
sequence subsequence
person compression
VERDI vivaVittorioEmanueleReDiItalia
caseDoesMatter CaseDoesMatter
Sample Output
Yes
No
Yes
No
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=830&amp;amp;problem=1281&amp;amp;mosmsg=Submission+received+with+ID+20551262
循环大的 从第一位小的开始 判断是否匹配，若是小的下标+1，若非大的+1，继续循环。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; using namespace std; int main() { string s,a; while(cin&amp;gt;&amp;gt;s&amp;gt;&amp;gt;a) { int sn=0; for(int i=0;i&amp;lt;a.size()&amp;amp;&amp;amp;sn&amp;lt;s.size();i++) { if(a[i]==s[sn]) { sn++; //cout&amp;lt;&amp;lt;sn&amp;lt;&amp;lt;&amp;#34;!!&amp;#34;&amp;lt;&amp;lt;endl; } } if(sn==s.size()) cout&amp;lt;&amp;lt;&amp;#34;Yes&amp;#34;&amp;lt;&amp;lt;endl; else cout&amp;lt;&amp;lt;&amp;#34;No&amp;#34;&amp;lt;&amp;lt;endl; } return 0; } //AC at 2017/12/30 （没想到居然一下就过了，总共十分钟？这还是在同一天的）</description>
    </item>
    
    <item>
      <title>UVA 10562 - Undraw the Trees(看图写树) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-10562-undraw-the-trees%E7%9C%8B%E5%9B%BE%E5%86%99%E6%A0%91-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-10562-undraw-the-trees%E7%9C%8B%E5%9B%BE%E5%86%99%E6%A0%91-by-sucicada/</guid>
      <description>例题6-17 看图写树（Undraw the Trees, UVa 10562）
你的任务是将多叉树转化为括号表示法。如图6-16所示，每个结点用除了“-”、“|”和空格
的其他字符表示，每个非叶结点的正下方总会有一个“|”字符，然后下方是一排“-”字符，恰
好覆盖所有子结点的上方。单独的一行“#”为数据结束标记。
Sample Input
2 A | -------- B C D | | ----- - E F G # e | ---- f g # Sample Output
(A(B()C(E()F())D(G())))
(e(f()g()))
本家地址
先记录树，然后从头开始递归遍历树，并且构造先序遍历字串。
非叶子结点字母下方必有竖线。竖线下方必有若干横线，横线下方必有若干字母，即子节点。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;cstring&amp;gt; using namespace std; char tree[222][222]; int isRightChar(char c){ return c &amp;amp;&amp;amp; c!=&amp;#39;-&amp;#39; &amp;amp;&amp;amp; c!=&amp;#39;|&amp;#39; &amp;amp;&amp;amp; c!=&amp;#39; &amp;#39; &amp;amp;&amp;amp; c!=&amp;#39;#&amp;#39;; } int loop(int x,int y){ cout&amp;lt;&amp;lt;tree[x][y]; cout&amp;lt;&amp;lt;&amp;#34;(&amp;#34;; if(tree[x+1][y]!</description>
    </item>
    
    <item>
      <title>uva 11809 - Floating-Point Numbers（浮点数）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-11809-floating-point-numbers%E6%B5%AE%E7%82%B9%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-11809-floating-point-numbers%E6%B5%AE%E7%82%B9%E6%95%B0/</guid>
      <description>习题3-12 浮点数（Floating-Point Numbers, UVa11809）
计算机常用阶码-尾数的方法保存浮点数。如图3-9所示，如果阶码有6位，尾数有8位，可以表达的最大浮点数为0.1111111112×2
1111112。注意小数点后第一位必须为1，所以一共有9位小数。
图3-9 阶码-尾数保存浮点数
这个数换算成十进制之后就是0.9980468752^63=9.20535763834529410^18。你的任务是根据这个最大浮点数，求出阶码的位数E和尾数的位数M。输入格式为AeB，表示最大浮点数为A*10B。0&amp;lt; A&amp;lt;10，并且恰好包含15位有效数字。输 入结束标志为0e0。对于每组数据，输
出M和E。输入保证有唯一解，且0≤M≤9，1≤E≤30。在本题中，M+E+2不必为8的整数倍。
Sample Input
5.699141892149156e76
9.205357638345294e18
0e0
Sample Output
5 8
8 6
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=830&amp;amp;problem=2909&amp;amp;mosmsg=Submission+received+with+ID+20702100
我们只要算：m*2^(2^n-1)=f *10^t (m是浮点数位，n是阶码位数，求f和t；) 而f=10^log10(f)：即左边=10^t1=10^(t+log10(f)); t1=log10(m*2^(2^n-1))=log10(m)+(2^n-1) *log10(2) t=(int)t1; f=10^(t1-t);
感谢参考来自http://blog.csdn.net/crazysillynerd/article/details/43339157 #include&amp;lt;iostream&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;cmath&amp;gt; using namespace std; double flo[10][30]; int expstr[10][30]; int main() { int twoe; double twom; double temp; for(int i=0;i&amp;lt;10;i++) { twom=1-pow(2,-i-1); for(int j=0;j&amp;lt;30;j++) { twoe = pow(2,j+1)-1; temp = log10(twom)+twoe*log10(2); expstr[i][j]=temp; flo[i][j]=pow(10,(temp-expstr[i][j])); } } while(1) { double flo1; int exp1; char str[25]={0};//存输入的浮点数字符串 int iff=0; //输入浮点数 char c; for(int i=0;(c=getchar())!</description>
    </item>
    
    <item>
      <title>UVA 11853 - Paintbal(战场) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-11853-paintbal%E6%88%98%E5%9C%BA-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-11853-paintbal%E6%88%98%E5%9C%BA-by-sucicada/</guid>
      <description>例题6-22 战场（Paintball, UVa 11853）
有一个1000×1000的正方形战场，战场西南角的坐标为(0,0)，西北角的坐标为(0,1000)。
战场上有n（0≤n≤1000）个敌人，第i个敌人的坐标为(xi
,yi
)，攻击范围为ri。为了避开敌人的
攻击，在任意时刻，你与每个敌人的距离都必须严格大于它的攻击范围。你的任务是从战场
的西边（x=0的某个点）进入，东边（x=1000的某个点）离开。如果有多个位置可以进/出，
你应当求出最靠北的位置。输入每个敌人的xi、yi、ri，输出进入战场和离开战场的坐标。
Sample Input
3
500 500 499
0 0 999
1000 1000 200
Sample Output
0.00 1000.00 1000.00 800.00
本家地址
关键在于抓住问题的本质，即问题的核心，即问题去除了表面保护层之下的那个最纯粹的那个命脉。
初看，我们发现，这是要在坐标图上画圆啊。过分可怕。
但是我们鼓起勇气再细看问题：
求最靠上的进入战场和离开战场的坐标。
解剖一下：
能否离开 若能，最上 最左边进，最后边出。 然后我们随便画几个图来看看。
怎么样就不能离开：
当有一条敌人从最上一直连通到最下。
若能，最靠上的地方是哪里：
如果我们最左边进入的地方的下方有一条敌线一直连通到最上边。
那么这条敌线就把我们包住了。
所以 敌线（从上方延伸 and 延伸到左边），就不能被我们在其上方进入。
所以我们只要求敌线的连通性和敌线范围（从上方开始的）在最左边和最右边的最下方坐标即可。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;cstdio&amp;gt; using namespace std; /* 关键在于抓住问题的本质，即问题的核心，即问题去除了表面保护层之下的那个最纯粹的那个命脉。 初看，我们发现，这是要在坐标图上画圆啊。过分可怕。 但是我们鼓起勇气再细看问题： 求最靠上的进入战场和离开战场的坐标。 解剖一下： 1. 能否离开 2. 若能，最上 3.</description>
    </item>
    
    <item>
      <title>uva 12096 - The SetStack Computer（集合栈）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-12096-the-setstack-computer%E9%9B%86%E5%90%88%E6%A0%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-12096-the-setstack-computer%E9%9B%86%E5%90%88%E6%A0%88/</guid>
      <description>例题5-5
集合栈计算机(The
Set
Stack
Computer,ACM/ICPC
NWERC
2006,UVa12096)
有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈,并且
支持以下操作。
PUSH:空集“{}”入栈。
DUP:把当前栈顶元素复制一份后再入栈。
UNION:出栈两个集合,然后把二者的并集入栈。
INTERSECT:出栈两个集合,然后把二者的交集入栈。ADD:出栈两个集合,然后把先出栈的集合加入到后出栈的集合中,把结果入栈。
每次操作后,输出栈顶集合的大小(即元素个数)。例如,栈顶元素是A={{},
{{}}},下一个元素是B={{},{{{}}}},则:
UNION操作将得到{{},{{}},{{{}}}},输出3。
INTERSECT操作将得到{{}},输出1。
ADD操作将得到{{},{{{}}},{{},{{}}}},输出3。
输入不超过2000个操作,并且保证操作均能顺利进行(不需要对空栈执行出栈操作)。
Sample Input
2
9
PUSH
DUP
ADD
PUSH
ADD
DUP
ADD
DUP
UNION
5
PUSH
PUSH
ADD
PUSH
INTERSECT
Sample Output
0
0
1
0
1
1
2
2
2
***
0
0
1
0
0
***
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=835&amp;amp;problem=3248&amp;amp;mosmsg=Submission+received+with+ID+21273791
性质：
１、set&amp;lt; int &amp;gt;　代表是集合
２、idcache 是集合与其编号的映射，每一个集合都有唯一的编号。
３、setcache是向量，即下标与其存的是集合的元素相映射。
４、每一个集合都只在以上容器中存在一个。
５、栈里存的只是集合的编号。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; map&amp;lt; set&amp;lt;int&amp;gt; ,int&amp;gt; idcache; //每一个集合对应一个编号 vector&amp;lt; set&amp;lt;int&amp;gt; &amp;gt; setcache; //每一个编号对应一个集合 int getid(set&amp;lt;int&amp;gt; s) { if(idcache.</description>
    </item>
    
    <item>
      <title>UVA 12171 - Sculpture(雕塑) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-12171-sculpture%E9%9B%95%E5%A1%91-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-12171-sculpture%E9%9B%95%E5%A1%91-by-sucicada/</guid>
      <description>例题6-18 雕塑（Sculpture, ACM/ICPC NWERC 2008, UVa12171）
某雕塑由n（n≤50）个边平行于坐标轴的长方体组成。每个长方体用6个整
数x0，y0，z0，x，y，z表示（均为1～500的整数），其中x0为长方体的顶点中x坐标的最小
值，x表示长方体在x方向的总长度。其他4个值类似定义。你的任务是统计这个雕像的体积
和表面积。注意，雕塑内部可能会有密闭的空间，其体积应计算在总体积中，但从“外部”看
不见的面不应计入表面积。雕塑可能会由多个连通块组成。
Sample Input
2
2
1 2 3 3 4 5
6 2 3 3 4 5
7
1 1 1 5 5 1
1 1 10 5 5 1
1 1 2 1 4 8
2 1 2 4 1 8
5 2 2 1 4 8
1 5 2 4 1 8
3 3 4 1 1 1</description>
    </item>
    
    <item>
      <title>UVA 122 - Trees on the level, Duke 1993 (树的层次遍历)</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-122-trees-on-the-level-duke-1993-%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-122-trees-on-the-level-duke-1993-%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</guid>
      <description>例题6-7 树的层次遍历（Trees on the level, Duke 1993, UVa 122）
输入一棵二叉树，你的任务是按从上到下、从左到右的顺序输出各个结点的值。每个结
点都按照从根结点到它的移动序列给出（L表示左，R表示右）。在输入中，每个结点的左
括号和右括号之间没有空格，相邻结点之间用一个空格隔开。每棵树的输入用一对空括
号“()”结束（这对括号本身不代表一个结点），如图6-3所示。
图6-3 一棵二叉树
注意，如果从根到某个叶结点的路径上有的结点没有在输入中给出，或者给出超过一
次，应当输出-1。结点个数不超过256。
样例输入：
(11,LL) (7,LLL) (8,R)
(5,) (4,L) (13,RL) (2,LLR) (1,RRR) (4,RR) ()
(3,L) (4,R) ()
样例输出：
5 4 8 11 13 4 7 2 1
not complete
本家地址
祭出对象大法
#include&amp;lt;iostream&amp;gt; #include&amp;lt;sstream&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;cstdlib&amp;gt; using namespace std; class Node{ public: int value; Node* left; Node* right; }; Node* queue[256]; void show(Node* root){ memset(queue,0,sizeof(queue)); int qbegin=0; int qend=0; int qlen = sizeof(queue)/sizeof(Node*); stringstream out; queue[qend] = root; qend = (qend+1) % qlen; while(qbegin!</description>
    </item>
    
    <item>
      <title>uva 1225 - Digit Counting（数数）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1225-digit-counting%E6%95%B0%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1225-digit-counting%E6%95%B0%E6%95%B0/</guid>
      <description> 把前n（n≤10000）个整数顺次写在一起：123456789101112…数一数0～9各出现多少次
（输出10个整数，分别是0，1，…，9出现的次数）。
Sample Input
2
3
13
Sample Output
0 1 1 1 0 0 0 0 0 0
1 6 2 2 1 1 1 1 1 1
（注：输出的最后一个数后面没有空格）
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=830&amp;amp;problem=3666&amp;amp;mosmsg=Submission+received+with+ID+20469369
//判断一个数各个位的数字，存于一个数组中，倒的来循环也无妨 #include&amp;lt;iostream&amp;gt; #include&amp;lt;cstdio&amp;gt; using namespace std; int main() { int T; cin&amp;gt;&amp;gt;T; getchar(); while(T--) { int num[10]={0}; int N; cin&amp;gt;&amp;gt;N; getchar(); while(N--) { int ni=N+1; while(ni) { num[ni%10]++; ni/=10; } } for(int i=0;i&amp;lt;9;i++) cout&amp;lt;&amp;lt;num[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; cout&amp;lt;&amp;lt;num[9]&amp;lt;&amp;lt;endl; } return 0; } //AC at 2017/12/10 </description>
    </item>
    
    <item>
      <title>UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) 【后日谈】by SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-12333-revenge-of-fibonacci-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%9A%84%E5%A4%8D%E4%BB%87-%E5%90%8E%E6%97%A5%E8%B0%88by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-12333-revenge-of-fibonacci-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%9A%84%E5%A4%8D%E4%BB%87-%E5%90%8E%E6%97%A5%E8%B0%88by-sucicada/</guid>
      <description>正篇以及正确解题思路和代码参见 UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) by SuCicada 此篇为后日谈 要说为什么专门开一篇来记录想法呢，主要是因为想说的太多了。首先从UVA的提交记录上来看，上一次答题是在足足1年之前了。
这么久以来都没有再好好做算法，感觉快要忘本了。而且出来之后脑子也不是那么灵光了，虽然更理性，但是却少了些抽象的想象力。
再说这道题，一开始我根本不知道什么字典序，完全是打表暴力比对的。把前40位算出来那里都是没错的。
但是之后我想的是：用map排个序，然后二分查找。但是这样会有问题，因为二分找到的可能并不是最小的，所以找到之后还需要分别找到同样匹配前缀的那一区域的数字，因为是map排过序的，所以他们都是挨着的。
但是之后在极端痛苦了两个晚上之后，我放弃了这种做法，经过测试计算，发现我电脑中g++在一秒钟可以进行4亿次运算，假设有5万个40位数字需要比对，4亿除以5万除以40 有20万呢，或者保险点我们取个1000。（一直到当时我都以为这道题的时间限制是1秒）
然后我就在死灰复燃的状态下在下2天晚上把位数比对写出了（暴力）。为了减少比对量，我打表了前3位，也就是记录下前三位的数字第一次出现的序数，而且这个序数是map中的序数，map中的序数和fibo的序数可是不同的。
而且map不能随机读取，怎么办，我又创造了两个数组专门存放键和值。
后来我还发现个位数的搜索起来比较慢，因为他们要暴力比对的数是最多的，所以我又用一个map来记录已经查找过的结果。
我真的是要疯，一直到昨天晚上我把这套模型整通。本地一跑，通过，time测下来 1.2秒，我巨喜。提交，time limit exceeded。把udebug上的样例全部跑了一遍，没有超过1.5秒的。我随机生成各种5万个数的组合，2秒之内绝对能过。
但是 time limit exceeded， time limit exceeded，time limit exceeded，time limit exceeded，time limit exceeded。
”难道是表打的太小了？“我又将打表位数升到4，升到5。然而为什么更慢了。
那会已经3点钟了，我感到生命力的衰减，在极度无望的情况下，我打开百度，UVA 12333，我真特么被这道题23333了，
这道题考大数+字典树
我惊住，一个新的窗子仿佛打开了，一查，全懂了，完全懂了。我缩在床上颤抖不已，脑子瞬间就明白了我该怎么做，但是身体已经无法支撑下去，为了能保持住自己的生命力。我艰难的进入睡眠。
第二天我写，真的很快，因为我已经知道了，虽然遇到了oj离奇而严厉的 runtime error错误。但是我很冷静，因为我知道这个方法肯定是没错的，这条路一定是对的。就是这种知道目的的坚定。
当Accepted出现在屏幕上，我想哭了。太痛苦了，太刺激了，太疯狂了。再加上17个小时没有进食带来的虚弱感让我恍惚，感觉我活下来了。
劫后余生的感激之情。
而现在已经5点怅然若失感时不时在席卷我，跨时两个星期，4个夜晚的崩溃，20余小时的挣扎，20多次的错误。我太弱了，我为我的弱小感到伤心，但是我又为我的成功感到高兴。
算法拯救我，算法伤害我，算法摧残我，算法安慰我。
我时尝为我的自艾感到痛苦。
但是我害怕痛苦吗，不如说我正喜欢痛苦。
附赠更快的却更错的代码：
#include&amp;lt;iostream&amp;gt; #include&amp;lt;algorithm&amp;gt; #include&amp;lt;iterator&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;iomanip&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; using namespace std; vector&amp;lt;string&amp;gt; fibonacci(100005); map&amp;lt;string,int&amp;gt; fiboSorted; vector&amp;lt;string&amp;gt; fiboName(100005); vector&amp;lt;int&amp;gt; fiboIndex(100005); int limitSite = 52; string add(string a,string b){ int aLen = a.</description>
    </item>
    
    <item>
      <title>UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) by SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-12333-revenge-of-fibonacci-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%9A%84%E5%A4%8D%E4%BB%87-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-12333-revenge-of-fibonacci-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%9A%84%E5%A4%8D%E4%BB%87-by-sucicada/</guid>
      <description>合适的思路 大数加法 字典树 代码 注意点 附录 后日谈 习题5-15 Fibonacci的复仇（Revenge of Fibonacci, ACM/ICPC Shanghai 2011,
UVa12333）
Fibonacci数的定义为：F(0)=F(1)=1，然后从F(2)开始，F(i)=F(i-1)+F(i-2)。例如，前10
项Fibonacci数分别为1, 1, 2, 3, 5, 8, 13, 21, 34, 55……
有一天晚上，你梦到了Fibonacci，它告诉你一个有趣的Fibonacci数。醒来以后，你只记
得了它的开头几个数字。你的任务是找出以它开头的最小Fibonacci数的序号。例如以12开头
的最小Fibonacci数是F(25)。输入不超过40个数字，输出满足条件的序号。
如果序号小于100000的Fibonacci数均不满足条件，输出-1。
提示：本题有一定效率要求。如果高精度代码比较慢，可能会超时。
原题链接 合适的思路 首先想我们该怎么样能匹配前缀，首先我们不知道完整的数字是什么，所以我们要先得到符合要求的数字数据集。
然后将这些数据集放入字典树中
所以我们要做的就是
使用大数加法技巧，计算前100000个fibonacci 将每一个fibo数存入字典树中 大数加法 首先先做大数加法，使用字符串存储数字，两个字符串（数字）从最后一位即个位开始一位一位加。
问题在于：
100000个fibo数字，到后期位数是相当恐怖的，测试时发现第10万个数字有足足2万多位。这会造成在运算时时间和空间的非常糟糕的消耗。
所以我们就可以遵从题意，只关心前40位，我们只截取每个数字的前面一部分做计算。这就要引出第2个和第3个问题。 如果我们使用40位，不论后面多少位，就把第40位当作个位。这会产生一个误差的问题。 比如两个数字 11001 和88999，如果我们只取他们的前2位算出来下一个数的前2位是99，但是实际上下一个数的前2位是10。这就是误差。 在解决第1个问题的时候，我们需要考虑数字进位的情况，因为我们只能看到数字的前一部分，不知道两个相加的数字是否位数相等，比如1234和345相加，假设取前2位，那么我们只能看到12和34，这样直接相加是不对的。 解决
问题:3：先解决位数问题，我们可以将位数记录在字符串中，比如加入一个最后一位专门用来放位数。但是这样我们只能放256个无符号数字（因为使用char型元素存储）。那么换个思路，因为我们的问题在于两个数字位数不等，而不是位数究竟多少，所以可以只记录位数的奇偶即可。
（另：其他办法，因为是Fibo数，位数不等的情况下，后一个数是大的数字，位数肯定多，而且第一位肯定是1，可以用这些关键点来解决） 问题:2：为了解决误差问题，我们就不能只选取前40位，那么应该选几位呢，经过测试发现最小能保证前40位没有问题的位数是52，测试方法见附录。
不过要是不能测试的时候可以以10位为单位扩大范围，反正50和60位的差距远比50和2万的差距小。 字典树 每一个结点中存有
从根节点到此结点的最小的Fibo序数，即最小前缀数字。 一个map，存有下一位的数字到下一位所在的结点的位置映射关系。 结点之间的关系如下图
在存储的时候，存入的字符串在经过每一个结点的时候，都要比一下这个结点中存储的minIndex（FIbo最小前缀序号），并将其替换成两者中更小的。
这样就能保证按照字典树的脉络寻找，寻找到的结点中的序号，一定是前缀数所在的最小的Fibo序号。
注意点 不知道现在的UVA 编译器是怎么回事，我定义的 int型返回值函数没有给返回值，返回判我 Runtime error。我一开始压根不明觉厉，一行一行注释，然后一次次提交看看哪部分代码没有才会不报 re，以此来判断问题出在哪部分。光是这样就提交了十几次。
我愿称之为绝活。
在 线 O J ，现 场 调 试。</description>
    </item>
    
    <item>
      <title>uva 133 - The Dole Queue（救济金点人）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-133-the-dole-queue%E6%95%91%E6%B5%8E%E9%87%91%E7%82%B9%E4%BA%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-133-the-dole-queue%E6%95%91%E6%B5%8E%E9%87%91%E7%82%B9%E4%BA%BA/</guid>
      <description>例题4-3 救济金发放（The Dole Queue, UVa 133）
n(n&amp;lt;20)个人站成一圈，逆时针编号为1～n。有两个官员，A从1开始逆时针数，B从n开
始顺时针数。在每一轮中，官员A数k个就停下来，官员B数m个就停下来（注意有可能两个
官员停在同一个人上）。接下来被官员选中的人（1个或者2个）离开队伍。
输入n，k，m输出每轮里被选中的人的编号（如果有两个人，先输出被A选中的）。例
如，n=10，k=4，m=3，输出为4 8, 9 5, 3 1, 2 6, 10, 7。注意：输出的每个数应当恰好占3格。（即setw(3)）
Sample Input
10 4 3
0 0 0
Sample Output
␣␣4␣␣8,␣␣9␣␣5,␣␣3␣␣1,␣␣2␣␣6,␣10,␣␣7
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=832&amp;amp;page=show_problem&amp;amp;problem=69
有一个数组来表示队列里的人，然后分别用两个循环，从头和尾开始依次过，并且记录下每一轮最后的落脚点，在下一轮中就当做是起始点了。点出来的人的位置可以直接用0代替。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; using namespace std; int dole[25]; int n,a,b; int cycle(int j)//int n,int ab) { //int j=0; for(int i=0;i&amp;lt;a;i++) { do { j++; if(j==n) j=0; continue; } while(dole[j]==0); //j++; } return j; } int cycle2(int j)//int n,int b) { //int j=n-1; for(int i=0;i&amp;lt;b;i++) { do { j--; if(j&amp;lt;0) j=n-1; continue; } while(dole[j]==0); } //cout&amp;lt;&amp;lt;&amp;#34;j &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl; return j; } int main() { while(cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;amp;&amp;amp;(n!</description>
    </item>
    
    <item>
      <title>uva 1339 - Ancient Cipher（映射密码）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1339-ancient-cipher%E6%98%A0%E5%B0%84%E5%AF%86%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1339-ancient-cipher%E6%98%A0%E5%B0%84%E5%AF%86%E7%A0%81/</guid>
      <description>例题4-1 古老的密码（Ancient Cipher, NEERC 2004, UVa1339）
给定两个长度相同且不超过100的字符串，判断是否能把其中一个字符串的各个字母重
排，然后对26个字母做一个一一映射，使得两个字符串相同。例如，JWPUDJSTVP重排后可
以得到WJDUPSJPVT，然后把每个字母映射到它前一个字母（B-&amp;gt;A, C-&amp;gt;B, …, Z-&amp;gt;Y, A-
Z），得到VICTORIOUS。输入两个字符串，输出YES或者NO。
Sample Input
JWPUDJSTVP
VICTORIOUS
MAMA
ROME
HAHA
HEHE
AAA
AAA
NEERCISTHEBEST
SECRETMESSAGES
Sample Output
YES
NO
YES
YES
NO
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=832&amp;amp;problem=4085&amp;amp;mosmsg=Submission+received+with+ID+20728592
//1、我们只需要分别记录两个字串里出现的各个字母的数量， //2、然后从小到大或从大到小排序， //3、之后进行比较，如果两个字串对应，那么他们的字母数量表相同下标的元素值（代表字母的数量）也应该相同。 #include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; using namespace std; void ssqrt(int *str) { //cout&amp;lt;&amp;lt;str&amp;lt;&amp;lt;endl; for(int i=0;i&amp;lt;26;i++) for(int j=i+1;j&amp;lt;26;j++) if(str[i]&amp;gt;str[j]) { int temp=str[i]; str[i]=str[j]; str[j]=temp; } //cout&amp;lt;&amp;lt;str&amp;lt;&amp;lt;endl; } int main() { string str,guess;//输入的两个字串 while(cin&amp;gt;&amp;gt;str&amp;gt;&amp;gt;guess) { int cha1[26]={0},cha2[26]={0};//分别记录两个字串里的各个字母的数量 for(int i=0;i&amp;lt;str.</description>
    </item>
    
    <item>
      <title>uva 1368 - DNA Consensus String（DNA汉明距离）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1368-dna-consensus-stringdna%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1368-dna-consensus-stringdna%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</guid>
      <description>习题3-7 DNA序列（DNA Consensus String, ACM/ICPC Seoul 2006, UVa1368）
输入m个长度均为n的DNA序列，求一个DNA序列，到所有序列的总Hamming距离尽量
小。两个等长字符串的Hamming距离等于字符不同的位置个数，例如，ACGT和GCGA的
Hamming距离为2（左数第1, 4个字符不同）。
输入整数m和n（4≤m≤50, 4≤n≤1000），以及m个长度为n的DNA序列（只包含字母
A，C，G，T），输出到m个序列的Hamming距离和最小的DNA序列和对应的距离。如有多
解，要求为字典序最小的解。例如，对于下面5个DNA序列，最优解为TAAGATAC。
TATGATAC
TAAGCTAC
AAAGATCC
TGAGATAC
TAAGATGT
（汉明距离：算出 每列与 此列最多量的字符 不同的字符的个数 ，各个列相加）
Sample Input
3
5 8
TATGATAC
TAAGCTAC
AAAGATCC
TGAGATAC
TAAGATGT
4 10
ACGTACGTAC
CCGTACGTAG
GCGTACGTAT
TCGTACGTAA
6 10
ATGTTACCAT
AAGTTACGAT
AACAAAGCAA
AAGTTACCTT
AAGTTACCAA
TACTTACCAA
Sample Output
TAAGATAC
7
ACGTACGTAA
6
AAGTTACCAA
12
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=830&amp;amp;problem=4114&amp;amp;mosmsg=Submission+received+with+ID+20524214
//能解出来就是好的，有时候略微繁琐一些是在所难免的。 //It&amp;#39;s not necessary to tack such a toxic attitude around that it&amp;#39;s slightly difficult.</description>
    </item>
    
    <item>
      <title>UVA 156 - Ananagrams (反片语)</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-156-ananagrams-%E5%8F%8D%E7%89%87%E8%AF%AD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-156-ananagrams-%E5%8F%8D%E7%89%87%E8%AF%AD/</guid>
      <description>例题5-4 反片语（Ananagrams，Uva 156）
输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文
本中的另外一个单词。 在判断是否满足条件时，字母不分大小写，但在输出时应保留输入中
的大小写，按字典序进行排列（所有大写字母在所有小写字母的前面）。
Sample Input
ladder came tape soon leader acme RIDE lone Dreis peat
ScAlE orb eye Rides dealer NotE derail LaCeS drIed
noel dire Disk mace Rob dries
#
Sample Output
Disk
NotE
derail
drIed
eye
ladder
soon
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=835&amp;amp;problem=92&amp;amp;mosmsg=Submission+received+with+ID+22713249
思路和书上的一样, 先把每次的单词变成小写, 然后将其存入map的键, 值就是原单词.
如果是重复的单词, 那么就把值变成空的.
最后判断 map 里每一个迭代对象的值是不是空就行了
将不是空的结果存入一个set, set自动排序, 然后再将set遍历输出即可
#include&amp;lt;iostream&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;set&amp;gt; #include&amp;lt;algorithm&amp;gt; using namespace std; string lower(string s){ string re; for(int i=0;i&amp;lt;s.</description>
    </item>
    
    <item>
      <title>UVA 1572 - Self-Assembly(自组合) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1572-self-assembly%E8%87%AA%E7%BB%84%E5%90%88-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1572-self-assembly%E8%87%AA%E7%BB%84%E5%90%88-by-sucicada/</guid>
      <description>例题6-19 自组合（Self-Assembly, ACM/ICPC World Finals 2013, UVa 1572）
有n（n≤40000）种边上带标号的正方形。每条边上的标号要么为一个大写字母后面跟着一个加号或减号，要么为数字00。当且仅当两条边的字母相同且符号相反时，两条边能拼在一起（00不能和任何边拼在一起，包括另一条标号为00的边）。
假设输入的每种正方形都有无穷多种，而且可以旋转和翻转，你的任务是判断能否组成一个无限大的结构。每条边要么悬空（不和任何边相邻），要么和一个上述可拼接的边相邻。如图6-17（a）所示是3个正方形，图6-17（b）所示边是它们组成的一个合法结构（但大小有限）。
Sample Input
3
A+00A+A+ 00B+D+A- B-C+00C+
1
K+K-Q+Q
Sample Output
bounded
unbounded
本家地址
提炼一下关键点：一共53种符号。方块数目很大，构造传统二维图会过大而超时。方块内部符号已知连通性。求方块间符号连通性。
可以抽象为52个点（00去掉），已知连通性（方块内部，不互补符号），互补符号可连通，当一段方块能够重复连接，即能够无限，即在可能的通路中求是否存在环路。
所以解决方案：使用dfs的方式，从一个符号开始，然后循环找方块内部的道路，找到之后，再递归走向下一个与其互补的符号。然后记录每一次递归通过的符号，即结点，当某一次递归走到了已经走过的符号结点上，那么就存在重复道路，即环路了。
具体看注释
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;cstring&amp;gt; using namespace std; /* x -&amp;gt; y : inner */ /* y -&amp;gt; x : outer( + -) */ // /* A+B+C+D+...A-B-C-D- */ /* A+A-B+B-C+C-D+D-... */ int table[55][55]; /* 1: can go 2: has gone 用于减少计算数 */ int look[55]; /* 作为标记，锁一类。作为当前一次dfs中,这个点是否已经走过了 用于判断环路存在 */ int run[55]; int getIndex(char a,char b){ return (a-&amp;#39;A&amp;#39;)*2 + (b==&amp;#39;-&amp;#39;?</description>
    </item>
    
    <item>
      <title>uva 1584 - Circular Sequence（环状序列）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1584-circular-sequence%E7%8E%AF%E7%8A%B6%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1584-circular-sequence%E7%8E%AF%E7%8A%B6%E5%BA%8F%E5%88%97/</guid>
      <description> 长度为n的环状串有n种表示法，分别为从某
个位置开始顺时针得到。例如，图3-4的环状串
有10种表示：
CGAGTCAGCT，GAGTCAGCTC，AGTCAGCTCG等。在这些表示法中，字典序最小的称
为&amp;quot;最小表示&amp;quot;。
输入一个长度为n（n≤100）的环状DNA串（只包含A、C、G、T这4种字符）的一种表
示法，你的任务是输出该环状串的最小表示。例如，CTCC的最小表示是
CCCT，CGAGTCAGCT的最小表示为AGCTCGAGTC。
Sample Input
2
CGAGTCAGCT
CTCC
Sample Output
AGCTCGAGTC
CCCT
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=829&amp;amp;page=show_problem&amp;amp;problem=4459
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;string.h&amp;gt; using namespace std; int const N = 100; //比较从be1,和从be2开始的字串哪一个更小 int com(char *s,int be1,int be2) { int sl=strlen(s); for(int i=0;i&amp;lt;sl;i++) { //cout&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;(be1+i)%N&amp;lt;&amp;lt;endl; //cout&amp;lt;&amp;lt;s[(be1+i)%N]&amp;lt;&amp;lt;&amp;#34;_&amp;#34;&amp;lt;&amp;lt;s[(be2+i)%N]&amp;lt;&amp;lt;endl; if(s[(be1+i)%sl]&amp;gt;s[(be2+i)%sl]) return be2; if(s[(be1+i)%sl]&amp;lt;s[(be2+i)%sl]) return be1; } return be1; } char s[N+5]; int main() { // char acgt[4]=&amp;#34;ACGT&amp;#34;; int T=1; cin&amp;gt;&amp;gt;T; while(T--) { scanf(&amp;#34;%s&amp;#34;,s); int j=0; int be1=0,be2; for(int i=0;i&amp;lt;strlen(s);i++)//找最小的首字符给be1 { if(s[i]&amp;lt;s[be1]) { be1=i; } } //cout&amp;lt;&amp;lt;be1&amp;lt;&amp;lt;endl; for(int i=0;i&amp;lt;strlen(s);i++)//在最小的首字符中 找最小的字串 { if(s[i]==s[be1]) { if(com(s,be1,i)==i) be1=i; } } for(int i=0;i&amp;lt;strlen(s);i++) cout&amp;lt;&amp;lt;s[(be1+i)%strlen(s)]; cout&amp;lt;&amp;lt;endl; } return 0; } ACat2017/12/9 </description>
    </item>
    
    <item>
      <title>uva 1585 - Ancient Cipher （OX）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1585-ancient-cipher-ox/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1585-ancient-cipher-ox/</guid>
      <description> 给出一个由O和X组成的串（长度为1～80），统计得分。每个O的得分为目前连续出现
的O的个数，X的得分为0。例如，OOXXOXXOOO的得分为1+2+0+0+1+0+0+1+2+3。
Sample Input
5
OOXXOXXOOO
OOXXOOXXOO
OXOXOXOXOXOXOX
OOOOOOOOOO
OOOOXOOOOXOOOOX
Sample Output
10
9
7
55
30
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=830&amp;amp;problem=4460&amp;amp;mosmsg=Submission+received+with+ID+20465648
#include&amp;lt;iostream&amp;gt; #include&amp;lt;cstdio&amp;gt; using namespace std; int main() { int T; cin&amp;gt;&amp;gt;T; getchar(); while(T--) { int sum=0; int o=1; int c; while((c=getchar())!=&amp;#39;\n&amp;#39;) { if(c==&amp;#39;O&amp;#39;) { sum+=o; o++; } if(c==&amp;#39;X&amp;#39;) { o=1; } } cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl; } return 0; } //AC at 2017/12/9 </description>
    </item>
    
    <item>
      <title>uva 1586 - Molar mass（分子量）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1586-molar-mass%E5%88%86%E5%AD%90%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1586-molar-mass%E5%88%86%E5%AD%90%E9%87%8F/</guid>
      <description>给出一种物质的分子式（不带括号），求分子量。本题中的分子式只包含4种原子，分
别为C, H, O, N，原子量分别为12.01, 1.008, 16.00, 14.01（单位：g/mol）。例如，C6H5OH的
分子量为94.108g/mol。
Sample Input
4
C
C6H5OH
NH2CH2COOH
C12H22O11
Sample Output
12.010
94.108
75.070
342.296
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=830&amp;amp;problem=4461&amp;amp;mosmsg=Submission+received+with+ID+20466109
//通过判断下一个字符的类型来执行上一个原子的量计算 #include&amp;lt;iostream&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;cctype&amp;gt; using namespace std; int main()//两个变量，一个存原子量，一个存后面的数字 { int T; cin&amp;gt;&amp;gt;T; getchar(); while(T--) { int c; double sum=0,mol=0; int num=0; while((c=getchar())!=&amp;#39;\n&amp;#39;) { if(isdigit(c)) { num=num*10+c-&amp;#39;0&amp;#39;; //sum+=mol*(c-&amp;#39;0&amp;#39;); //num=1; } else { if(num) { sum+=mol*num;//加前一个原子*数量 mol=num=0; } else { sum+=mol;//加前一个原子 } switch(c) { case &amp;#39;C&amp;#39;:mol=12.01;break; case &amp;#39;H&amp;#39;:mol=1.</description>
    </item>
    
    <item>
      <title>uva 1587 - Box（盒子）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1587-box%E7%9B%92%E5%AD%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1587-box%E7%9B%92%E5%AD%90/</guid>
      <description>习题3-10 盒子（Box, ACM/ICPC NEERC 2004, UVa1587）
给定6个矩形的长和宽wi和hi（1≤wi，hi≤1000），判断它们能否构成长方体的6个面。
Sample Input
1345 2584
2584 683
2584 1345
683 1345
683 1345
2584 683
1234 4567
1234 4567
4567 4321
4322 4567
4321 1234
4321 1234
Sample Output
POSSIBLE
IMPOSSIBLE
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=830&amp;amp;problem=4462&amp;amp;mosmsg=Submission+received+with+ID+20554313
1、因为长方体都有三组含四条的边，我们先将三条不同的边长度用一个数组存起，在用一个数组存各个边在六组数据中分别出现的次数。
2、输入的同时来进行存边，并记录下出现的正方形的个数（即输入的两条边相等）。
3、六组输入完成后，判断是否属于以下情况
（1）a 4 , b 4 ,c 4 ,正方面 0
（2）a 8 , b 4 ,c 0 ,正方面 2
（3）a 12 , b 0 ,c 0 ,正方面 6
（a 4：a长度的边有4条）</description>
    </item>
    
    <item>
      <title>uva 1588 - Kickdown（换低挡装置）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1588-kickdown%E6%8D%A2%E4%BD%8E%E6%8C%A1%E8%A3%85%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1588-kickdown%E6%8D%A2%E4%BD%8E%E6%8C%A1%E8%A3%85%E7%BD%AE/</guid>
      <description>习题3-11 换低挡装置（Kickdown, ACM/ICPC NEERC 2006, UVa1588）
给出两个长度分别为n1，n2（n1，n2≤100）且每列高度只为1或2的长条。需要将它们放
入一个高度为3的容器（如图3-8所示），问能够容纳它们的最短容器长度。 Sample Input
2112112112
2212112
12121212
21212121
2211221122
21212
Sample Output
10
8
15
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=830&amp;amp;problem=4463&amp;amp;mosmsg=Submission+received+with+ID+20560401
用两个字符串数组分别存这两个块，一块作为不动的，另一块在其上移动，判断当前移动到的位置是不是和下块契合（用循环依次比较各个位置），若不是则继续移动到下一位。
需要注意的是，最短的契合方案有可能你漏想了，下面一共是三种可能的情况。所以我用一个函数来将两个块换了位置后又移动了一次。
//三种情况：bbbbb aa (|a|:ab重叠 //1.短块在长块里(bb|aa|b) //2.短块头在长块里（外），短块尾巴超出长块尾(bbbb|a|a) //3.长块头在短块尾（外），长块尾巴超出短块尾(a|a|bbbb) //不要忘记第三种情况，有时最短空间就是出自3 #include&amp;lt;iostream&amp;gt; #include&amp;lt;cstring&amp;gt; using namespace std; const int N = 100; //int kick1[N+5],kick2[N+5]; int kickdown(string k1,string k2)//定k1，移k2 { //cout&amp;lt;&amp;lt;k1.size()&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;k2.size()&amp;lt;&amp;lt;endl; for(int i=0;i&amp;lt;k1.size();i++) { int ii=i,j=0;//i就是大小块契合的那一位 //cout&amp;lt;&amp;lt;ii&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl; while((k1[ii]-&amp;#39;0&amp;#39;+k2[j]-&amp;#39;0&amp;#39;)&amp;lt;=3&amp;amp;&amp;amp;(j&amp;lt;k2.size()&amp;amp;&amp;amp;ii&amp;lt;k1.size()))//若当前位不匹配则进行for到下一位 { //cout&amp;lt;&amp;lt;&amp;#34;k1 ii &amp;#34;&amp;lt;&amp;lt;ii&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;k1[ii]&amp;lt;&amp;lt;&amp;#34; | k2 j&amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;k2[j]&amp;lt;&amp;lt;endl; ii++; j++; } if(j==k2.</description>
    </item>
    
    <item>
      <title>uva 1589 - Xiangqi（象棋）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1589-xiangqi%E8%B1%A1%E6%A3%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1589-xiangqi%E8%B1%A1%E6%A3%8B/</guid>
      <description>习题4-1 象棋（Xiangqi, ACM/ICPC Fuzhou 2011, UVa1589）
考虑一个象棋残局，其中红方有n（2≤n≤7）个棋子，黑方只有一个将。红方除了有一个
帅（G）之外还有3种可能的棋子：车（R），马（H），炮（C），并且需要考虑“蹩马
腿”（如图4-4所示）与将和帅不能照面（将、帅如果同在一条直线上，中间又不隔着任何棋
子的情况下，走子的一方获胜）的规则。
输入所有棋子的位置，保证局面合法并且红方已经将军。你的任务是判断红方是否已经
把黑方将死。
Sample Input
2 1 4
G 10 5
R 6 4
3 1 5
H 4 5
G 10 5
C 7 5
0 0 0
Sample Output
YES
NO
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=833&amp;amp;problem=4464&amp;amp;mosmsg=Submission+received+with+ID+20833399
注意：
输入的第一行第一个为红子的数量，后两个是黑将的位置。接下来的是红子类型和位置。
思路：
1、黑将有四种走法，即上下左右。我们只要判断 是否这四种走法中合理的都是死路 即可判断将是否被将死 。
2、先判断是否当前的黑将走子的位置是否合理，即当前的将子有没有超出九宫格。
3、对于车炮帅的将军，我们可以一起判断，先从将的位置开始，依次往一条路过，比如从（1，4）向（10，4）竖的过，
（1）如果路上遇到车或帅，那么就是将军了。
（2）若是非车帅的子，就计数加一。（比如我用c_iff变量记录目前非车帅的子数量）。
（3）若是炮，判断炮前是否有一个子（c_iff的值是不是一），若是，将军 。
（4）关于如何将“顺次从黑将开始分别左一行，右一行，上一列，下一列遍历格子上的子”放在一个循环条件里，见代码，我是将本应四个循环的条件写在一个循环体里用 if 处理了
4、关于马的将军，我们可以单独判断。看图,(x,y)位置为黑将，黑框位置为蹩马腿，如果此处没有子那么与其相邻的两个位置上有马的话就可以将军了。
这里的技巧1：两层循环过完四个方向，见代码
技巧2：黑框位置：（x+i，y+j），与其相邻的马（x+i+i，y+j）和（x+i，y+j+j）
5、注意：还有一点陷阱，我们还要考虑一开始黑将就和红帅对面，那样的话黑将就可以直接击杀红帅。样例：
2 1 5
G 10 5</description>
    </item>
    
    <item>
      <title>uva 1590 - IP Networks（IP地址）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1590-ip-networksip%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1590-ip-networksip%E5%9C%B0%E5%9D%80/</guid>
      <description>习题4-5 IP网络（IP Networks, ACM/ICPC NEERC 2005, UVa1590）
可以用一个网络地址和一个子网掩码描述一个子网（即连续的IP地址范围）。其中子网
掩码包含32个二进制位，前32-n位为1，后n位为0，网络地址的前32-n位任意，后n位为0。
所有前32-n位和网络地址相同的IP都属于此网络。
例如，网络地址为194.85.160.176（二进制为11000010|01010101|10100000|10110000），
子网掩码为255.255.255.248（二进制为11111111|11111111|11111111|11111000），则该子网
的IP地址范围是194.85.160.176～194.85.160.183。输入一些IP地址，求最小的网络（即包含IP
地址最少的网络），包含所有这些输入地址。
例如，若输入3个IP地址：194.85.160.177、194.85.160.183和194.85.160.178，包含上述3
个地址的最小网络的网络地址为194.85.160.176，子网掩码为255.255.255.248。
Sample Input
3
194.85.160.177
194.85.160.183
194.85.160.178
Sample Output
194.85.160.176
255.255.255.248
【注意：他可能有很多组输入，而每组输出之间没有空行】
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=833&amp;amp;problem=4465&amp;amp;mosmsg=Submission+received+with+ID+21184770
思路：
1、先将所有ip存起来，用数组或容器什么的。
2、转换二进制
3、从第一位开始，诸位比较所有的ip在这一位上的数字一样否
4、判断出最小网络位数，即掩码为1的位数。
5、转换十进制
（我用来存二进制的ip用的是string）
（用了下vector，当然也可以用数组存，一个32*1000的数组）
/* 110000100101010110100000_10110001 110000100101010110100000_10110111 110000100101010110100000_10110010 11000010010101011010000010110000 11111111111111111111111111111000 */ //特殊情况：只输入一个IP地址，这时掩码应该32位1 #include&amp;lt;iostream&amp;gt; #include&amp;lt;stack&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstdio&amp;gt; using namespace std; string binary(int dec) { string str=&amp;#34;00000000&amp;#34;; stack&amp;lt;int&amp;gt; s; int bin=0; for(int i=7;i&amp;gt;=0;i--) { //s.push(dec%2); str[i]=dec%2+&amp;#39;0&amp;#39;; dec /= 2; } // while(!</description>
    </item>
    
    <item>
      <title>UVA 1592 - Database (数据库) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1592-database-%E6%95%B0%E6%8D%AE%E5%BA%93-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1592-database-%E6%95%B0%E6%8D%AE%E5%BA%93-by-sucicada/</guid>
      <description>例题5-9 数据库（Database，ACM/ICPC NEERC 2009，UVa1592）
输入一个n行m列的数据库（1≤n≤10000，1≤i≤10），是否存在两个不同行r1，r2和两个
不同列c1，c2，使得这两行和这两列相同（即（r1，c1）和（r2，c1）相同，（r1，c2）和
（r2，c2）相同）。例如，对于如图5-3所示的数据库，第2、3行和第2、3列满足要求。
Sample Input
3 3
How to compete in ACM ICPC,Peter,peter@neerc.ifmo.ru
How to win ACM ICPC,Michael,michael@neerc.ifmo.ru
Notes from ACM ICPC champion,Michael,michael@neerc.ifmo.ru
2 3
1,Peter,peter@neerc.ifmo.ru
2,Michael,michael@neerc.ifmo.ru
Sample Output
NO
2 3
2 3
YES
本家地址
设计存储的结构
[ { (c1.value, c2.value) -&amp;gt; r0.index } ] 列表中存储每一行中列列的组合（map存储）。列表的大小会是数据库的列*(列-1)/2。map的键是一个存有2个元素的列表（列表中存的是列值），map的值是对应的行下标。map的大小为总行数。
存储：
我们在存储时，针对每一行进行列的两两组合，然后对每一个组合在当前列组合下标中进行map查找，如果总排列数过完之后，有2个map匹配项，那我们就找到了。
在这里也用到了字符串索引存储的方式。类比指针，我们对每一个字符串给定一个编号，然后存在数据库中的就只是这个编号，而不用存字符串，节省了很大空间。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;set&amp;gt; using namespace std; /* [ { (c1.value, c2.value) -&amp;gt; r0.</description>
    </item>
    
    <item>
      <title>UVA 1599 - Ideal Path(理想路径) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-1599-ideal-path%E7%90%86%E6%83%B3%E8%B7%AF%E5%BE%84-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-1599-ideal-path%E7%90%86%E6%83%B3%E8%B7%AF%E5%BE%84-by-sucicada/</guid>
      <description>例题6-20 理想路径（Ideal Path, NEERC 2010, UVa1599）
给一个n个点m条边（2≤n≤100000，1≤m≤200000）的无向图，每条边上都涂有一种颜
色。求从结点1到结点n的一条路径，使得经过的边数尽量少，在此前提下，经过边的颜色序
列的字典序最小。一对结点间可能有多条边，一条边可能连接两个相同结点。输入保证结点
1可以达到结点n。颜色为1～10
9的整数。
Sample Input
4 6
1 2 1
1 3 2
3 4 3
2 3 1
2 4 4
3 1 1
Sample Output
2
1 3
本家链接
先找最短路：倒序从终点bfs找。
- 在此认为倒序和正序效果一样。只是某些处理逻辑相反。
bfs之后，可能存在多条最短路，所以再需要一次bfs，来选出颜色最小的路。
降低时间的注意点：
选择合适的数据结构存储图。 一开始使用了map作为存储图的结构，后来在遍历过程中实在比vector慢了太多。 使用标记记录走过的结点，减少bfs重复计算。 对了2:00 - 2:30 期间uva oj 判题特别慢特别慢。尽量避开。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;map&amp;gt; #include&amp;lt;queue&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstring&amp;gt; #include&amp;lt;set&amp;gt; using namespace std; #define mapiter map&amp;lt;int,int&amp;gt;::iterator const int MAX_N = 100005; /* 先找最短路：倒序从终点bfs找。 - 在此认为倒序和正序效果一样。只是某些处理逻辑相反。 bfs之后，可能存在多条最短路，所以再需要一次bfs，来选出颜色最小的路。 一开始使用了map作为存储图的结构，后来在遍历过程中实在比vector慢了太多。 */ /* a-&amp;gt;b map[a][b] == color */ class Node{ public: int next; int color; }; // map&amp;lt;int,int&amp;gt; door[MAX_N]; vector&amp;lt;Node&amp;gt; door[MAX_N]; /* 存储无向图，因为结点太多了 */ int book[MAX_N]; /* 记录每个点距离终点`的最小距离 */ int visit[MAX_N]; /* 记录走过的点 */ int big = (1L&amp;lt;&amp;lt;31)-1; int res[MAX_N]; int N,M; /* n下各点 到n 的距离取最短+1 door[a][b] a -&amp;gt; b log[b] = min(log[b], log[a]+1) */ void bfs(){ queue&amp;lt;int&amp;gt; tmp; tmp.</description>
    </item>
    
    <item>
      <title>uva 201 - Squares（数正方形）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-201-squares%E6%95%B0%E6%AD%A3%E6%96%B9%E5%BD%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-201-squares%E6%95%B0%E6%AD%A3%E6%96%B9%E5%BD%A2/</guid>
      <description>习题4-2 正方形（Squares, ACM/ICPC World Finals 1990, UVa201）
有n行n列（2≤n≤9）的小黑点，还有m条线段连接其中的一些黑点。统计这些线段连成
了多少个正方形（每种边长分别统计）。
行从上到下编号为1～n，列从左到右编号为1～n。边用H i j和V i j表示，分别代表边
(i,j)-(i,j+1)和(i,j)-(i+1,j)。如图4-5所示最左边的线段用V 1 1表示。图中包含两个边长为1的正
方形和一个边长为2的正方形。
Sample Input
4
16
H 1 1
H 1 3
H 2 1
H 2 2
H 2 3
H 3 2
H 4 2
H 4 3
V 1 1
V 2 1
V 2 2
V 2 3
V 3 2
V 4 1
V 4 2
V 4 3</description>
    </item>
    
    <item>
      <title>uva 202 - Repeating Decimals（循环小数）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-202-repeating-decimals%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-202-repeating-decimals%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0/</guid>
      <description>习题3-8 循环小数（Repeating Decimals, ACM/ICPC World Finals 1990, UVa202）
输入整数a和b（0≤a≤3000，1≤b≤3000），输出a/b的循环小数表示以及循环节长度。例
如a=5，b=43，小数表示为0.(116279069767441860465)，循环节长度为21。
注意：有些即便是原题也可能没用看清的要求
（如果小数位大于50括号里显示到50个小数位即可，后面加&amp;hellip;）
（但是输出的小数位要是确实的位数，即便几百几千）
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=830&amp;amp;problem=138&amp;amp;mosmsg=Submission+received+with+ID+20551105
Sample Input
76 25
5 43
1 397
Sample Output
76/25 = 3.04(0)
1 = number of digits in repeating cycle
5/43 = 0.(116279069767441860465)
21 = number of digits in repeating cycle
1/397 = 0.(00251889168765743073047858942065491183879093198992&amp;hellip;)
99 = number of digits in repeating cycle
（ps：这个案例的99就很是误导人）
思路：从手算的除法公式下手，每一次的被除数都是 上一个被除数 &amp;ndash; 上一位商*除数，而我们只要找到从哪里开始的被除数和之前的某一个被除数一样，那么从这一位便开始循环；如果不懂，看下面的例子：2/3
0.6 6 // 3|2.0 //一开始不够除，补零 1.8 //28 = 4（商）* 7（除数） 2 0 //20 = (30（被除数）- 4（商）* 7（除数）)*10 //开始循环 //同时我们发现 这里的被除数20 和第二行的被除数20 一样， 如果还不懂，亲自写一下除法运算，真的可以秒懂。</description>
    </item>
    
    <item>
      <title>uva 210 - Concurrency Simulator (并行程序模拟)</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-210-concurrency-simulator-%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-210-concurrency-simulator-%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F/</guid>
      <description>例题6-1 并行程序模拟（ Concurrency Simulator, ACM/ICPC World Finals 1991,
UVa210）
你的任务是模拟n个程序（ 按输入顺序编号为1～ n） 的并行执行。 每个程序包含不超过
25条语句， 格式一共有5种： var = constant（ 赋值） ； print var（ 打印） ； lock； unlock； end。
变量用单个小写字母表示， 初始为0， 为所有程序公有（ 因此在一个程序里对某个变量
赋值可能会影响另一个程序） 。 常数是小于100的非负整数。
每个时刻只能有一个程序处于运行态， 其他程序均处于等待态。 上述5种语句分别需
要t1、 t2、 t3、 t4、 t5单位时间。 运行态的程序每次最多运行Q个单位时间（ 称为配额） 。 当
一个程序的配额用完之后， 把当前语句（ 如果存在） 执行完之后该程序会被插入一个等待队
列中， 然后处理器从队首取出一个程序继续执行。 初始等待队列包含按输入顺序排列的各个
程序， 但由于lock/unlock语句的出现， 这个顺序可能会改变。
lock的作用是申请对所有变量的独占访问。 lock和unlock总是成对出现， 并且不会嵌套。
lock总是在unlock的前面。 当一个程序成功执行完lock指令之后， 其他程序一旦试图执行lock
指令， 就会马上被放到一个所谓的阻止队列的尾部（ 没有用完的配额就浪费了） 。 当unlock
执行完毕后， 阻止队列的第一个程序进入等待队列的首部。</description>
    </item>
    
    <item>
      <title>uva 213 - Message Decoding（二进制编码）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-213-message-decoding%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-213-message-decoding%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/</guid>
      <description>例题4-4 信息解码（Message Decoding, ACM/ICPC World Finals 1991, UVa 213）
考虑下面的01串序列：
0, 00, 01, 10, 000, 001, 010, 011, 100, 101, 110, 0000, 0001, …, 1101, 1110, 00000, …
首先是长度为1的串，然后是长度为2的串，依此类推。如果看成二进制，相同长度的后
一个串等于前一个串加1。注意上述序列中不存在全为1的串。
你的任务是编写一个解码程序。首先输入一个编码头（例如AB#TANCnrtXc），则上述
序列的每个串依次对应编码头的每个字符。例如，0对应A，00对应B，01对应#，…，110对
应X，0000对应c。接下来是编码文本（可能由多行组成，你应当把它们拼成一个长长的01
串）。编码文本由多个小节组成，每个小节的前3个数字代表小节中每个编码的长度（用二
进制表示，例如010代表长度为2），然后是各个字符的编码，以全1结束（例如，编码长度
为2的小节以11结束）。编码文本以编码长度为000的小节结束。
例如，编码头为$#\，编码文本为0100000101101100011100101000，应这样解码：
010(编码长度为2)00(#)00(#)10(*)11(小节结束)011(编码长度为3)000()111(小节结束)001(编码
长度为1)0($)1(小节结束)000(编码结束)。
Sample input
TNM AEIOU
0010101100011
1010001001110110011
11000
$#
0100000101101100011100101000
Sample output
TAN ME
##*$
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=832&amp;amp;problem=149&amp;amp;mosmsg=Submission+received+with+ID+20759428
/* 1、先接收字符串，因为有空格，所以我用了getline，因为我用string 2、然后我们将输入的字符串存入code这个二维数组里，code[i][j]中i代表二进制码的位数，j代表当前01码的十进制数。以此我们每次循环的j小于2^i-i即可。 3、然后我们用循环，先将三位的二进制数传入bin_dec()函数，来得出接下来代表一个字符的二进制码的位数。 4、contra()函数是用来进行每一组相同码长的字符的输出。 （1）其思路是用一个变量记录当前bcode（01码字符串）读到哪个位了。 （2）然后循环将之后的len位二进制变成一个整数，传入bin_dec()函数得出其代表的十进制数，而这个十进制数也是code数组的第二维的下标。 5、还有一点，因为二进制码在输入的过程中并不一定是在同一行,所以我用了：当前下标+要接受的码长 和 当前的01码字符串长度来进行比较，若大则接收新的一行字符串，再加到原先01码字符串后面。（！注意这里用的是while循环而不是单一次的if判断，是因为可能接收一次字串后也依然不够码长，所以要一直接收到足够长为止。）*/ #include&amp;lt;iostream&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;cstring&amp;gt; using namespace std; char code[7][1&amp;lt;&amp;lt;7];//长度，值，来存字符 int bin_dec(int b)//二进制转十进制 { int dec=0; for(int i=0;b!</description>
    </item>
    
    <item>
      <title>uva 220 - Othello（黑白翻转棋）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-220-othello%E9%BB%91%E7%99%BD%E7%BF%BB%E8%BD%AC%E6%A3%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-220-othello%E9%BB%91%E7%99%BD%E7%BF%BB%E8%BD%AC%E6%A3%8B/</guid>
      <description>习题4-3 黑白棋（Othello, ACM/ICPC World Finals 1992, UVa220）
你的任务是模拟黑白棋游戏的进程。黑白棋的规则为：黑白双方轮流放棋子，每次必须
让新放的棋子“夹住”至少一枚对方棋子，然后把所有被新放棋子“夹住”的对方棋子替换成己
方棋子。一段连续（横、竖或者斜向）的同色棋子被“夹住”的条件是两端都是对方棋子（不
能是空位）。如图4-6（a）所示，白棋有6个合法操作，分别为(2,3),(3,3),(3,5), (6,2),(7,3),
(7,4)。选择在(7,3)放白棋后变成如图4-6（b）所示效果（注意有竖向和斜向的共两枚黑棋变
白）。注意(4,6)的黑色棋子虽然被夹住，但不是被新放的棋子夹住，因此不变白。
（a） （b）
图4-6 黑白棋
输入一个8*8的棋盘以及当前下一次操作的游戏者，处理3种指令：
L指令打印所有合法操作，按照从上到下，从左到右的顺序排列（没有合法操作时输出No legal move）。
Mrc指令放一枚棋子在(r,c)。如果当前游戏者没有合法操作，则是先切换游戏者再操作。输入保证这个操作是合法的。输出操作完毕后黑白方的棋子总数。
Q指令退出游戏，并打印当前棋盘（格式同输入）。
Sample Input
2
-&amp;mdash;&amp;mdash;-
-&amp;mdash;&amp;mdash;-
-&amp;mdash;&amp;mdash;-
&amp;mdash;WB&amp;mdash;
-&amp;ndash;BW&amp;mdash;
-&amp;mdash;&amp;mdash;-
-&amp;mdash;&amp;mdash;-
-&amp;mdash;&amp;mdash;-
W
L
M35
L
Q
WWWWB&amp;mdash;
WWWB&amp;mdash;-
WWB&amp;mdash;&amp;ndash;
WB&amp;mdash;&amp;mdash;
-&amp;mdash;&amp;mdash;-
-&amp;mdash;&amp;mdash;-
-&amp;mdash;&amp;mdash;-
-&amp;mdash;&amp;mdash;-
B
L
M25
L
Q
Sample Output
(3,5) (4,6) (5,3) (6,4)
Black - 1 White - 4
(3,4) (3,6) (5,6)
-&amp;mdash;&amp;mdash;-</description>
    </item>
    
    <item>
      <title>UVA 221 - Urban Elevations(城市正视图) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-221-urban-elevations%E5%9F%8E%E5%B8%82%E6%AD%A3%E8%A7%86%E5%9B%BE-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-221-urban-elevations%E5%9F%8E%E5%B8%82%E6%AD%A3%E8%A7%86%E5%9B%BE-by-sucicada/</guid>
      <description>例题5-12 城市正视图（Urban Elevations, ACM/ICPC World Finals 1992, UVa221）
如图5-4所示，有n（n≤100）个建筑物。左侧是俯视图（左上角为建筑物编号，右下角
为高度），右侧是从南向北看的正视图。
图5-4 建筑俯视图与正视图
输入每个建筑物左下角坐标（即x、y坐标的最小值）、宽度（即x方向的长度）、深度
（即y方向的长度）和高度（以上数据均为实数），输出正视图中能看到的所有建筑物，按
照左下角x坐标从小到大进行排序。左下角x坐标相同时，按y坐标从小到大排序。
输入保证不同的x坐标不会很接近（即任意两个x坐标要么完全相同，要么差别足够大，
不会引起精度问题）。
Sample Input
14
160 0 30 60 30
125 0 32 28 60
95 0 27 28 40
70 35 19 55 90
0 0 60 35 80
0 40 29 20 60
35 40 25 45 80
0 67 25 20 50
0 92 90 20 80
95 38 55 12 50</description>
    </item>
    
    <item>
      <title>uva 227 - Puzzle （迷宫中的空格）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-227-puzzle-%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-227-puzzle-%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC/</guid>
      <description>习题3-5 谜题（Puzzle, ACM/ICPC World Finals 1993, UVa227）
有一个5*5的网格，其中恰好有一个格子是空的，其他格子各有一个字母。一共有4种指
令：A, B, L, R，分别表示把空格上、下、左、右的相邻字母移到空格中。输入初始网格和指
令序列（以数字0结束），输出指令执行完毕后的网格。如果有非法指令，应输出“This
puzzle has no final configuration.
还有：输入的迷宫以大写 Z 结束。输出的行与行间要有一行空行
Sample Input
TRGSJ
XDOKI
M VLN
WPABE
UQHCF
ARRBBL0
ABCDE
FGHIJ
KLMNO
PQRS
TUVWX
AAA
LLLL0
ABCDE
FGHIJ
KLMNO
PQRS
TUVWX
AAAAABBRRRLL0
Z
Sample Output
Puzzle #1:
T R G S J
X O K L I
M D V B N
W P A E
U Q H C F</description>
    </item>
    
    <item>
      <title>uva 232 - Crossword Answers（纵横迷宫）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-232-crossword-answers%E7%BA%B5%E6%A8%AA%E8%BF%B7%E5%AE%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-232-crossword-answers%E7%BA%B5%E6%A8%AA%E8%BF%B7%E5%AE%AB/</guid>
      <description>习题3-6 纵横字谜的答案（Crossword Answers, ACM/ICPC World Finals 1994,
UVa232）
输入一个r行c列（1≤r，c≤10）的网格，黑格用“*”表示，每个白格都填有一个字母。如
果一个白格的左边相邻位置或者上边相邻位置没有白格（可能是黑格，也可能出了网格边
界），则称这个白格是一个起始格。
首先把所有起始格按照从上到下、从左到右的顺序编号为1, 2, 3,…，如图所示。
接下来要找出所有横向单词（Across）。这些单词必须从一个起始格开始，向右延伸到
一个黑格的左边或者整个网格的最右列。最后找出所有竖向单词（Down）。这些单词必须
从一个起始格开始，向下延伸到一个黑格的上边或者整个网格的最下行。
输出时每两行之间有空行
Sample Input
2 2
AT
O
6 7
AIMDEN
MEONE
UPONTO
SOERIN
SAOR*
IES*DEA
0
Sample Output
puzzle #1:
Across
1.AT
3.O
Down
1.A
2.TO
puzzle #2:
Across
1.AIM
4.DEN
7.ME
8.ONE
9.UPON
11.TO
12.SO
13.ERIN
15.SA
17.OR
18.IES
19.DEA
Down
1.A
2.IMPOSE
3.MEO
4.DO
5.ENTIRE
6.NEON
9.US
10.NE
14.ROD
16.AS</description>
    </item>
    
    <item>
      <title>uva 253 - Cube painting（相同骰子）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-253-cube-painting%E7%9B%B8%E5%90%8C%E9%AA%B0%E5%AD%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-253-cube-painting%E7%9B%B8%E5%90%8C%E9%AA%B0%E5%AD%90/</guid>
      <description>习题4-4 骰子涂色（Cube painting, UVa 253）
输入两个骰子，判断二者是否等价。每个骰子用6个字母表示，如图4-7所示。
图4-7 骰子涂色
例如rbgggr和rggbgr分别表示如图4-8所示的两个骰子。二者是等价的，因为图4-8（a）
所示的骰子沿着竖直轴旋转90°之后就可以得到图4-8（b）所示的骰子。
（a） （b）
图4-8 旋转前后的两个骰子
.
Sample Input
rbgggrrggbgr
rrrbbbrrbbbr
rbgrbgrrrrrg
Sample Output
TRUE
FALSE
FALSE
思路：暴力枚举，将一个骰子的所有姿态都列出来，
1、注意第一个图上的数字，那个是记录骰子面的顺序
2、先找最上面的，也就是1的位置，能排列6种（1，2，3，4，5，6）
3、然后找到了上面也就找到了与其相对的面，就是下面，就是字串中第六个元素。这个不会额外记录，因为有上就有下了。
4、然后就是中间四个的排列了，很显然，4种。
5、然后我们变换第二个骰子，看看它在这24种情况中，有没有一种的情况和第一个骰子的记录是相同的。（比较字串即可）
6、请注意骰子面的转换是否正确，虽然这个逻辑简单，但是容易写错，要好好检查，我就因为写错下标错了两次。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; using namespace std; /* 1 3 2 4 5 1在顶上 6 2 3 6 4 1 2在顶上 5 3 5 6 2 1	3在顶上 4 4 2 6 5 1	4在顶上 3 5 4 6 3 1	5在顶上 2 6 3 5 4 2	6在顶上 1 */ string s1,s2;//记录两个骰子的字符串 int str_equal(string a,char s1,char s2,char s3,char s4,char s5,char s6)//比较两个字串相等吗 { string b=&amp;#34;0000000&amp;#34;; b[1]=s1; b[2]=s2; b[3]=s3; b[4]=s4; b[5]=s5; b[6]=s6; //cout&amp;lt;&amp;lt;b.</description>
    </item>
    
    <item>
      <title>UVA 297 - Quadtrees （四分数） By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-297-quadtrees-%E5%9B%9B%E5%88%86%E6%95%B0-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-297-quadtrees-%E5%9B%9B%E5%88%86%E6%95%B0-by-sucicada/</guid>
      <description>例题6-11 四分树（Quadtrees, UVa 297）
如图6-8所示，可以用四分树来表示一个黑白图像，方法是用根结点表示整幅图像，然
后把行列各分成两等分，按照图中的方式编号，从左到右对应4个子结点。如果某子结点对
应的区域全黑或者全白，则直接用一个黑结点或者白结点表示；如果既有黑又有白，则用一
个灰结点表示，并且为这个区域递归建树。
图6-8 四分树
给出两棵四分树的先序遍历，求二者合并之后（黑色部分合并）黑色像素的个数。p表
示中间结点，f表示黑色（full），e表示白色（empty）。
样例输入：
3
ppeeefpffeefe
pefepeefe
peeef
peefe
peeef
peepefefe
样例输出：
There are 640 black pixels.
There are 512 black pixels.
There are 384 black pixels.
本家
构造32*32的矩阵，构建树木的时候同时给矩阵染色，由于黑色会覆盖，所以也不怕树木之间的冲突。然后最后刷一下矩阵，看看有多少个黑块块就行（即数字为1）
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;cmath&amp;gt; using namespace std; /* 共5+1层 32*32=4^5 */ int SIDE_LENGTH = 32; int quad[100][100]; int sum = 0; /* f &amp;gt; p &amp;gt; e */ void build(int side,int x,int y){ char c; cin&amp;gt;&amp;gt;c; if(c==&amp;#39;p&amp;#39;){ for(int xi=0;xi&amp;lt;=1;xi++){ for(int yi=0;yi&amp;lt;=1;yi++){ int nextSide = side / 2; int xx = x+nextSide*xi; int yy = y+nextSide*yi; build(nextSide,xx,yy); } } }else if(c==&amp;#39;f&amp;#39;){ /* fill $quad from $begin to $end */ for(int xi=x;xi&amp;lt;x+side;xi++){ for(int yi=y;yi&amp;lt;y+side;yi++){ if(quad[xi][yi]==0){ sum++; quad[xi][yi] = 1; } } } } } int main(){ int T; cin&amp;gt;&amp;gt;T; while(T--){ // memset(quad,0,SIDE_LENGTH*SIDE_LENGTH*sizeof(int)); for(int i=0;i&amp;lt;SIDE_LENGTH;i++){ for(int j=0;j&amp;lt;SIDE_LENGTH;j++){ quad[i][j]=0; } } sum = 0; for(int i=0;i&amp;lt;2;i++){ build(SIDE_LENGTH,0,0); } cout&amp;lt;&amp;lt;&amp;#34;There are &amp;#34;&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;&amp;#34; black pixels.</description>
    </item>
    
    <item>
      <title>uva 340 	Master-Mind Hints（猜数串）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-340-master-mind-hints%E7%8C%9C%E6%95%B0%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-340-master-mind-hints%E7%8C%9C%E6%95%B0%E4%B8%B2/</guid>
      <description>实现一个经典&amp;quot;猜数字&amp;quot;游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确
（A），有多少数字在两个序列都出现过但位置不对（B）。
输入包含多组数据。每组输入第一行为序列长度n，第二行是答案序列，接下来是若干
猜测序列。猜测序列全0时该组数据结束。n=0时输入结束。
样例输入：
4
1 3 5 5
1 1 2 3
4 3 3 5
6 5 5 1
6 1 3 5
1 3 5 5
0 0 0 0
10
1 2 2 2 4 5 6 6 6 9
1 2 3 4 5 6 7 8 9 1
1 1 2 2 3 3 4 4 5 5
1 2 1 3 1 5 1 6 1 9</description>
    </item>
    
    <item>
      <title>UVA 400 - Unix ls (Unixls命令)</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-400-unix-ls-unixls%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-400-unix-ls-unixls%E5%91%BD%E4%BB%A4/</guid>
      <description>例题5-8 Unixls命令（Unix ls，UVa400） 输入正整数n以及n个文件名，按照字典序排序后按列优先的方式左对齐输出。 假设最长文件名有M字符，则最右列有M字符，其他列都是M＋2字符。
Sample Input
10
tiny
2short4me
very_long_file_name
shorter
size-1
size2
size3
much_longer_name
12345678.123
mid_size_name
12
Weaser
Alfalfa
Stimey
Buckwheat
Porky
Joe
Darla
Cotton
Butch
Froggy
Mrs_Crabapple
P.D.
19
Mr._French
Jody
Buffy
Sissy
Keith
Danny
Lori
Chris
Shirley
Marsha
Jan
Cindy
Carol
Mike
Greg
Peter
Bobby
Alice
Ruben
Sample Output
------------------------------------------------------------ 12345678.123 size-1 2short4me size2 mid_size_name size3 much_longer_name tiny shorter very_long_file_name ------------------------------------------------------------ Alfalfa Cotton Joe Porky Buckwheat Darla Mrs_Crabapple Stimey Butch Froggy P.</description>
    </item>
    
    <item>
      <title>uva 401（回文词）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-401%E5%9B%9E%E6%96%87%E8%AF%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-401%E5%9B%9E%E6%96%87%E8%AF%8D/</guid>
      <description>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=829&amp;amp;problem=342&amp;amp;mosmsg=Submission+received+with+ID+20398535
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; #include&amp;lt;string.h&amp;gt; using namespace std; string r=&amp;#34;A 3 HIL JM O 2TUVWXY501SE Z 8 &amp;#34;; char *m_c=&amp;#34;AHIMOTUVWXY018&amp;#34;; char mir_c(char c) { if(c&amp;gt;=&amp;#39;A&amp;#39;&amp;amp;&amp;amp;c&amp;lt;=&amp;#39;Z&amp;#39;) { c=r[c-&amp;#39;A&amp;#39;]; } else if(c&amp;gt;=&amp;#39;0&amp;#39;&amp;amp;&amp;amp;c&amp;lt;=&amp;#39;9&amp;#39;)//如果不是else if 那么变成2的S又会变回S c=r[c-&amp;#39;0&amp;#39;+26]; return c; } int main() { string s; while(cin&amp;gt;&amp;gt;s) { int n=s.size(); int m1=2,m2=3,i;//先判断对称，再判断镜像 for(i=0;i&amp;lt;n/2;i++) { if(s[i]!=s[n-i-1]) m1=1; if(mir_c(s[i])!=s[n-i-1]) { //cout&amp;lt;&amp;lt;mir_c(s[i])&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;s[n-i-1]; m2=1; } } if((n%2==1)&amp;amp;&amp;amp;strchr(m_c,s[n/2])==NULL) m2=1;//判断中间一位是不是镜像的 //cout&amp;lt;&amp;lt;m1&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;m2&amp;lt;&amp;lt;&amp;#34; &amp;#34;; cout&amp;lt;&amp;lt;s; switch(m1*=m2) { case 1:cout&amp;lt;&amp;lt;&amp;#34; -- is not a palindrome.</description>
    </item>
    
    <item>
      <title>uva 455 - Periodic Strings （找字符串周期）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-455-periodic-strings-%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-455-periodic-strings-%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%A8%E6%9C%9F/</guid>
      <description>习题3-4 周期串（Periodic Strings, UVa455）
如果一个字符串可以由某个长度为k的字符串重复多次得到，则称该串以k为周期。例
如，abcabcabcabc以3为周期（注意，它也以6和12为周期）。
输入一个长度不超过80的字符串，输出其最小周期。
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;category=830&amp;amp;problem=396&amp;amp;mosmsg=Submission+received+with+ID+20473859
//先找到和第一个元素相等的下一个元素，然后第一个元素位和找到的元素位依次往后过， //一直到结束，若一直一样则周期为找到的元素位。 //比如ababcababc， //1.s[0]先找到了和s[1]相等,然后分析， //2.s[0+1]和s[1+1]比，相等。 //3.s[0+1+1]再和s[1+1+1],不等，跳出 //4.s[0]再和s[2],s[3],s[4]比。。。 #include&amp;lt;iostream&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;string.h&amp;gt; using namespace std; const int N = 80; char s[N+5]; int cir(int i) { int n=strlen(s); if(n%i!=0)//防止aba或abca输出2或3而不是3或4的情况 return 0; for(int j=i;j&amp;lt;strlen(s);j++)//顺次比较前后字串相等否 { if(s[j-i]!=s[j]) { return 0; } } return i; } int main () { int tt; scanf(&amp;#34;%d&amp;#34;,&amp;amp;tt); while(tt--) { scanf(&amp;#34;\n%s&amp;#34;,s); int T=0;//周期 int i,n=strlen(s); for(i=1;i&amp;lt;n;i++) { if(s[0]==s[i]) { if((T=cir(i))==i) { break; } } } cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;endl; if(tt!</description>
    </item>
    
    <item>
      <title>uva 489 - Hangman Judge（吊人游戏）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-489-hangman-judge%E5%90%8A%E4%BA%BA%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-489-hangman-judge%E5%90%8A%E4%BA%BA%E6%B8%B8%E6%88%8F/</guid>
      <description>例题4-2 刽子手游戏（Hangman Judge, UVa 489）
刽子手游戏其实是一款猜单词游戏，如图4-
1所示。游戏规则是这样的：计算机想一个单词
让你猜，你每次可以猜一个字母。如果单词里有
那个字母，所有该字母会显示出来；如果没有那
个字母，则计算机会在一幅“刽子手”画上填一
笔。这幅画一共需要7笔就能完成，因此你最多
只能错6次。注意，猜一个已经猜过的字母不！算
错。
在本题中，你的任务是编写一个“裁判”程
序，输入单词和玩家的猜测，判断玩家赢了
（You win.）、输了（You lose.）还是放弃了
（You chickened out.）。每组数据包含3行，第1
行是游戏编号（-1为输入结束标记），第2行是
计算机想的单词，第3行是玩家的猜测。后两行
保证只含小写字母。
注意，猜一个已经猜过的字母不算
错。！
Sample Input
1
cheese
chese
2
cheese
abcdefg
3
cheese
abcdefgij
-1
Sample Output
Round 1
You win.
Round 2
You chickened out.
Round 3
You lose.
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=832&amp;amp;page=show_problem&amp;amp;problem=430
用两个整型来记录当前还允许错的次数，和原始字符串的总字符数
1，因为重复猜测不算错，所以我们先将guess字符串中的重复字符消去，用循环和string::erase()
2，外循环猜测字符串，内循环原始字符串，如果相同，就将原始字符串的此元素变成‘ * ’。
3，没猜中一次就记录，内循环结束后来更新记录。若果win或lose就return函数，否则循环都结束之后就说明是‘弃权’。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; using namespace std; string orig,guess; int hang(int num,int right) { for(int i=0;i&amp;lt;guess.</description>
    </item>
    
    <item>
      <title>uva 508 - Morse Mismatches（摩斯码）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-508-morse-mismatches%E6%91%A9%E6%96%AF%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-508-morse-mismatches%E6%91%A9%E6%96%AF%E7%A0%81/</guid>
      <description>习题4-6 莫尔斯电码（Morse Mismatches, ACM/ICPC World Finals 1997, UVa508）
输入每个字母的Morse编码，一个词典以及若干个编码。对于每个编码，判断它可能是
哪个单词。如果有多个单词精确匹配，选取字典序第一个再加上“!”；如果无法精确匹
配，可以在编码尾部增加或删除一些字符以后匹配某个单词（增加或删除的字符应尽量少）。如果有多个单词可以这样匹配上，选取字典序第一个输出并且在后面加上“?”。
。
提供一个样例
Sample Input
A .-
B -&amp;hellip;
C -.-.
D -..
E .
F ..-.
G &amp;ndash;.
H &amp;hellip;.
I ..
J .&amp;mdash;
K -.-
L .-..
M &amp;ndash;
N -.
O &amp;mdash;
P .&amp;ndash;.
Q &amp;ndash;.-
R .-.
S &amp;hellip;
T -
U ..-
V &amp;hellip;-
W .&amp;ndash;
X -..-
Y -.&amp;ndash;
Z &amp;ndash;..
0 &amp;mdash;&amp;mdash;</description>
    </item>
    
    <item>
      <title>uva 509 RAID!（磁盘数据）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-509-raid%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-509-raid%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE/</guid>
      <description>习题4-7 RAID技术（RAID!, ACM/ICPC World Finals 1997, UVa509）
RAID技术用多个磁盘保存数据。每份数据在不止一个磁盘上保存，因此在某个磁盘损
坏时能通过其他磁盘恢复数据。本题讨论其中一种RAID技术。数据被划分成大小
为s（1≤s≤64）比特的数据块保存在d（2≤d≤6）个磁盘上，如图4-9所示，每d-1个数据块都
有一个校验块，使得每d个数据块的异或结果为全0（偶校验）或者全1（奇校验）。
图4-9 数据保存情况
例如，d=5，s=2，偶校验，数据6C7A79EDFC（二进制01101100 01111010 01111001
11101101 11111100）的保存方式如图4-10所示。
图4-10 数据6C7A79EDPC的保存方式
其中加粗块是校验块。输入d、s、b、校验的种类（E表示偶校验，O表示奇校验）以
及b（1≤b≤100）个数据块（其中“x”表示损坏的数据），你的任务是恢复并输出完整的数
据。如果校验错或者由于损坏数据过多无法恢复，应报告磁盘非法。
Sample Input
5 2 5
E
0001011111
0110111011
1011011111
1110101100
0010010111
3 2 5
E
0001111111
0111111011
xx11011111
3 5 1
O
11111
11xxx
x1111
0
Sample Output
Disk set 1 is valid, contents are: 6C7A79EDFC
Disk set 2 is invalid.
Disk set 3 is valid, contents are: FFC</description>
    </item>
    
    <item>
      <title>uva 512 - Spreadsheet Tracking（Excel表格）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-512-spreadsheet-trackingexcel%E8%A1%A8%E6%A0%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-512-spreadsheet-trackingexcel%E8%A1%A8%E6%A0%BC/</guid>
      <description>例题4-5 踪电子表格中的单元格（Spreadsheet Tracking, ACM/ICPC World Finals
1997, UVa512）
有一个r行c列（1≤r，c≤50）的电子表格，行从上到下编号为1～r，列从左到右编号为1
～c。如图4-2（a）所示，如果先删除第1、5行，然后删除第3, 6, 7, 9列，结果如图4-2（b）
所示。
（a） （b）
图4-2 删除行、列
接下来在第2、3、5行前各插入一个空行，然后在第3列前插入一个空列，会得到如图4-
3所示结果。
图4-3 插入行、列
你的任务是模拟这样的n个操作。具体来说一共有5种操作：
EX r1 c1 r2 c2交换单元格(r1,c1),(r2,c2)。
A x1 x2 … xA 插入或删除A行或列（DC-删除列，DR-删除行，IC-插入
列，IR-插入行，1≤A≤10）。
在插入／删除指令后，各个x值不同，且顺序任意。接下来是q个查询，每个查询格式
为“r c”，表示查询原始表格的单元格(r,c)。对于每个查询，输出操作执行完后该单元格的新
位置。输入保证在任意时刻行列数均不超过50。
Sample Input
7 9
5
DR 2 1 5
DC 4 3 6 7 9
IC 1 3
IR 2 2 4
EX 1 2 6 5
4
4 8</description>
    </item>
    
    <item>
      <title>UVA 514 - Rails ( 铁轨)</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-514-rails-%E9%93%81%E8%BD%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-514-rails-%E9%93%81%E8%BD%A8/</guid>
      <description>例题6-2 铁轨（Rails, ACM/ICPC CERC 1997, UVa 514）
某城市有一个火车站，铁轨铺设如图6-1所示。 有n节车厢从A方向驶入车站，按进站顺
序编号为1～n。 你的任务是判断是否能让它们按照某种特定的顺序进入B方向的铁轨并驶出
车站。 例如，出栈顺序(5 4 1 2 3)是不可能的，但(5 4 3 2 1)是可能的。
为了重组车厢，你可以借助中转站C。 这是一个可以停放任意多节车厢的车站，但由于
末端封顶，驶入C的车厢必须按照相反的顺序驶出C。 对于每个车厢，一旦从A移入C，就不
能再回到A了；一旦从C移入B，就不能回到C了。 换句话说，在任意时刻，只有两种选择：
A→C和C→B。
Sample Input
5
1 2 3 4 5
5 4 1 2 3
0
6
6 5 4 3 2 1
0
0
Sample Output
Yes
No
Yes
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=838&amp;amp;page=show_problem&amp;amp;problem=455
和书上的思路一样
车进入是先从1到n
我们每进入一辆,就判断一下是不是要出去的那一辆, 如果是,这辆车就走了,然后判断一下下一辆
如果不是就进入中转轨道中等的
#include&amp;lt;iostream&amp;gt; #include&amp;lt;stack&amp;gt; using namespace std; // [注意] 最后一组输出之后要有一个空行 int fun(int N){ stack&amp;lt;int&amp;gt; wait; // 等待通过的火车 stack&amp;lt;int&amp;gt; temp; // 中转轨道 for(int i=N;i&amp;gt;=1;i--){ wait.</description>
    </item>
    
    <item>
      <title>uva 540 - Team Queue（插队队列）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-540-team-queue%E6%8F%92%E9%98%9F%E9%98%9F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-540-team-queue%E6%8F%92%E9%98%9F%E9%98%9F%E5%88%97/</guid>
      <description>例题5-6 团体队列(Team Queue,UVa540)
有t个团队的人正在排一个长队。每次新来一个人时,如果他有队友在排队,那么这个
新人会插队到最后一个队友的身后。如果没有任何一个队友排队,则他会排到长队的队尾。
输入每个团队中所有队员的编号,要求支持如下3种指令(前两种指令可以穿插进
行)。
ENQUEUEx:编号为x的人进入长队。
DEQUEUE:长队的队首出队。
STOP:停止模拟。
对于每个DEQUEUE指令,输出出队的人的编号。
Sample Input
2
3 101 102 103
3 201 202 203
ENQUEUE 101
ENQUEUE 201
ENQUEUE 102
ENQUEUE 202
ENQUEUE 103
ENQUEUE 203
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
STOP
2
5 259001 259002 259003 259004 259005
6 260001 260002 260003 260004 260005 260006
ENQUEUE 259001
ENQUEUE 260001
ENQUEUE 259002
ENQUEUE 259003
ENQUEUE 259004
ENQUEUE 259005
DEQUEUE
DEQUEUE</description>
    </item>
    
    <item>
      <title>UVA 548 - Tree(树) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-548-tree%E6%A0%91-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-548-tree%E6%A0%91-by-sucicada/</guid>
      <description>例题6-8 树（Tree, UVa 548）
给一棵点带权（权值各不相同，都是小于10000的正整数）的二叉树的中序和后序遍
历，找一个叶子使得它到根的路径上的权和最小。如果有多解，该叶子本身的权应尽量小。
输入中每两行表示一棵树，其中第一行为中序遍历，第二行为后序遍历。
样例输入：
3 2 1 4 5 7 6
3 1 2 5 6 7 4
7 8 11 3 5 16 12 18
8 3 11 7 16 18 12 5
255
255
样例输出：
1
3
255
本家地址
在根据中序和后序遍历进行构造的时候，同时计算叶子的权值和，比较选择最小的权值的叶子，记录最小权值和的叶子和权值和。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;sstream&amp;gt; #include&amp;lt;cstring&amp;gt; using namespace std; int inorder[10004]; int postorder[10004]; int inindex[10004]; int min_top_value = 100000004; // 最小的权和 int loft = -1; // 叶子本身的值, /* 参数: 当前子树的 中序前,后 后序前,后 */ int calcul(int in_begin, int in_end, int post_begin, int post_end, int alculate_root_value){ // in_end - in_begin == post_end - post_begin int root_value = postorder[post_end]; // 根, 从后序 int root_in_index = inindex[root_value];//fin_inorder(in_begin, in_end, root_value); alculate_root_value = alculate_root_value + root_value; // 新的累计根值, 加上自己身上的 if(in_end &amp;lt;= in_begin){ // 叶子了 if(loft == -1 || // 第一个叶子 (alculate_root_value &amp;lt; min_top_value) || (alculate_root_value == min_top_value &amp;amp;&amp;amp; inorder[in_begin] &amp;lt; loft) ) { min_top_value = alculate_root_value; loft = inorder[in_begin]; } return 0; } int len = root_in_index-1-in_begin; if(root_in_index &amp;gt; in_begin){ calcul(in_begin, root_in_index-1, post_begin, post_begin + len, alculate_root_value); // 左枝 } len = in_end - root_in_index-1; if(root_in_index &amp;lt; in_end){ calcul(root_in_index+1, in_end, post_end-1-len , post_end-1, alculate_root_value); // 右枝 } return 0; } void init(){ memset(inorder,0,sizeof(inorder)); memset(postorder,0,sizeof(postorder)); memset(inindex,0,sizeof(inindex)); min_top_value = 100000004; // 最小的权和 loft = -1; // 叶子本身的值 } int main() { int row = 0; string line; while(getline(cin,line)){ // cout&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&amp;#34; &amp;#34;; stringstream ss(line); int i=0; int n; if(row==0){ // 新的一组, 要初始化 // 代表是一组中的第一行,即中序遍历 init(); while(ss&amp;gt;&amp;gt;n){ inorder[i] = n; inindex[n] = i; i++; } row = 1; }else{ // 一组中的第二行, 即后序遍历 while(ss&amp;gt;&amp;gt;n){ postorder[i++] = n; } row = 0; calcul(0,i-1,0,i-1,0); cout&amp;lt;&amp;lt;loft&amp;lt;&amp;lt;endl; } return 0; } // AC at 2020/03/21 ps：债还清了，这个代码提交了12次数，uva因为赞助商跑路的关系（不知道也没有关系），感觉现在更加慢了。网站首页筹集代码贡献。也想做点贡献，但是C++的网站。。。</description>
    </item>
    
    <item>
      <title>UVA 572 - Oil Deposits (油田) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-572-oil-deposits-%E6%B2%B9%E7%94%B0-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-572-oil-deposits-%E6%B2%B9%E7%94%B0-by-sucicada/</guid>
      <description>例题6-12 油田（Oil Deposits, UVa 572）
输入一个m行n列的字符矩阵，统计字符“@”组成多少个八连块。如果两个字符“@”所在
的格子相邻（横、竖或者对角线方向），就说它们属于同一个八连块。例如，图6-9中有两
个八连块。
Sample Input
1 1
*
3 5
@@*
@
@@*
1 8
@@***@
5 5
****@
@@@
@**@
@@@@
@@**@
0 0
Sample Output
0
1
2
2
本家连接
恩，嘛，遍历跑呗。反正到处都有。
#include&amp;lt;iostream&amp;gt; using namespace std; char oil[110][110]; int sum=0; int length,width; int isOil=0; void show(){ for(int i=0;i&amp;lt;length;i++){ for(int j=0;j&amp;lt;width;j++) cout&amp;lt;&amp;lt;oil[i][j]; cout&amp;lt;&amp;lt;endl; } // cout&amp;lt;&amp;lt;&amp;#34;========================&amp;#34;&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;endl; } int dfs(int x,int y){ char plot = oil[x][y]; if(x&amp;lt;0 || x&amp;gt;=length || y&amp;lt;0 || y&amp;gt;=width || plot!</description>
    </item>
    
    <item>
      <title>UVA 679 - Dropping Balls (小球下落) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-679-dropping-balls-%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-679-dropping-balls-%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD-by-sucicada/</guid>
      <description>例题6-6 小球下落（Dropping Balls, UVa 679）
有一棵二叉树，最大深度为D，且所有叶子的深度都相同。所有结点从上到下从左到右
编号为1, 2, 3,…, 2D-1。在结点1处放一个小球，它会往下落。每个内结点上都有一个开关，
初始全部关闭，当每次有小球落到一个开关上时，状态都会改变。当小球到达一个内结点
时，如果该结点上的开关关闭，则往左走，否则往右走，直到走到叶子结点，如图所
示。
一些小球从结点1处依次开始下落，最后一个小球将会落到哪里呢？输入叶子深度D和
小球个数I，输出第I个小球最后所在的叶子编号。假设I不超过整棵树的叶子个数。D≤20。
输入最多包含1000组数据。
样例输入：
6
4 2
3 4
10 1
2 2
8 128
16 12345
-1
样例输出：
12
7
512
3
255
36358
本家链接
最简单能想到的就是模拟，模拟球的下落，但是输入一旦大了就超时了。 所以我们可以，找规律。 首先假设有6层，我们来扔球看看情况
球数 落下位置（最后一行,第一个为0计数） 0 0 1 16 2 8 3 24 4 4 5 20 6 12 7 28 8 2 9 18 10 10 11 26 12 6 13 22 14 14 15 30 --- 16 1 17 17 18 9 19 25 20 5 21 21 22 13 23 29 24 3 25 19 26 11 27 27 28 7 29 23 30 15 31 31 ==== 第33开始轮回 === 32 0 33 16 34 8 35 24 36 4 37 20 38 12 39 28 发现规律了吧。</description>
    </item>
    
    <item>
      <title>UVA 699 - The Falling Leaves (落叶) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-699-the-falling-leaves-%E8%90%BD%E5%8F%B6-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-699-the-falling-leaves-%E8%90%BD%E5%8F%B6-by-sucicada/</guid>
      <description>例题6-10 下落的树叶（The Falling Leaves, UVa 699）
给一棵二叉树，每个结点都有一个水平位
置：左子结点在它左边1个单位，右子结点在右
边1个单位。从左向右输出每个水平位置的所有
结点的权值之和。如图6-7所示，从左到右的3个
位置的权和分别为7，11，3。按照递归（先序）
方式输入，用-1表示空树。
样例输入：
5 7 -1 6 -1 -1 3 -1 -1
8 2 9 -1 -1 6 5 -1 -1 12 -1
-1 3 7 -1 -1 -1
-1
样例输出：
Case 1:
7 11 3
Case 2:
9 7 21 15
【注意】 一棵树的输[入可能分为多行。输出最多一行80个（代表树最多80列）
本家地址
一边输入一边记录左右结点的值，放在数组中叠加。唯一的问题就是存在左右子树，无法确定左右范围具体为多少，所以可以采用两种方法：
设定一个最大的范围，80*2-1 范围，选择最中点为root结点，然后左右放置子节点。 将左右子树分开存放，右子树包含根节点，放置一个数组，下标递增代表结点向右扩增。将左子树放置另一个数组，下标递增代表结点向左扩增。如果以根节点为坐标轴0，那么左子树放置的坐标中就是反坐标轴，只是方向相反。 我采用第2种，因为一开始不知道范围（貌似）
#include&amp;lt;iostream&amp;gt; #include&amp;lt;cmath&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;cstring&amp;gt; using namespace std; int leftTree[100] = {0}; int rightTree[100] = {0}; /* include root */ int leftIndex = 0; int rightIndex = 0; char c; int tree(int index){ int n; cin&amp;gt;&amp;gt;n; if(n!</description>
    </item>
    
    <item>
      <title>UVA 816 - Abbott‘s Revenge (Abbott的复仇) By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-816-abbotts-revenge-abbott%E7%9A%84%E5%A4%8D%E4%BB%87-by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-816-abbotts-revenge-abbott%E7%9A%84%E5%A4%8D%E4%BB%87-by-sucicada/</guid>
      <description>例题6-14 Abbott的复仇（Abbott&amp;rsquo;s Revenge, ACM/ICPC World Finals 2000, UVa 816）
有一个最多包含9*9个交叉点的迷宫。输入起点、离开起点时的朝向和终点，求一条最
短路（多解时任意输出一个即可）。
图6-14 迷宫及走向
这个迷宫的特殊之处在于：进入一个交叉点
的方向（用NEWS这4个字母分别表示北东西
南，即上右左下）不同，允许出去的方向也不
同。例如，1 2 WLF NR ER 表示交叉点(1,2)
（上数第1行，左数第2列）有3个路标（字
符“”只是结束标志），如果进入该交叉点时的
朝向为W（即朝左），则可以左转（L）或者直
行（F）；如果进入时朝向为N或者E则只能右转
（R），如图6-14所示。
注意：初始状态是“刚刚离开入口”，所以即
使出口和入口重合，最短路也不为空。例如，图
6-14中的一条最短路为(3,1) (2,1) (1,1) (1,2)
(2,2) (2,3) (1,3) (1,2) (1,1) (2,1) (2,2) (1,2) (1,3) (2,3) (3,3)。
Sample Input
SAMPLE
3 1 N 3 3
1 1 WL NR *
1 2 WLF NR ER *
1 3 NL ER *
2 1 SL WR NF *</description>
    </item>
    
    <item>
      <title>UVA 839 - Not so Mobile （天平）By SuCicada</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-839-not-so-mobile-%E5%A4%A9%E5%B9%B3by-sucicada/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-839-not-so-mobile-%E5%A4%A9%E5%B9%B3by-sucicada/</guid>
      <description>例题6-9 天平（Not so Mobile, UVa 839）
输入一个树状天平，根据力矩相等原则判断是否平衡。如图6-5所示，所谓力矩相等，
就是WlDl=WrDr，其中Wl和Wr分别为左右两边砝码的重量，D为距离。
采用递归（先序）方式输入：每个天平的格式为Wl，Dl，Wr，Dr，当Wl或Wr为0时，表
示该“砝码”实际是一个子天平，接下来会描述这个子天平。当Wl=Wr=0时，会先描述左子天
平，然后是右子天平。
样例输入：
1
0 2 0 4
0 3 0 1
1 1 1 1
2 4 4 2
1 6 3 2
Sample Output
YES
【注意】 输出结果之间空一行
本家地址
递归走，一边输入每一结点，一边递归判断这个结点的左结点结果（左子树重量总和）和右结点结果（右子树重量总和）是否满足要求。
这样的话在建立树的时候也就直接计算结束了。
#include&amp;lt;iostream&amp;gt; using namespace std; int lair(){ int wl,dl,wr,dr; cin&amp;gt;&amp;gt;wl&amp;gt;&amp;gt;dl&amp;gt;&amp;gt;wr&amp;gt;&amp;gt;dr; if(wl == 0){ /* have left branch */ wl = lair(); } if(wr == 0){ wr = lair(); } if(wl==0 || wr==0 || wl*dl !</description>
    </item>
    
    <item>
      <title>UVa Online Judge 西班牙Valladolid 在线判官 和 uDebug使用简单教程</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva-online-judge-%E8%A5%BF%E7%8F%AD%E7%89%99valladolid-%E5%9C%A8%E7%BA%BF%E5%88%A4%E5%AE%98-%E5%92%8C-udebug%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva-online-judge-%E8%A5%BF%E7%8F%AD%E7%89%99valladolid-%E5%9C%A8%E7%BA%BF%E5%88%A4%E5%AE%98-%E5%92%8C-udebug%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</guid>
      <description>udebug使用在后面
https://uva.onlinejudge.org/
1、这是主界面，如果你还没有账号，那么就点击图中的register。
2、然后就是填写信息，邮箱要用gmail，信息填写完成后点击下方的register
3、之后打开邮箱查看接受的邮件，并点击其中的链接完成注册确认，之后会转到uva oj，如果页面显示 your account is now active.You may now log in!则表示注册完成。
4、然后输入用户名密码登录
5、然后在左边的栏目中，点击Browse Problems 就可以找到有关刘汝佳以及其他一些著名套题了。
6、然后是关于如何答题，现在我们打开了一道题目，看图上红框住的左上角，
（1）其中我们点击PDF，会下载下来本道题的pdf格式文件
（2）我们点击submit就是提交代码了。
其中如果是用的C语言或C++选择第一个c++，提交结果没有ac，如果不是代码问题，那么试试选择c++11吧。
参考了UVAOJ的注册和评测入门
（3）最后我想说一下在看题界面的那个Debug选项，就是旁边有个红色的甲虫的。
若果打不开udebug就挂vpn试试吧
https://www.udebug.com/UVa/1589 （当前是1589号题）
我们点进去后，一共四部分。上左边就是一些用户上传的关于本题的一些样例。点击其中一个，这些样例就会显示在右边的框中。
然后我们点击下方写着Get Accepted Output蓝格，就会在下方的左边出现这些样例的正确输出结果。我们可以把这些样例用我们的代码输出的结果粘到右边的框中。之后点击Compare Outputs 进行对比。
这样我就能很方便的知道我们的代码在处理哪一个样例上出现里问题，更改起来也更有方向性。还有如果出现了图中的情况，明明都对但还是显示不对，那是因为他的输出默认多了一个空行，这个一般和代码没有关系。默认为对就行了。
我们还可以在上面快速搜索你需要的题号。
目前支持这些oj
这是主页https://www.udebug.com/
可以去他的Twitter和Facebook上看看，网上关于udegug的信息不多。</description>
    </item>
    
    <item>
      <title>uva1583 - Digit Generator （生成元）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva1583-digit-generator-%E7%94%9F%E6%88%90%E5%85%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva1583-digit-generator-%E7%94%9F%E6%88%90%E5%85%83/</guid>
      <description>如果x加上x的各个数字之和得到y，就说x是y的生成元。给出n（1≤n≤100000），求最小
生成元。无解输出0。例如，n=216，121，2005时的解分别为198，0，1979。
Sample Input
3
216
121
2005
Sample Output
198
0
1979
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=829&amp;amp;page=show_problem&amp;amp;problem=4458
//先算出所有的生成元x的原数y，以s[y]=x的形式将其存起，在求y的解x的时候，直接输出是s[y]即可 //所以为了求最小生成元也就是x，就要从尾到头的循环算y。 #include&amp;lt;iostream&amp;gt; #include&amp;lt;cstdio&amp;gt; #include&amp;lt;string.h&amp;gt; using namespace std; int const N = 100000; int sn[N+5]={0}; int main() { memset(sn,0,sizeof(sn)); for(int i=N;i&amp;gt;=0;i--) { int n=i; int s=i; while(n&amp;gt;0) { s+=n%10; n/=10; } sn[s]=i; } //for(int i=0;i&amp;lt;N;i++) // cout&amp;lt;&amp;lt;sn[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; // cout&amp;lt;&amp;lt;endl; int n,T; cin&amp;gt;&amp;gt;T; while(T--) { int i; cin&amp;gt;&amp;gt;n; cout&amp;lt;&amp;lt;sn[n]&amp;lt;&amp;lt;endl; } return 0; } //AC at 2017/12/7 以下算法虽然一样可以算出正确答案，但是超时，oj不通过。</description>
    </item>
    
    <item>
      <title>uva272 （TeX）</title>
      <link>https://sucicada.github.io/blog/posts/uvaoj/uva272-tex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/uvaoj/uva272-tex/</guid>
      <description>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=829&amp;amp;page=show_problem&amp;amp;problem=208
TEX is a typesetting language developed by Donald Knuth. It takes source text together with a few
typesetting instructions and produces, one hopes, a beautiful document. Beautiful documents use “
and ” to delimit quotations, rather than the mundane &amp;quot; which is what is provided by most keyboards.
Keyboards typically do not have an oriented double-quote, but they do have a left-single-quote and a right-single-quote &#39;. Check your keyboard now to locate the left-single-quote key (sometimes</description>
    </item>
    
    <item>
      <title>virtualbox 发送 ctrl alt fn组合键的方法：使用热键（默认右ctrl）&#43;fn即可</title>
      <link>https://sucicada.github.io/blog/posts/soft/virtualbox-%E5%8F%91%E9%80%81-ctrl-alt-fn%E7%BB%84%E5%90%88%E9%94%AE%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E7%83%AD%E9%94%AE%E9%BB%98%E8%AE%A4%E5%8F%B3ctrl&#43;fn%E5%8D%B3%E5%8F%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/virtualbox-%E5%8F%91%E9%80%81-ctrl-alt-fn%E7%BB%84%E5%90%88%E9%94%AE%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E7%83%AD%E9%94%AE%E9%BB%98%E8%AE%A4%E5%8F%B3ctrl&#43;fn%E5%8D%B3%E5%8F%AF/</guid>
      <description>一般是用来在虚拟机中切换文字模式和图像化窗口模式的。
如果直接使用ctrl+alt+fn可能会触发主机的组合键。
所以使用热键+fn</description>
    </item>
    
    <item>
      <title>Visual Stdio Code 运行生成任务  输出不了</title>
      <link>https://sucicada.github.io/blog/posts/soft/visual-stdio-code-%E8%BF%90%E8%A1%8C%E7%94%9F%E6%88%90%E4%BB%BB%E5%8A%A1-%E8%BE%93%E5%87%BA%E4%B8%8D%E4%BA%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/visual-stdio-code-%E8%BF%90%E8%A1%8C%E7%94%9F%E6%88%90%E4%BB%BB%E5%8A%A1-%E8%BE%93%E5%87%BA%E4%B8%8D%E4%BA%86/</guid>
      <description>刚刚解决了pip安装的问题，现在打开vscode又出现了问题。
我像平常一样按下ctrl+shift+B 运行我的python文件
但是结果就像我用vc写C语言一样，闪过一个黑窗口的终端界面，然后就没了。没有输出，控制台界面也没有停下来让我好好看看。
我查了查，没有结果。
然后灵机一动，我知道怎么回事了。都怪我手贱，将python.exe这个文件设置成了默认管理员模式运行。
我不知道为什么，反正我取消了管理员模式运行就好了。</description>
    </item>
    
    <item>
      <title>windows 一键切换ip dns脚本</title>
      <link>https://sucicada.github.io/blog/posts/soft/windows-%E4%B8%80%E9%94%AE%E5%88%87%E6%8D%A2ip-dns%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/windows-%E4%B8%80%E9%94%AE%E5%88%87%E6%8D%A2ip-dns%E8%84%9A%E6%9C%AC/</guid>
      <description>下载bat脚本
https://github.com/SuCicada/ipswitch
然后运行,按照提示输入即可
@echo off&amp;amp;color 1E&amp;amp;title IP地址快速切换器 echo ┌────────────────────────────┐ echo ｜ ｜ echo ｜ 切换网络环境，请输入当前所在位置 │ echo ｜ ｜ echo └────────────────────────────┘ &amp;gt;nul 2&amp;gt;&amp;amp;1 &amp;#34;%SYSTEMROOT%\system32\cacls.exe&amp;#34; &amp;#34;%SYSTEMROOT%\system32\config\system&amp;#34; :choice set choice= set /p choice=【外网】请选择1，【内网】请选择2 :[1,2]? if %choice%==2 goto school_lan if %choice%==1 (goto lab_lan) else (echo 输入错误，请重新输入&amp;amp;goto choice) :lab_lan set eth=&amp;#34;本地连接&amp;#34; set ip=10.0.0. set netmask=255.255.255.0 set gw=10.0.0.1 set dns1=8.8.8.8 set dns2= echo. echo 切换到外网有线环境 echo. goto switch :school_lan set eth=&amp;#34;本地连接&amp;#34; set ip=10.90.6. set netmask=255.255.255.0 set gw=10.</description>
    </item>
    
    <item>
      <title>WSL2 -- Windows10 环境中运行 Linux （无缝衔接，开发利器）</title>
      <link>https://sucicada.github.io/blog/posts/soft/wsl2--windows10-%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%90%E8%A1%8C-linux-%E6%97%A0%E7%BC%9D%E8%A1%94%E6%8E%A5%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/wsl2--windows10-%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%90%E8%A1%8C-linux-%E6%97%A0%E7%BC%9D%E8%A1%94%E6%8E%A5%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8/</guid>
      <description>WSL2 是什么 全称为 Windows Subsystem for Linux2。是一个能在Windows上运行Linux运行环境的工具。是WSL的第二代。
简单来说就是Windows下的Linux虚拟机。
比虚拟机好在哪里 启动速度超快。文件访问跨系统访问无限制（因为两个系统之间的目录是通过网络映射挂载的） Windows、Linux 命令混合使用。无论在哪个系统的终端，都可以使用另一个系统的命令。（比如在Linux中使用explorer.exe . 看看会发生什么） 比WSL1好在哪 最主要体现在网络隔离、以及进程管理（比如ps）。
WSL2使用类似NAT的虚拟机网络模式。这样的好处就是Linux和Windows的网段是隔离的。
而WSL1更像是运行在Windows上的一个程序，所以网络IP、端口、进程状态等都是用的Windows宿主机。
所以这么来看WSL2更像是纯粹的一个虚拟机了。
安装&amp;amp;配置 在 Windows 中运行 Linux：WSL 2 使用入门
適用於Linux的Windows子系統(Windows Subsystem for Linux；WSL)
进阶提升效率 Windows Terminal
比PowerShell 更好用、更美观的Windows终端。支持窗口多开，WSL直开。
玩转WSL(2)之安装并配置Windows Terminal
Ctrl+Alt+T 开启终端。
下载WinHotKey，设置Windows Terminal默认窗口为WSL。
体验原生Linux终端的快感。
肯定有用的脚本 todo 衍生资源 WSL 和 WSL2 简单对比</description>
    </item>
    
    <item>
      <title>三柱体hanoi问题（C_C&#43;&#43;语言版）</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E4%B8%89%E6%9F%B1%E4%BD%93hanoi%E9%97%AE%E9%A2%98c_c&#43;&#43;%E8%AF%AD%E8%A8%80%E7%89%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E4%B8%89%E6%9F%B1%E4%BD%93hanoi%E9%97%AE%E9%A2%98c_c&#43;&#43;%E8%AF%AD%E8%A8%80%E7%89%88/</guid>
      <description>控制台运行输入数据格式 ： xxx（程序名） 3（汉诺塔层数）
会显示出每一步的移动步骤，以及每一柱上留有的盘数
#include&amp;lt;iostream&amp;gt; #include&amp;lt;sstream&amp;gt; using namespace std; int a=0,b=0,c=0; void hno(int n,char from,char mid,char to) { if(n&amp;gt;1) { hno(n-1,from,to,mid); hno(1,from,mid,to); hno(n-1,mid,from,to); } else { switch(from) { case &amp;#39;A&amp;#39;:a--;break; case &amp;#39;B&amp;#39;:b--;break; case &amp;#39;C&amp;#39;:c--;break; } switch(to) { case &amp;#39;A&amp;#39;:a++;break; case &amp;#39;B&amp;#39;:b++;break; case &amp;#39;C&amp;#39;:c++;break; } cout&amp;lt;&amp;lt;from&amp;lt;&amp;lt;&amp;#34;--&amp;gt;&amp;#34;&amp;lt;&amp;lt;to&amp;lt;&amp;lt;&amp;#34; A:&amp;#34;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;#34; B:&amp;#34;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;&amp;#34; C:&amp;#34;&amp;lt;&amp;lt;c&amp;lt;&amp;lt;endl; } } int main(int argc,char *argv[]) { // cout&amp;lt;&amp;lt;argc&amp;lt;&amp;lt;endl; // cout&amp;lt;&amp;lt;&amp;#34;_&amp;#34;&amp;lt;&amp;lt;argv[1]&amp;lt;&amp;lt;&amp;#34;_&amp;#34;&amp;lt;&amp;lt;endl; // return 0; stringstream s; int n;//=*argv[1]; s&amp;lt;&amp;lt;argv[1]; s&amp;gt;&amp;gt;n; //cin&amp;gt;&amp;gt;n; a=n; //hno(n,) hno(n,&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;); return 0; } </description>
    </item>
    
    <item>
      <title>三柱汉诺塔问题（Python版）</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E4%B8%89%E6%9F%B1%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98python%E7%89%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E4%B8%89%E6%9F%B1%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98python%E7%89%88/</guid>
      <description>思路一样
def move(n, a, b, c): if(n&amp;gt;1): move(n-1,a,c,b) move(1,a,b,c) move(n-1,b,a,c) else: print a,&amp;#39;--&amp;gt;&amp;#39;,c n = input(&amp;#39;input a number&amp;#39;) #int(raw_input()) move(n, &amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;) </description>
    </item>
    
    <item>
      <title>修改 linux、ubuntu 默认终端，外加terminator颜色方案</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E4%BF%AE%E6%94%B9-linuxubuntu-%E9%BB%98%E8%AE%A4%E7%BB%88%E7%AB%AF%E5%A4%96%E5%8A%A0terminator%E9%A2%9C%E8%89%B2%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E4%BF%AE%E6%94%B9-linuxubuntu-%E9%BB%98%E8%AE%A4%E7%BB%88%E7%AB%AF%E5%A4%96%E5%8A%A0terminator%E9%A2%9C%E8%89%B2%E6%96%B9%E6%A1%88/</guid>
      <description>需求：使用 cinnamon 桌面，想要修改右键打开的终端为terminator
先安装 dconf-tools
sudo apt-get install dconf-tools 依次进入
org -&amp;gt; cinnamon -&amp;gt; desktop -&amp;gt; default-applications -&amp;gt; terminal
然后将键值改成你想要的
比如terminator为
key value exec: x-terminal-emulator exec-arg: -e 最后来一个一键脚本
gsettings set org.gnome.desktop.default-applications.terminal exec /usr/bin/x-terminal-emulator gsettings set org.gnome.desktop.default-applications.terminal exec-arg &amp;#34;-e&amp;#34; terminator颜色方案
配置文件 ~/.config/terminator/config
[global_config] always_split_with_profile = True enabled_plugins = LaunchpadCodeURLHandler, APTURLHandler, LaunchpadBugURLHandler focus = system geometry_hinting = False handle_size = 2 inactive_color_offset = 1.0 title_font = mry_KacstQurn Bold 11 title_hide_sizetext = True title_receive_bg_color = &amp;#34;#729fcf&amp;#34; [keybindings] paste = &amp;lt;Primary&amp;gt;v [layouts] [[default]] [[[child1]]] parent = window0 profile = default type = Terminal [[[window0]]] parent = &amp;#34;&amp;#34; type = Window [plugins] [profiles] [[default]] background_color = &amp;#34;#3e3535&amp;#34; background_darkness = 0.</description>
    </item>
    
    <item>
      <title>关于 1.0_0.0 以及 0.0_0.0 的值</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8E-1.0_0.0-%E4%BB%A5%E5%8F%8A-0.0_0.0-%E7%9A%84%E5%80%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8E-1.0_0.0-%E4%BB%A5%E5%8F%8A-0.0_0.0-%E7%9A%84%E5%80%BC/</guid>
      <description>#include&amp;lt;cstdio&amp;gt; #include&amp;lt;iostream&amp;gt; using namespace std; int main() { printf(&amp;#34;%d\n&amp;#34;,1.0/0.0);//0 printf(&amp;#34;%d\n&amp;#34;,0.0/0.0);//0 printf(&amp;#34;%lld\n&amp;#34;,1.0/0.0);//9218868437227405312 printf(&amp;#34;%lld\n&amp;#34;,0.0/0.0);//-2251799813685248 printf(&amp;#34;%lf\n&amp;#34;,1.0/0.0);//1.#INF00 printf(&amp;#34;%lf\n&amp;#34;,0.0/0.0);//-1.#INF00 cout&amp;lt;&amp;lt;1.0/0.0&amp;lt;&amp;lt;endl;//inf cout&amp;lt;&amp;lt;0.0/0.0&amp;lt;&amp;lt;endl;//nan return 0; } </description>
    </item>
    
    <item>
      <title>关于 Flink1.11.1 找不到 Hadoop Native库解决方法</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/%E5%85%B3%E4%BA%8E-flink1.11.1-%E6%89%BE%E4%B8%8D%E5%88%B0-hadoop-native%E5%BA%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/%E5%85%B3%E4%BA%8E-flink1.11.1-%E6%89%BE%E4%B8%8D%E5%88%B0-hadoop-native%E5%BA%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>可以试试在 flink 的 conf/flink-conf.yaml 配置文件中加入配置如下
其中的native库的具体路径换成你自己的。
yarn.application-master.env.LD_LIBRARY_PATH: /opt/cloudera/parcels/CDH/lib/hadoop/lib/native:$LD_LIBRARY_PATH yarn.taskmanager.env.LD_LIBRARY_PATH: /opt/cloudera/parcels/CDH/lib/hadoop/lib/native:$LD_LIBRARY_PATH </description>
    </item>
    
    <item>
      <title>关于Flink 本地测试，自定义WebUI 端口的方法</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/%E5%85%B3%E4%BA%8Eflink-%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E8%87%AA%E5%AE%9A%E4%B9%89webui-%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/%E5%85%B3%E4%BA%8Eflink-%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E8%87%AA%E5%AE%9A%E4%B9%89webui-%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>以1.11.1版本举例，相差不大的版本之间大同小异。
先给成品：以Scala代码举例，Java大同小异。
通过反射将配置加入env的配置对象中。之后使用修改过的env来创建flink的任务流即可。
val env = StreamExecutionEnvironment.getExecutionEnvironment val javaEnv: environment.StreamExecutionEnvironment = env.getJavaEnv val field = classOf[org.apache.flink.streaming.api.environment.StreamExecutionEnvironment].getDeclaredField(&amp;#34;configuration&amp;#34;) field.setAccessible(true) import org.apache.flink.configuration.Configuration val configuration: Configuration = field.get(javaEnv).asInstanceOf[Configuration] configuration.setString(&amp;#34;rest.bind-port&amp;#34;, &amp;#34;8081&amp;#34;) 下面是探索过程，没兴趣的可以过了。
当我们加入了pom依赖后.发现能够看到本地IDE中的flink的webUI了.
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;flink-runtime-web_2.11&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${flink.version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 根据日志中显示可知我们的本地web端口为16434. 这不是一个我们想要看到的. 而且每一次运行都会产生一个随机的端口.这实在很痛苦.
17:15:28,577 INFO org.apache.flink.runtime.dispatcher.DispatcherRestEndpoint - Rest endpoint listening at localhost:16434 17:15:28,578 INFO org.apache.flink.runtime.highavailability.nonha.embedded.EmbeddedLeaderService - Proposing leadership to contender http://localhost:16434 17:15:28,581 INFO org.apache.flink.runtime.dispatcher.DispatcherRestEndpoint - Web frontend listening at http://localhost:16434 17:15:28,581 INFO org.apache.flink.runtime.dispatcher.DispatcherRestEndpoint - http://localhost:16434 was granted leadership with leaderSessionID=eb84fead-f735-4350-aff4-a7f883013432 所以我们要想办法来固定端口.</description>
    </item>
    
    <item>
      <title>关于Flink写入Redis没有incrByFloat等方法的解决措施</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/%E5%85%B3%E4%BA%8Eflink%E5%86%99%E5%85%A5redis%E6%B2%A1%E6%9C%89incrbyfloat%E7%AD%89%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%8E%AA%E6%96%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/%E5%85%B3%E4%BA%8Eflink%E5%86%99%E5%85%A5redis%E6%B2%A1%E6%9C%89incrbyfloat%E7%AD%89%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%8E%AA%E6%96%BD/</guid>
      <description>首当其冲：改源码。
使用的是org.apache.bahir:flink-connector-redis_2.11
目前2020年8月中maven官方库中最新的版本只有1.0。此版本未提供incrByFloat的方法。
首先猜测可能maven库不是最新的。去到此项目的github上一看。居然是1.1-SNAPSHOT的版本。但是此版本中仍然没有找到incrByFloat。
所以我们可以使用改源码重新编译的方式来解决这个问题。org.apache.flink:flink-connector-redis_2.11库与其类似。好在这个库比较简单，不需要做结构性的改动。
本博客意在记录需要改动源码的地方。
org.apache.flink.streaming.connectors.redis.common.container.RedisCommandsContainer
redis的操作接口，在这里添加void incrByFloat(String key, Double value);
的接口定义。 操作接口的实现有2处。org.apache.flink.streaming.connectors.redis.common.container.RedisClusterContainer和org.apache.flink.streaming.connectors.redis.common.container.RedisContainer
加入incrByFloat实现：（写法完全照抄其他方法实现） @Override public void incrByFloat(String key, Double value) { Jedis jedis = null; try { jedis = getInstance(); jedis.incrByFloat(key, value); } catch (Exception e) { if (LOG.isErrorEnabled()) { LOG.error(&amp;#34;Cannot send Redis message with command INCRBYFLOAT to key {} and value {} error message {}&amp;#34;, key, value, e.getMessage()); } throw e; }finally { releaseInstance(jedis); } } org.apache.flink.streaming.connectors.redis.common.mapper.RedisCommand</description>
    </item>
    
    <item>
      <title>关于linux 下pycharm 输入法不跟随的问题(未解决)</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8Elinux-%E4%B8%8Bpycharm-%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8D%E8%B7%9F%E9%9A%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%9C%AA%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8Elinux-%E4%B8%8Bpycharm-%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8D%E8%B7%9F%E9%9A%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%9C%AA%E8%A7%A3%E5%86%B3/</guid>
      <description>http://tieba.baidu.com/p/3858968877#70635782254l
https://neue.v2ex.com/t/306947
貌似linux无解</description>
    </item>
    
    <item>
      <title>关于linux上运行ONS</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8Elinux%E4%B8%8A%E8%BF%90%E8%A1%8Cons/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8Elinux%E4%B8%8A%E8%BF%90%E8%A1%8Cons/</guid>
      <description>https://tieba.baidu.com/p/5202079866?pv=1
用ONScripter
安装依赖库 sudo apt-get install libsdl1.2debian libsdl-sound1.2 libsdl-ttf2.0-0 libsdl-mixer1.2 libsdl-image1.2 libasound2 libjpeg62 libpng12-0 libvorbisfile3 libsmpeg0 libavifile-0.7c2 libbz2-1.0 libogg0</description>
    </item>
    
    <item>
      <title>关于Scala 的尾递归，使用JITWatch从字节码观察其原理</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/%E5%85%B3%E4%BA%8Escala-%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92%E4%BD%BF%E7%94%A8jitwatch%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%82%E5%AF%9F%E5%85%B6%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/%E5%85%B3%E4%BA%8Escala-%E7%9A%84%E5%B0%BE%E9%80%92%E5%BD%92%E4%BD%BF%E7%94%A8jitwatch%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%82%E5%AF%9F%E5%85%B6%E5%8E%9F%E7%90%86/</guid>
      <description>先说概念：
Scala的尾递归会被编译器自动优化成循环
主题直通车
先来简单看下一个简单验证方法 对比普通的递归： def fun2(x: Int): Int = { if (x == 1) throw new Exception(&amp;#34;nooo&amp;#34;) else fun2(x - 1) + 0 } 结果： Exception in thread &amp;#34;main&amp;#34; java.lang.Exception: nooo at Main$.fun2(Main.scala:17) at Main$.fun2(Main.scala:19) at Main$.fun2(Main.scala:19) at Main$.fun2(Main.scala:19) at Main$.fun2(Main.scala:19) 。。。。 at Main$.fun2(Main.scala:19) at Main$.main(Main.scala:25) at Main.main(Main.scala) 现象： 我们能看到在递归结束前，这个方法已经进入自己很多次了。
尾递归 def fun(x: Int): Int = { if (x == 0) throw new Exception(&amp;#34;nooo&amp;#34;) else fun(x - 1) } 结果：</description>
    </item>
    
    <item>
      <title>关于ssh scp 不用交互式 即自动或者带密码执行</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8Essh-scp-%E4%B8%8D%E7%94%A8%E4%BA%A4%E4%BA%92%E5%BC%8F-%E5%8D%B3%E8%87%AA%E5%8A%A8%E6%88%96%E8%80%85%E5%B8%A6%E5%AF%86%E7%A0%81%E6%89%A7%E8%A1%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8Essh-scp-%E4%B8%8D%E7%94%A8%E4%BA%A4%E4%BA%92%E5%BC%8F-%E5%8D%B3%E8%87%AA%E5%8A%A8%E6%88%96%E8%80%85%E5%B8%A6%E5%AF%86%E7%A0%81%E6%89%A7%E8%A1%8C/</guid>
      <description>sshpass方式
expect方式
第一种方式 通过 sshpass 来 sshpass -p &amp;#34;xxxx&amp;#34; ssh root@xxx.xx.xxx sshpass -p &amp;#34;xxxx&amp;#34; scp xxxx root@xxxx:/xxxxx 但是sshpass好像不能回显. 对于scp不太方便
但是对于ssh确实很好用的
第二种方式 通过expect
用法参考 比如使用ssh
#!/usr/bin/expect set timeout 30 spawn ssh root@sucicada.tk expect &amp;#34;password:&amp;#34; send &amp;#34;Ubuntu2019\n&amp;#34; interact 通过以上方式可以使用一个脚本就能登录到远程主机上了</description>
    </item>
    
    <item>
      <title>关于辗转相除</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8E%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8E%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4/</guid>
      <description>#include&amp;lt;iostream&amp;gt; using namespace std; int gcd(int a,int b,int&amp;amp; x,int &amp;amp;y){ if(b==0){ x = 1; y = 0; return a; } int q = gcd(b, a%b, y, x); // y 是给b用的 // a 是大的那个 y = (q-a*x)/b; cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl; return q; } int main(){ int x,y; int a=12; int b=32; gcd(a,b,x,y); } 这就是我这个菜鸡的代码备份，草我特么咋就这么笨</description>
    </item>
    
    <item>
      <title>关于阿里云的一些配置：</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/</guid>
      <description>先apt update 更新
作为
安装 nginx 反向代理服务器</description>
    </item>
    
    <item>
      <title>刘汝佳p35,2-5（分数化小数）算法竞赛入门经典第二版</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p352-5%E5%88%86%E6%95%B0%E5%8C%96%E5%B0%8F%E6%95%B0%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p352-5%E5%88%86%E6%95%B0%E5%8C%96%E5%B0%8F%E6%95%B0%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/</guid>
      <description>输入a，b，c，输出a/b的小数形式，精确到小数点后c位，a,b&amp;lt;=10^6,c&amp;lt;=100，以a=b=c=0结束，四舍五入
#include&amp;lt;stdio.h&amp;gt; int main() { int a,b,c,n=1; while(scanf(&amp;#34;%d%d%d&amp;#34;,&amp;amp;a,&amp;amp;b,&amp;amp;c)&amp;amp;&amp;amp;(a||b||c)) { printf(&amp;#34;Case %d: %d.&amp;#34;,n++,a/b);//整数位和小数点 for(int i=0;i&amp;lt;c-1;i++) { printf(&amp;#34;%d&amp;#34;,(a*10/b)%10); a=(a*10)%b;//为了不让a溢出，用a/b的余数来算并不影响结果 } printf(&amp;#34;%d\n&amp;#34;,((a*100/b)%100+5)/10);//最后一位四舍五入 } return 0; } 已经连这种简单的算法都要上网看别人写的了，自己想出来的都是错的，浪费了一个小时又。</description>
    </item>
    
    <item>
      <title>刘汝佳p35,2-6（123排列）算法竞赛入门经典第二版</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p352-6123%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p352-6123%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/</guid>
      <description>算法竞赛入门经典第二版
刘汝佳p35 , 2-6
用1,2,3，&amp;hellip;.，9组成3个三位数abc，def和ghi，每个数字恰好使用一次，要求abc:def:ghi=1:2:3。输出所有解。
#include&amp;lt;cstdio&amp;gt; #include&amp;lt;iostream&amp;gt; using namespace std; int nn(int a,int *n) { //cout&amp;lt;&amp;lt;&amp;#34;a&amp;#34;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl; for(int i=0;i&amp;lt;8;i++) { if(a==n[i]) { //cout&amp;lt;&amp;lt;n[i]&amp;lt;&amp;lt;endl; n[i]=-1; return 0; } } return 1; } void num(int a) { int n[9]; for(int i=0;i&amp;lt;8;i++) n[i]=i+1; int b=a*2; int c=a*3; int s[9]; s[0]=a/100; s[1]=(a/10)%10; s[2]=a%10; s[3]=b/100; s[4]=(b/10)%10; s[5]=b%10; s[6]=c/100; s[7]=(c/10)%10; s[8]=c%10; for(int i=0;i&amp;lt;8;i++) { //cout&amp;lt;&amp;lt;&amp;#34;si&amp;#34;&amp;lt;&amp;lt;s[i]&amp;lt;&amp;lt;endl; if(nn(s[i],n)==1) { //cout&amp;lt;&amp;lt;&amp;#34;return&amp;#34;&amp;lt;&amp;lt;endl; return; } } cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;c&amp;lt;&amp;lt;endl; } int main() { for(int a=100;a&amp;lt;=333;a++) { num(a); } return 0; } 所以结果是</description>
    </item>
    
    <item>
      <title>刘汝佳p39,3-2（开灯问题）算法竞赛入门经典第二版</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p393-2%E5%BC%80%E7%81%AF%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p393-2%E5%BC%80%E7%81%AF%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/</guid>
      <description>有n盏灯，编号为1～n，第1个人把所有灯打开，第2个人按下所有编号为2的倍数的开关（这些灯将被关掉），第3个人按下所有编号为3的倍数的开关（其中关掉的灯被打开， 开着灯将被关闭），依此类推。一共有k个人，问最后有哪些灯开着？
输入：n和k，输出开着的灯编号。k≤n≤1000。
样例输入：7 3
样例输出：1 5 6 7
（题目描述拷贝自http://blog.csdn.net/oceaniwater/article/details/40709609）
#include&amp;lt;stdio.h&amp;gt; int main() { int n,k,ni,ki,nii; //n=7;k=3; scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;n,&amp;amp;k); for(ni=1;ni&amp;lt;=n;ni++)//灯数 { nii=ni; for(ki=1;ki&amp;lt;=k;ki++)//每灯人数 { //printf(&amp;#34;%%%d &amp;#34;,nii%ki); if(nii%ki==0)//当前灯是否为当前人的倍数 { ni*=(-1);//负数为开，正数为灭 } //printf(&amp;#34;!%d\n&amp;#34;,ni); } if(ni&amp;lt;0) { printf(&amp;#34;%d &amp;#34;,ni*=-1); } } return 0; } </description>
    </item>
    
    <item>
      <title>刘汝佳p39,3-3（蛇形填数）算法竞赛入门经典第二版</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p393-3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p393-3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/</guid>
      <description>在nn方阵里填入1,2,„,nn，要求填成蛇形。例如n=4时方阵为
10 11 12 1
9 16 13 2
8 15 14 3
7 6 5 4
上面的方阵中，多余的空格只是为了便于观察规律，不必严格输出。n≤8。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;iomanip&amp;gt; using namespace std; int const N=120; int main() { int n[N][N]={0}; int m,mm; cin&amp;gt;&amp;gt;m; mm=m; int s=1,i,j; //s=n[i=0][j=m-1]=1; while(m--) { //m--; i=mm-m-1; j=m; while(i&amp;lt;=m-1 &amp;amp;&amp;amp;n[i][j]==0) n[i++][j]=s++;//right while(j&amp;gt;=mm-m &amp;amp;&amp;amp;n[i][j]==0) n[i][j--]=s++;//down while(i&amp;gt;=mm-m &amp;amp;&amp;amp;n[i][j]==0) n[i--][j]=s++;//left while(j&amp;lt;=m-1 &amp;amp;&amp;amp;n[i][j]==0) n[i][j++]=s++;//up if(s==mm*mm)n[i+1][j-1]=s; } for(i=0;i&amp;lt;mm;i++) { for(j=0;j&amp;lt;mm;j++) cout&amp;lt;&amp;lt;setw(3)&amp;lt;&amp;lt;n[i][j]; cout&amp;lt;&amp;lt;endl; } return 0; } </description>
    </item>
    
    <item>
      <title>刘汝佳p41,3-4（竖式问题）算法竞赛入门经典第二版</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p413-4%E7%AB%96%E5%BC%8F%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p413-4%E7%AB%96%E5%BC%8F%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/</guid>
      <description> 题目：
找出所有形如abc*de（三位数乘以两位数）的算式，使得在完整的竖式中，所有数字都属于一个特定的数字集合。输入数字集合（相邻数字之间没有空格），输出所有竖式。每个竖式前应有编号，之后应有一个空行。最后输出解的总数。具体格式见样例输出（为了便于观察，竖式中的空格改用小数点显示，但你的程序应该输出空格，而非小数点）。
样例输入：2357
样例输出：
&amp;lt;1&amp;gt;
..775
X..33
.&amp;mdash;&amp;ndash;
.2325
.&amp;mdash;&amp;ndash;
25575
The number of solutions = 1
分析：
尝试所有的abc和de，判断是否满足条件。
#include&amp;lt;iostream&amp;gt; #include&amp;lt;string.h&amp;gt; #include&amp;lt;cstdio&amp;gt; using namespace std; int main() { char s[15],f[25]; int n=1; cin&amp;gt;&amp;gt;s; for(int a=100;a&amp;lt;1000;a++) { for(int b=10;b&amp;lt;=99;b++) { int o=1; int x=a*(b%10),y=a*(b/10),z=a*b; sprintf(f,&amp;#34;%d%d%d%d%d&amp;#34;,a,b,x,y,z);//将abxyz输入到f中 for(int i=0;i&amp;lt;strlen(f);i++) if(strchr(s,f[i])==NULL) o=0; if(o) printf(&amp;#34;&amp;lt;%d&amp;gt;\n%5d\nX%4d\n-----\n%5d\n%4d \n-----\n%5d\n\n&amp;#34;,n++,a,b,x,y,z); } } cout&amp;lt;&amp;lt;&amp;#34;The number of solutions = &amp;#34;&amp;lt;&amp;lt;n-1&amp;lt;&amp;lt;endl; return 0; } </description>
    </item>
    
    <item>
      <title>判断字符是否为字母或数字</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%97%E6%AF%8D%E6%88%96%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%97%E6%AF%8D%E6%88%96%E6%95%B0%E5%AD%97/</guid>
      <description>参考：
C语言中isalnum()函数和isalpha()函数的对比使用
C语言 判断字符的大小写 isalpha()函数
#include&amp;lt;ctype.h&amp;gt;//或&amp;lt;cctype&amp;gt; int isalpha(int ch)//为英文字母时返回不一定为1的非零，否则返回零 isalnum(c)//判断c是否为英文字母或数字 isupper(c)//判断c是否为大写英文字母 islower(c)//判断c是否为小写英文字母 isdigit(c)//判断c是否为数字 以上若不是所判断字符类型则都返回零</description>
    </item>
    
    <item>
      <title>十六进制转十进制.h</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6.h/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6.h/</guid>
      <description>#include&amp;lt;stdio.h&amp;gt; #include&amp;lt;ctype.h&amp;gt; int sc(char a[])//传进来代表十六进制的字符串数组，返回十进制 { int i,n=0,t; for(i=0;a[i];i++) { a[i]=toupper(a[i]); if(a[i]&amp;gt;=&amp;#39;A&amp;#39;) t=a[i]-&amp;#39;A&amp;#39;+10; else t=a[i]-&amp;#39;0&amp;#39;; n=n*16+t; } return n; } </description>
    </item>
    
    <item>
      <title>啊</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%95%8A/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%95%8A/</guid>
      <description>Flume 的 发起：
org.apache.flume.node.Application
我们看最后这里
application.start(); final Application appReference = application; Runtime.getRuntime().addShutdownHook(new Thread(&amp;#34;agent-shutdown-hook&amp;#34;) { @Override public void run() { appReference.stop(); } }); </description>
    </item>
    
    <item>
      <title>在Linux Mint 19 _ Linux Mint 18上安装VirtualBox 6.0 _ 5.2</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%9C%A8linux-mint-19-_-linux-mint-18%E4%B8%8A%E5%AE%89%E8%A3%85virtualbox-6.0-_-5.2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%9C%A8linux-mint-19-_-linux-mint-18%E4%B8%8A%E5%AE%89%E8%A3%85virtualbox-6.0-_-5.2/</guid>
      <description>如果你直接可以
sudo apt-get install virtualbox-6.0那就相安无事
否则参考
https://www.itzgeek.com/how-tos/linux/linux-mint-how-tos/install-virtualbox-4-3-on-linux-mint-17.html
打开终端并将Oracle VirtualBox存储库的公钥导入您的系统。
wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -
使用以下命令添加VirtualBox存储库。
### Linux Mint 19 ###
echo“deb [arch = amd64] http://download.virtualbox.org/virtualbox/debian bionic contrib”| sudo tee /etc/apt/sources.list.d/virtualbox.list
### Linux Mint 18 ###
echo“deb http://download.virtualbox.org/virtualbox/debian xenial contrib”| sudo tee /etc/apt/sources.list.d/virtualbox.list
更新存储库索引数据库。
sudo apt-get update
使用apt命令安装VirtualBox。
VirtualBox 6.0：
sudo apt-get install -y virtualbox-6.0
VirtualBox 5.2：
sudo apt-get install -y virtualbox-5.2
经历:
先参看官网方法:https://www.virtualbox.org/wiki/Linux_Downloads
deb https://download.virtualbox.org/virtualbox/debian &amp;lt;mydist&amp;gt; contrib 增加源, &amp;lt;mydist&amp;gt; 里添加ubuntu的发行版 使用</description>
    </item>
    
    <item>
      <title>在树莓派 raspberrypi 系统中 安装rar unrar解压</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE-raspberrypi-%E7%B3%BB%E7%BB%9F%E4%B8%AD-%E5%AE%89%E8%A3%85rar-unrar%E8%A7%A3%E5%8E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE-raspberrypi-%E7%B3%BB%E7%BB%9F%E4%B8%AD-%E5%AE%89%E8%A3%85rar-unrar%E8%A7%A3%E5%8E%8B/</guid>
      <description>参考
https://raspberrypi.stackexchange.com/questions/3617/how-to-install-unrar-nonfree
1.卸载unrar-free。
$ sudo apt-get remove unrar-free
2.通过编辑确保您拥有源存储库/etc/apt/sources.list。
$ cat /etc/apt/sources.list
# Default repository
deb http://archive.raspbian.org/raspbian wheezy main contrib non-free rpi
# Source repository to add
deb-src http://archive.raspbian.org/raspbian wheezy main contrib non-free rpi
3.同步apt数据库。
$ sudo apt-get update
4.创建一个工作目录并移入其中。该unrar-nonfree命令将在此目录中构建。
$ cd $(mktemp -d)
5.安装所需的依赖项unrar-nonfree。
$ sudo apt-get build-dep unrar-nonfree
6.下载unrar-nonfree源代码并构建.deb软件包。
$ sudo apt-get source -b unrar-nonfree
7.安装生成的.deb包。它的名称取决于版本unrar-nonfree。
$ sudo dpkg -i unrar*.deb
如果第六步报错如下:
dpkg-buildpackage: info: binary-only upload (no source included) W: 由于文件&amp;#39;unrar-nonfree_5.</description>
    </item>
    
    <item>
      <title>如何在 ClassPathXmlApplicationContext 里使用相对类路径的 xml文件</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E5%A6%82%E4%BD%95%E5%9C%A8-classpathxmlapplicationcontext-%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E7%B1%BB%E8%B7%AF%E5%BE%84%E7%9A%84-xml%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E5%A6%82%E4%BD%95%E5%9C%A8-classpathxmlapplicationcontext-%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E7%B1%BB%E8%B7%AF%E5%BE%84%E7%9A%84-xml%E6%96%87%E4%BB%B6/</guid>
      <description>参考https://blog.csdn.net/upxiaofeng/article/details/53332226
URL a = this.getClass().getResource(&amp;#34;&amp;#34;); // 获取ClassPath的绝对URI路径 // or URL a = 写你的类名.getResource(&amp;#34;&amp;#34;); // 这里是反射的知识, String aa = a.toString(); // 转字符串 int begin = aa.indexOf(&amp;#34;/bin&amp;#34;)+5; aa = aa.substring(begin); // 切去 aa就是了 比如
String xmlPath = MainApp2.class.getResource(&amp;#34;&amp;#34;).toString(); xmlPath = xmlPath.substring(xmlPath.indexOf(&amp;#34;/bin/&amp;#34;)+5); </description>
    </item>
    
    <item>
      <title>控制台光标移动(有尾迹）</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E6%9C%89%E5%B0%BE%E8%BF%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E6%9C%89%E5%B0%BE%E8%BF%B9/</guid>
      <description>更改了网上的代码，实现有尾迹的移动，
用键盘上的上下左右来控制
这是借鉴地址：C语言之实现控制台光标随意移动
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;windows.h&amp;gt; #include &amp;lt;conio.h&amp;gt; HANDLE hout; //获得输入 char getInput() { int ch; //输入字符串 COORD coord; //屏幕上的坐标 CONSOLE_SCREEN_BUFFER_INFO csbi; //控制台屏幕缓冲区信息 coord.X=11; coord.Y=10; ch=getch(); csbi.dwCursorPosition.X=11; csbi.dwCursorPosition.Y=10; //0x0d表示回车，0XE0表示上下左右等键的键码 while(ch==0xE0||ch==0x0d) { GetConsoleScreenBufferInfo(hout,&amp;amp;csbi);//读取控制台屏幕缓冲信息 coord.X=csbi.dwCursorPosition.X; //得到坐标X的值 coord.Y=csbi.dwCursorPosition.Y; //得到坐标Y的值 ch=getch(); //printf(&amp;#34; &amp;#34;); //上 if(ch==0x48) { if(coord.Y!=0) { coord.Y--; //printf(&amp;#34;%c&amp;#34;,&amp;#39;A&amp;#39;); } } //下 else if(ch==0x50) { coord.Y++; //printf(&amp;#34;%c&amp;#34;,&amp;#39;A&amp;#39;); } //左 else if(ch==0x4b) { if(coord.X!=0){coord.X--;}//printf(&amp;#34;%c&amp;#34;,&amp;#39;A&amp;#39;);} } //右 else if(ch==0x4d) { if(coord.X!=79) { coord.X++; //printf(&amp;#34;%c&amp;#34;,&amp;#39;A&amp;#39;); } } printf(&amp;#34;%c&amp;#34;,&amp;#39;.</description>
    </item>
    
    <item>
      <title>数学必知必会-导数、梯度与积分</title>
      <link>https://sucicada.github.io/blog/posts/math/%E6%95%B0%E5%AD%A6%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%AF%BC%E6%95%B0%E6%A2%AF%E5%BA%A6%E4%B8%8E%E7%A7%AF%E5%88%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/math/%E6%95%B0%E5%AD%A6%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%AF%BC%E6%95%B0%E6%A2%AF%E5%BA%A6%E4%B8%8E%E7%A7%AF%E5%88%86/</guid>
      <description>(238条消息) 数学必知必会&amp;mdash;-导数、梯度与积分_sakura小樱的博客-CSDN博客_梯度求积分 数学必知必会&amp;mdash;-导数、梯度与积分 sakura小樱 于 2018-06-12 19:18:22 发布 3204 收藏 6
文章标签： 导数 数学 微积分
版权
一、导数 1.1常用的倒数 1.2复合函数求导 1.2.1链式法则 1.2.2多元函数求导：偏导数（偏微分） 二、积分 定积分 不定积分 拓展 三、均方误差 3.1导数应用 3.2线性回归的应用 四、梯度 4.1导入 4.2定义： 4.3事例 4.4理解方法 4.5梯度下降法定义 4.6局部极限值 4.7下降法求最小值方法 4.7.1抛小球法—momentum 4.7.2Nesterov 4.7.3自适应 4.7.4AdaDelta以及RMSprop 4.7.5选择 from sympy import * x=Symbol(&amp;#34;x&amp;#34;) diff(x**3 + x**2) #3x**2 + 2**x 一、导数 导数的实质就是曲线切线的斜率
1.1常用的倒数 1.2复合函数求导 1.2.1链式法则 1.2.2多元函数求导：偏导数（偏微分） 链式法则
多元函数求导的法则
二、积分 积分是微分的逆运算，即知道了函数的 导函数，反求原函数。在应用上，积分作用不仅如此，它被大量应用于求和，通俗的说是求 曲边三角形的面积，这巧妙的求解方法是积分特殊的性质决定的。
更多推导公式点击这里
定积分 不定积分 拓展 ● 微分的相关知识</description>
    </item>
    
    <item>
      <title>树莓派 raspberry系统 VNC View 连接 Cannot currently show the desktop 错误解决</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E6%A0%91%E8%8E%93%E6%B4%BE-raspberry%E7%B3%BB%E7%BB%9F-vnc-view-%E8%BF%9E%E6%8E%A5-cannot-currently-show-the-desktop-%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E6%A0%91%E8%8E%93%E6%B4%BE-raspberry%E7%B3%BB%E7%BB%9F-vnc-view-%E8%BF%9E%E6%8E%A5-cannot-currently-show-the-desktop-%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</guid>
      <description>https://www.raspberrypi.org/forums/viewtopic.php?t=216737
我是因为空间不够</description>
    </item>
    
    <item>
      <title>比赛中使用文件输入输出</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E6%AF%94%E8%B5%9B%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E6%AF%94%E8%B5%9B%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</guid>
      <description>使用文件最简单的方式就是使用输入输出重定向
freopen(&amp;#34;input.txt&amp;#34;,&amp;#34;r&amp;#34;,stdin);//从文件读入 freopen(&amp;#34;outout.txt&amp;#34;,&amp;#34;w&amp;#34;,stdout);//写入文件 非重定向
#include&amp;lt;stdio.h&amp;gt; int main() { FILE *fin,*fout; int x; fin = fopen(&amp;#34;input.txt&amp;#34;,&amp;#34;rb&amp;#34;);//从文件读入 fout = fopen(&amp;#34;outout.txt&amp;#34;,&amp;#34;wb&amp;#34;);//写入文件 fscanf(fin,&amp;#34;%d&amp;#34;,&amp;amp;x); fprintf(fout,&amp;#34;%d&amp;#34;,x); fclose(fin); fclose(fout); return 0; } </description>
    </item>
    
    <item>
      <title>求int型的最大取值（正数）</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E6%B1%82int%E5%9E%8B%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8F%96%E5%80%BC%E6%AD%A3%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E6%B1%82int%E5%9E%8B%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8F%96%E5%80%BC%E6%AD%A3%E6%95%B0/</guid>
      <description>用的是夹值法
#include&amp;lt;stdio.h&amp;gt; int main(){ int i=1,n=1,m; do { n=i; i=i*2; printf(&amp;#34;%d\n&amp;#34;,n); } while((i/2)==n);//n是存数，i去趟雷 putchar(&amp;#39;\n&amp;#39;); m=n; for(;;) { n=m; m+=1; if((m-1)!=n) { printf(&amp;#34;break&amp;#34;); break; } else m-=1; i=1; while(1) { if(i!=1) if((n-i/2)!=m) { printf(&amp;#34;int %d\n&amp;#34;,m); return; } printf(&amp;#34;!!!\n&amp;#34;); if(i!=1) m=n;//m是存数，n去趟雷 n=n+i; i*=2; printf(&amp;#34;%d %d\n&amp;#34;,m,n); } } getchar(); return 0; } 最大值：2147483647</description>
    </item>
    
    <item>
      <title>求最长回文子串</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E6%B1%82%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E6%B1%82%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>一段字符串中出现的正反读一样的子串
当时自己写下的泛泛之词
#include&amp;lt;stdio.h&amp;gt; #define N 20 int main() { char a[N]=&amp;#34;abcb&amp;#34;; char b[N]=&amp;#34;0000&amp;#34;; int i,j,m; for(i=0;i&amp;lt;strlen(a)/2;i++) { for(j=i+1;j&amp;lt;strlen(a);j++) { if(a[i]==a[j]) { printf(&amp;#34;%d %d %d &amp;#34;,i,j ,m); for(m=i;m&amp;lt;=j;m++) { if(a[m]!=a[j+i-m]) break; b[m-i]=a[m]; b[j-i-m]=a[j+i-m]; if((m==j+i-m)||(m==j+i-m-1)) i=j; printf(&amp;#34;%s\n&amp;#34;,b); } } } } printf(&amp;#34;%s\n&amp;#34;,b); return 0; } </description>
    </item>
    
    <item>
      <title>王源 汇编语言 课设2 8086-boot</title>
      <link>https://sucicada.github.io/blog/posts/assmbly/%E7%8E%8B%E6%BA%90-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E8%AF%BE%E8%AE%BE2-8086-boot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/assmbly/%E7%8E%8B%E6%BA%90-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E8%AF%BE%E8%AE%BE2-8086-boot/</guid>
      <description>代码见https://github.com/SuCicada/8086-Boot
第二版 2019/5/31 23:06
见 class2i.asm 文件
1、偏移地址可以从0开始算了！
将要拷贝软盘中的代码放到新的data段中，然后在 0:7c00h 处的代码一开始就跳转 07c0:0h 处，这样就解决了偏移地址无法从0开始算的问题，可以抛弃 偏移量 site 的做法了。
2、引导操作系统一步到位
废弃了将代码（what拷贝硬盘到7c00h处，并从7c00h执行）拷贝到 0:200h 这个安全地方执行的做法。
采取的新方法就是，将引导操作系统这部分功能的代码－－移动到 0:7c00h - 0:07dffh 这512字节之外的地方，这样就安全了！目前是放到了 3功能（显示时间）之后
3、独立的信息显示模块
show_info 函数单独拿出来，又减少了100行代码
4、更少的代码
从原先的1100行降到890行，少了210行。
第一版 主要从2019/5/17 到2019/5/21 日，大约历经40小时
见 class2i.asm 文件
１．关于硬盘拷贝的位置
引导操作系统时，硬盘这个 80h 磁盘，必须将一开始的部分拷贝到 0:7c00h 处，不能换成是别的地方，所以这就还在拷贝的时候覆盖原有的代码，导致拷贝之后无法跳转到 0:7c00h 处执行。
所以采用的是：将拷贝与执行代码，一并拷贝到其他的安全的地方，比如 0:200h 处。</description>
    </item>
    
    <item>
      <title>王爽 汇编 课设1</title>
      <link>https://sucicada.github.io/blog/posts/assmbly/%E7%8E%8B%E7%88%BD-%E6%B1%87%E7%BC%96-%E8%AF%BE%E8%AE%BE1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/assmbly/%E7%8E%8B%E7%88%BD-%E6%B1%87%E7%BC%96-%E8%AF%BE%E8%AE%BE1/</guid>
      <description>使用temp空间来暂存每一行要显示的字符, 然后调用show_str子程序 进行显示
外层21次循环
难点:dd段的数字太大,无法简单进行除10存储, 需要借助div_d 大除法的子程序(更改的),
assume cs:code,ds:table,ss:stack stack segment db 32 dup (0) stack ends table segment db 81 dup(0) ; temp空间 ; 81 * 1 = 81 byte db &amp;#39;1975&amp;#39;,&amp;#39;1976&amp;#39;,&amp;#39;1977&amp;#39;,&amp;#39;1978&amp;#39;,&amp;#39;1979&amp;#39;,&amp;#39;1980&amp;#39;,&amp;#39;1981&amp;#39;,&amp;#39;1982&amp;#39;,&amp;#39;1983&amp;#39; db &amp;#39;1984&amp;#39;,&amp;#39;1985&amp;#39;,&amp;#39;1986&amp;#39;,&amp;#39;1987&amp;#39;,&amp;#39;1988&amp;#39;,&amp;#39;1989&amp;#39;,&amp;#39;1990&amp;#39;,&amp;#39;1991&amp;#39;,&amp;#39;1992&amp;#39; db &amp;#39;1993&amp;#39;,&amp;#39;1994&amp;#39;,&amp;#39;1995&amp;#39; ; 21 * 4 = 84 byte dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 ; 12 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ; 21 * 4 = 84 byte dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 ; 21 * 2 = 42 byte db 1,0,0,0,0 ; 循环的第几,年的第几,钱的第几,人的第几,当前temp空间的指向 ; 5 * 1 = 5 byte table ends code segment start: mov ax,stack mov ss,ax mov sp,32 mov ax,table ; 原始数据 mov ds,ax mov bx,0 ; 年的计数 mov cx,21 main_loop: push cx ; ds:[84+84+42+5] 是temp区域 ; =========== 年 =============== ; 显示4列 mov cx,4 mov bl,ds:[81+84+84+42][1] ; 年的字节在哪 mov bh,0 mov si,0 start_s1: mov dl, ds:81[bx] ; 记得跳过81byte mov ds:[si],dl inc bx inc si loop start_s1 mov al,4 mov ds:[81+84+84+42][4],al ; ================ 空格 ================= mov cx,4 ; 空格数量 ; mov dl,ds:[81+84+84+42][4] call add_space ; 存储空格 ; add dl,4 ; mov ds:[81+84+84+42][4],dl ; temp扩增了 ; =================== 收入 ================== ; 显示10列 mov bl,ds:[81+84+84+42][2] ; 收入的字节在哪 mov bh,0 mov ax,ds:[81+84][bx] mov dx,ds:[81+84][bx+2] mov bl,ds:[81+84+84+42][4] mov bh,0 mov si,bx ; 存到 ds:[.</description>
    </item>
    
    <item>
      <title>简单聊天机器人(百度语音识别,语音合成,图灵机器人API实现)</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BAapi%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%99%BE%E5%BA%A6%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB%E8%AF%AD%E9%9F%B3%E5%90%88%E6%88%90%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BAapi%E5%AE%9E%E7%8E%B0/</guid>
      <description>百度语音识别API的使用样例（python实现）
【Python】调用百度REST API实现语音识别
python 调用图灵机器人api实现简单的人机交互
百度语音识别api调用 python
Python 调用图灵机器人API
图灵机器人api调用
【Python】调用百度REST API实现语音识别
语音识别的技术原理是什么？
处理音频&amp;ndash;pyaudio
Py之pyaudio：Python库之pyaudio简介、安装、使用方法之详细攻略
关于ALSA lib pcm.c:7843:(snd_pcm_recover) underrun occurred等错误(未解决)
https://blog.csdn.net/gaonii/article/details/69358270
https://blog.petrockblock.com/forums/topic/alsa-lib-pcm-c7339snd_pcm_recover-underrun-occurred/
https://stackoverflow.com/questions/23151269/alsa-lib-pcm-c7843snd-pcm-recover-underrun-occurred-error-in-julia-while
树莓派上安装pyaudio 及 对声音实时监控
http://www.tuling123.com/help/h_cent_webapi.jhtml?nav=doc
http://ai.baidu.com/
http://ai.baidu.com/docs#/ASR-API/top</description>
    </item>
    
    <item>
      <title>背包问题 01 和完全</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-01-%E5%92%8C%E5%AE%8C%E5%85%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-01-%E5%92%8C%E5%AE%8C%E5%85%A8/</guid>
      <description>#include&amp;lt;iostream&amp;gt; using namespace std; int w[] = {0,2,3,4,7}; int v[] = {0,1,3,5,9}; const int Cap = 10; int m[Cap+1][Cap+1] = {0}; int N = 4; void show(); int pack01(){ //https://www.cnblogs.com/Christal-R/p/Dynamic_programming.html for(int i=1;i&amp;lt;=4;i++){ // for(int j=1;j&amp;lt;=Cap;j++){ for(int j=Cap;j&amp;gt;0;j--){ if(j&amp;lt;w[i]){ m[i][j] = m[i-1][j]; }else{ m[i][j] = max(m[i-1][j],m[i-1][j-w[i]]+v[i]); } cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;v[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;w[i]&amp;lt;&amp;lt;endl; show(); } } } int m2[10] = {0}; int pack01_2(){ for(int i=1;i&amp;lt;=4;i++){ for(int j=Cap;j&amp;gt;0;j--){ if(j &amp;lt; w[i]){ m2[j] = m2[j]; }else{ m2[j] = max( m2[j], m2[j-w[i]] + v[i]); } cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;m2[j-w[i]] + v[i]&amp;lt;&amp;lt;endl; for(int i=0;i&amp;lt;=Cap;i++) cout&amp;lt;&amp;lt;m2[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; cout&amp;lt;&amp;lt;endl; } } } void show(){ for(int i=0;i&amp;lt;=4;i++){ for(int j=0;j&amp;lt;=Cap;j++){ cout&amp;lt;&amp;lt;m[i][j]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; } cout&amp;lt;&amp;lt;endl; } cout&amp;lt;&amp;lt;&amp;#34;----------------&amp;#34;&amp;lt;&amp;lt;endl; } int goback(){ int i=N,j=Cap; cout&amp;lt;&amp;lt;m[i][j]&amp;lt;&amp;lt;endl; while(i&amp;gt;0 &amp;amp;&amp;amp; j&amp;gt;0){ cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;m[i][j]&amp;lt;&amp;lt;endl; if(m[i][j] == m[i-1][j]){ i--; }else{ cout&amp;lt;&amp;lt;&amp;#34;choosen: &amp;#34;&amp;lt;&amp;lt;v[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;w[i]&amp;lt;&amp;lt;endl; j -= w[i]; i--; } } } int packfull(){ // https://blog.</description>
    </item>
    
    <item>
      <title>能被学的东西 【已知】</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E8%83%BD%E8%A2%AB%E5%AD%A6%E7%9A%84%E4%B8%9C%E8%A5%BF-%E5%B7%B2%E7%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E8%83%BD%E8%A2%AB%E5%AD%A6%E7%9A%84%E4%B8%9C%E8%A5%BF-%E5%B7%B2%E7%9F%A5/</guid>
      <description>可新学 Lucene Vertx Clojure Haskell 可深入 Netty Redis </description>
    </item>
    
    <item>
      <title>解决 vboxdrv.sh: failed: Cannot change group vboxusers for device _dev_vboxdrv.</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E8%A7%A3%E5%86%B3-vboxdrv.sh-failed-cannot-change-group-vboxusers-for-device-_dev_vboxdrv./</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E8%A7%A3%E5%86%B3-vboxdrv.sh-failed-cannot-change-group-vboxusers-for-device-_dev_vboxdrv./</guid>
      <description>virtualbox 报错 ,看提示让执行以下
sudo /sbin/vboxconfig 如果报错:
vboxdrv.sh: failed: Cannot change group vboxusers for device /dev/vboxdrv.
那么应该是本用户没有加入vboxusers.
参考:
https://ubuntuforums.org/archive/index.php/t-790303.html
执行:
sudo addgroup vboxusers sudo adduser your_username vboxusers sudo /etc/init.d/vboxdrv setup 即可
错误原因应该是我卸载mysql时将一些旧的配置删了,我不知道,我相信没人会闲到犯和我一样的错误</description>
    </item>
    
    <item>
      <title>解决sublime 的 package control 问题here are no packages available for installation</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E8%A7%A3%E5%86%B3sublime-%E7%9A%84-package-control-%E9%97%AE%E9%A2%98here-are-no-packages-available-for-installation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E8%A7%A3%E5%86%B3sublime-%E7%9A%84-package-control-%E9%97%AE%E9%A2%98here-are-no-packages-available-for-installation/</guid>
      <description>参考https://blog.csdn.net/zknxx/article/details/52685094
关于 channel_v3.json 文件 ,下载的压缩包里没有, 需要下载https://packagecontrol.io/channel_v3.json 页面
但是这个页面我发现一开始没有打开, 可以在这里下载, https://download.csdn.net/download/su_cicada/10568987
积分至少 1真坑,不想出积分的可以去https://github.com/SuCicada/channel_v3.json 上下载我上传到上面的</description>
    </item>
    
    <item>
      <title>解决sublime不能输入中文，以及输入中文操作异常，以及文字候选框位置异常</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E8%A7%A3%E5%86%B3sublime%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E4%BB%A5%E5%8F%8A%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E6%93%8D%E4%BD%9C%E5%BC%82%E5%B8%B8%E4%BB%A5%E5%8F%8A%E6%96%87%E5%AD%97%E5%80%99%E9%80%89%E6%A1%86%E4%BD%8D%E7%BD%AE%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E8%A7%A3%E5%86%B3sublime%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E4%BB%A5%E5%8F%8A%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E6%93%8D%E4%BD%9C%E5%BC%82%E5%B8%B8%E4%BB%A5%E5%8F%8A%E6%96%87%E5%AD%97%E5%80%99%E9%80%89%E6%A1%86%E4%BD%8D%E7%BD%AE%E5%BC%82%E5%B8%B8/</guid>
      <description>两种办法：都试试吧，两个都试一遍
https://github.com/YoungZHU/sublime-imfix
强烈第一个，一定要记的sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade 一般解决不了更新一下系统就都好了
https://blog.csdn.net/CV_YOU/article/details/77702383
关于文中改桌面快捷方式的配置文件，来使得其能通过桌面快捷方式打开也能输入中文，有一个更加简单的方法。
如果你之前通过终端输入subl来打开的sublime能输入中文的话，那么这一条就适用。
就是将桌面上sublime的快捷方式的属性中的命令一行：改成 subl 。</description>
    </item>
    
    <item>
      <title>解决Visual Stdio Code python 输出乱码（中文乱码和全部乱码）</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E8%A7%A3%E5%86%B3visual-stdio-code-python-%E8%BE%93%E5%87%BA%E4%B9%B1%E7%A0%81%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E5%92%8C%E5%85%A8%E9%83%A8%E4%B9%B1%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E8%A7%A3%E5%86%B3visual-stdio-code-python-%E8%BE%93%E5%87%BA%E4%B9%B1%E7%A0%81%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E5%92%8C%E5%85%A8%E9%83%A8%E4%B9%B1%E7%A0%81/</guid>
      <description>第一种情况
无论输出什么都是乱码一堆，但是在切换到别的文件输出正常，在排除了代码错误，以及中文输出（下面会说）的情况，那么你只需要看看是不是你的文件名的关系，如果有空格则不行，别的字符还没有尝试。
运行环境：vscode版本：1.19.3
代码语言：python 3.6
第二种情况
在vscode里用ctrl+shift+B直接输出python运行结果时。
print(&amp;#39;是中文吗&amp;#39;) 下面输出栏中却显示的是乱码，而在终端中运行则正常显示中文。
查了很久，尝试了很多办法，改了很多设置。都没用，在不换ide的前提下，终于找见了一种在vscode中能行的办法。
在一个py文件里加上以下内容
#一、如果vs code中输出中文乱码 # -*-coding:utf-8 -*- import io import sys #改变标准输出的默认编码 sys.stdout=io.TextIOWrapper(sys.stdout.buffer,encoding=&amp;#39;utf8&amp;#39;) print(&amp;#39;中文吗&amp;#39;) 即可，如果每次都要写一堆很麻烦，那么就将其作为一个单独的py文件，再写别的py文件时，import进来就行了。
（别问我为什么不用F5来调试，因为我的vs会告诉我 调试适配器进程已意外终止）</description>
    </item>
    
    <item>
      <title>解决Visual Stdio Code 调试时显示“调试适配器进程已意外终止”</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E8%A7%A3%E5%86%B3visual-stdio-code-%E8%B0%83%E8%AF%95%E6%97%B6%E6%98%BE%E7%A4%BA%E8%B0%83%E8%AF%95%E9%80%82%E9%85%8D%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%B7%B2%E6%84%8F%E5%A4%96%E7%BB%88%E6%AD%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E8%A7%A3%E5%86%B3visual-stdio-code-%E8%B0%83%E8%AF%95%E6%97%B6%E6%98%BE%E7%A4%BA%E8%B0%83%E8%AF%95%E9%80%82%E9%85%8D%E5%99%A8%E8%BF%9B%E7%A8%8B%E5%B7%B2%E6%84%8F%E5%A4%96%E7%BB%88%E6%AD%A2/</guid>
      <description>当我按下F5的时候，这个ide告诉我“调试适配器进程已意外终止”，无法调试，断点就失去了作用，这让我十分烦恼，在尝试了网上的所有办法后，比如重新配置launch文件，或者重新安装python插件，重新安装软件，都没有用 。
那么这样的话，不妨试试彻底删除，重新安装软件吧。
在看了https://segmentfault.com/q/1010000008133674中
2个地方需要删除：
C:Users{user}AppDataRoamingCode
C:Users{user}.vscode
其中我在卸载vscode后只删除了第二个文件夹，然后再重新安装1.19.3后，终于可以调试了。</description>
    </item>
    
    <item>
      <title>论如何解决类似如 &#39;&#39;&#39;使用 openresty 库 lua-resty-kafka 对接kafka 报错 no resolver defined to resolve &#34;xxx&#34; &#39;&#39;&#39; 的问题</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E8%AE%BA%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B1%BB%E4%BC%BC%E5%A6%82-%E4%BD%BF%E7%94%A8-openresty-%E5%BA%93-lua-resty-kafka-%E5%AF%B9%E6%8E%A5kafka-%E6%8A%A5%E9%94%99-no-resolver-defined-to-resolve-xxx-%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E8%AE%BA%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B1%BB%E4%BC%BC%E5%A6%82-%E4%BD%BF%E7%94%A8-openresty-%E5%BA%93-lua-resty-kafka-%E5%AF%B9%E6%8E%A5kafka-%E6%8A%A5%E9%94%99-no-resolver-defined-to-resolve-xxx-%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>始苦寻无果，终幸得其所
参考项目的issue
https://github.com/doujiang24/lua-resty-kafka/issues/5
这个issue已经将问题说的很明白了
在我电脑上当时的表现就是lua从kafka获取到的broker的host一直是ubuntu
而我明明给lua中配置的host是ip地址。
而ubuntu这个域名在/etc/hosts中有设置，但是在我去掉域名解析，重启电脑之后，还是没有解决。
因为有这个被动ip转成了本地域名的灵异现象存在，使得lua-resty-kafka库无法解析域名，导致生产者无法向kafka推送数据。
而解决办法则是在kafka的配置文件 server.properties中设置
host.name= {你的ip或域名}
更新: 原因研究
根据:kafka主机名解析hostname
我们查看zookeeper中关于kafka的brokers的信息
[zk: localhost:2181(CONNECTED) 0] get /brokers/ids/0
{&amp;ldquo;listener_security_protocol_map&amp;rdquo;:{&amp;ldquo;PLAINTEXT&amp;rdquo;:&amp;ldquo;PLAINTEXT&amp;rdquo;},&amp;ldquo;endpoints&amp;rdquo;:[&amp;ldquo;PLAINTEXT://ubuntu:9092&amp;rdquo;],&amp;ldquo;jmx_port&amp;rdquo;:-1,&amp;ldquo;host&amp;rdquo;:&amp;ldquo;ubuntu&amp;rdquo;,&amp;ldquo;timestamp&amp;rdquo;:&amp;ldquo;1584515322686&amp;rdquo;,&amp;ldquo;port&amp;rdquo;:9092,&amp;ldquo;version&amp;rdquo;:4}
从中果然发现了ubuntu:9092，所以问题出在zookeeper。
然后继续搜索，找到
如何避免将Kafka broker机器的hostname注册进zookeeper
其中提到了配置文件的注释提示信息，翻回去一看
# Hostname and port the broker will advertise to producers and consumers. If not set,
# it uses the value for &amp;ldquo;listeners&amp;rdquo; if configured. Otherwise, it will use the value
# returned from java.net.InetAddress.getCanonicalHostName().
#advertised.listeners=PLAINTEXT://your.host.name:9092
果然，如果没有配置就使用 java.net.InetAddress.getCanonicalHostName()获得。
到服务器上使用命令执行一看
java&amp;gt; java.net.InetAddress.getLocalHost().getCanonicalHostName(); java.lang.String res0 = &amp;#34;ubuntu&amp;#34; 果然如此！</description>
    </item>
    
    <item>
      <title>证明 scala 不能从外部调用内部函数</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/%E8%AF%81%E6%98%8E-scala-%E4%B8%8D%E8%83%BD%E4%BB%8E%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/%E8%AF%81%E6%98%8E-scala-%E4%B8%8D%E8%83%BD%E4%BB%8E%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0/</guid>
      <description>一段代码
object ASD { def main(args: Array[String]): Unit = { def f(a: Any): Unit = { println(a) } f(&amp;#34;sfsfsfdsdfd&amp;#34;) } } 如果我们想进行类似ASD.main.f(xx)或ASD.f(xx)的操作, 是否可行.
事实是残酷的, 它告诉我们不可行.
那么下面从反编译角度来探究为什么不可行:
首先我们打开编译后的 class 文件所在目录
有2个文件: ASD.class和ASD$.class
ASD.class 节选
public final class ASD { public static void main(String[] paramArrayOfString) { ASD$.MODULE$.main(paramArrayOfString); } } 这个不重要
ASD$.class 节选
public final class ASD$ { public static final ASD$ MODULE$; private final void f$1(Object a) { Predef$.MODULE$.println(a); } public void main(String[] args) { f$1(&amp;#34;sfsfsfdsdfd&amp;#34;); } private ASD$() { MODULE$ = this; } } 发现了吗, 内部函数 f 被编译为 私有的 final 方法f$1.</description>
    </item>
    
    <item>
      <title>读取properties配置文件路径找不到的解决方法</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E8%AF%BB%E5%8F%96properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%89%BE%E4%B8%8D%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E8%AF%BB%E5%8F%96properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E6%89%BE%E4%B8%8D%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</guid>
      <description>public class DB_connection { String JDBC_DRIVER;//=&amp;#34;com.mysql.jdbc.Driver&amp;#34;; String DB_URL;// = &amp;#34;jdbc:mysql://localhost:3306/promotion_website?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;#34;; String FILENAME = &amp;#34;/database.properties&amp;#34;; String USER;// = &amp;#34;root&amp;#34;; String PASS;// = &amp;#34;mysql&amp;#34;; Connection conn = null; public DB_connection() { try { Properties prop = new Properties(); String FILE_PATH = this.getClass().getClassLoader().getResource(FILENAME).getPath(); System.out.println(&amp;#34;path &amp;#34;+FILE_PATH); File file = new File(FILE_PATH); FileInputStream in = new FileInputStream(file); prop.load(in); JDBC_DRIVER = prop.getProperty(&amp;#34;JDBC_DRIVER&amp;#34;); DB_URL = prop.getProperty(&amp;#34;DB_URL&amp;#34;); USER = prop.getProperty(&amp;#34;USER&amp;#34;); PASS = prop.getProperty(&amp;#34;PASS&amp;#34;); } catch (FileNotFoundException ex) { Logger.</description>
    </item>
    
    <item>
      <title>重要的事情</title>
      <link>https://sucicada.github.io/blog/posts/%E6%97%A5%E8%A8%98/%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E6%83%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/%E6%97%A5%E8%A8%98/%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E6%83%85/</guid>
      <description>RULE 如何成为自由的守则：
让大脑习惯这么做
目标是返璞归真 首先第一步，摆脱方便电子品的束缚，这是硅基入侵危机的第一重危机。 摆脱方式就是：主观控制，快乐转移 不要刷b站 不要刷youtube 有目的的可以看 娱乐的东西有限制才行 抵制诱惑，比如小视频，小游戏 减少无用信息的输入，减少精力的分散，减少记忆暂存区的资源占用 要有信仰，在需要娱乐的时候，可以做： 听哆啦生肉 听日语歌，v家 早:
拿手机*2，水瓶，口罩，耳机，钱包 出门之前，开窗通风。 出门之前刮胡子 早上可以看的app： qq 看看有没有留言 微信 看看有没有留言 twitter anki 之后时间都用其填充 白: 晚(家): 晚上回到家， 做锻炼 做仰卧起坐 60*2 (time:10m) 仰卧起坐的时候拉伸是很舒服的。 注意压腿 然后洗头。洗完吹干,越早洗完,越多时间晾干. (time:7m+5m) 洗脸 然后念一遍日语 25*1 (time:25m) 至此 40m 之后就开始当日特定事项 睡前: 刷牙 (time:3m) 睡前记日记 (time:5m) 睡前把耳机，手机充电，并检查是否处于充电状态 (time:30s) 睡前检查闹钟，准备好包包和外出物品 平板不要带上床，让大脑习惯这么做 睡前检查一遍 about 和todo 睡眠不要少于6小时，如果可以不要连续3天少于5小时，如果发生此类情况，建议立即想方设法进行睡眠。 建议睡眼时长为7小时。如小于7小时。建议中午午睡 睡前寂寞不想睡的话，进行控梦练习，和场景想象练习 周日晚上洗漱整理杂项善后可能3小时，远远大于预期 何为适当休息：即使用不需要持续网络的软件，比如本地图库、离线音乐软件、 如厕时可以适当使用a岛和动漫之家，仅限于看完动漫之家订阅列表中更新的漫画。 可做的事情： 日文课文背诵朗读 学唱日文歌 《科幻世界》阅读 SuOS 开发 补充日记，写文章，写回忆录，写随笔 认知理论总结 整理 notion 和博客 https://www.</description>
    </item>
    
    <item>
      <title>针对导入外部Gradle项目发生的版本冲突错误。</title>
      <link>https://sucicada.github.io/blog/posts/bigdata/%E9%92%88%E5%AF%B9%E5%AF%BC%E5%85%A5%E5%A4%96%E9%83%A8gradle%E9%A1%B9%E7%9B%AE%E5%8F%91%E7%94%9F%E7%9A%84%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%E9%94%99%E8%AF%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/bigdata/%E9%92%88%E5%AF%B9%E5%AF%BC%E5%85%A5%E5%A4%96%E9%83%A8gradle%E9%A1%B9%E7%9B%AE%E5%8F%91%E7%94%9F%E7%9A%84%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%E9%94%99%E8%AF%AF/</guid>
      <description>比如一个使用场景：Intellij 导入Kafka 2.2.1版本源码。
在使用gradle初始化项目时各种grafana配置文件报错。
原因主要是本机构建用的Gradle版本与项目编写配置文件产生冲突，简而言之就是Gradle版本不对。
比如Kafka 2.2.1 在发布的时候，Gradle 版本最高直到5.4.1。而本机使用了Gradle 6 。导致了冲突，下载 Gradle 5.4.1 并用其构建即可解决。</description>
    </item>
    
    <item>
      <title>颠倒字符串（整体，子串）</title>
      <link>https://sucicada.github.io/blog/posts/soft/%E9%A2%A0%E5%80%92%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B4%E4%BD%93%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://sucicada.github.io/blog/posts/soft/%E9%A2%A0%E5%80%92%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B4%E4%BD%93%E5%AD%90%E4%B8%B2/</guid>
      <description>这是对整体的字符串镜像
#include &amp;lt;stdio.h&amp;gt; int main(void) { char a[9] = &amp;#34;abcdef&amp;#34;; int i,j;//j是最后一位，i是执行位 j=strlen(a)-1; printf(&amp;#34;%s\n&amp;#34;,a); for(i=0;i&amp;lt;strlen(a)/2;i++) { a[i]+=a[j-i]; a[j-i]=a[i]-a[j-i]; a[i]=a[i]-a[j-i]; printf(&amp;#34;%s\n&amp;#34;,a); } return 0; } 这是对子串镜像
#include &amp;lt;stdio.h&amp;gt; int main(void) { char a[] = &amp;#34;012 4567 910&amp;#34;; int i,j,t;//j是最后一位，i是执行位 j=7; t=i=4;//t记录下变换部分的第一位 printf(&amp;#34;%s\n&amp;#34;,a); for(;i&amp;lt;(j+t+1)/2;i++) { a[i]+=a[j-i+t]; a[j-i+t]=a[i]-a[j-i+t]; a[i]=a[i]-a[j-i+t]; printf(&amp;#34;%s\n&amp;#34;,a); } return 0; } </description>
    </item>
    
  </channel>
</rss>
