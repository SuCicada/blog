<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | SuCicada</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - SuCicada">
<meta name="author" content="SuCicada">
<link rel="canonical" href="https://sucicada.github.io/blog/posts/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.5b5501da54f21435c8f8010d1de02123ae8d1ada696b48c6530ec4eea283e7d6.css" integrity="sha256-W1UB2lTyFDXI&#43;AENHeAhI66NGtppa0jGUw7E7qKD59Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sucicada.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sucicada.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sucicada.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sucicada.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://sucicada.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://sucicada.github.io/blog/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Posts" />
<meta property="og:description" content="SuCicada - https://github.com/SuCicada" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://sucicada.github.io/blog/posts/" /><meta property="og:image" content="https://sucicada.github.io/blog/papermod-cover.png"/>

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://sucicada.github.io/blog/papermod-cover.png"/>

<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content="SuCicada - https://github.com/SuCicada"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://sucicada.github.io/blog/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sucicada.github.io/blog" accesskey="h" title="SuCicada (Alt + H)">SuCicada</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sucicada.github.io/blog/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://sucicada.github.io/blog/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://sucicada.github.io/blog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://sucicada.github.io/blog/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://sucicada.github.io/blog">Home</a></div>
  <h1>
    Posts
    <a href="index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 540 - Team Queue（插队队列）
    </h2>
  </header>
  <div class="entry-content">
    <p>例题5-6 团体队列(Team Queue,UVa540)
有t个团队的人正在排一个长队。每次新来一个人时,如果他有队友在排队,那么这个
新人会插队到最后一个队友的身后。如果没有任何一个队友排队,则他会排到长队的队尾。
输入每个团队中所有队员的编号,要求支持如下3种指令(前两种指令可以穿插进
行)。
ENQUEUEx:编号为x的人进入长队。
DEQUEUE:长队的队首出队。
STOP:停止模拟。
对于每个DEQUEUE指令,输出出队的人的编号。
Sample Input
2
3 101 102 103
3 201 202 203
ENQUEUE 101
ENQUEUE 201
ENQUEUE 102
ENQUEUE 202
ENQUEUE 103
ENQUEUE 203
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
STOP
2
5 259001 259002 259003 259004 259005
6 260001 260002 260003 260004 260005 260006
ENQUEUE 259001
ENQUEUE 260001
ENQUEUE 259002
ENQUEUE 259003
ENQUEUE 259004
ENQUEUE 259005
DEQUEUE
DEQUEUE...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 540 - Team Queue（插队队列）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-540-team-queue%E6%8F%92%E9%98%9F%E9%98%9F%E5%88%97/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 548 - Tree(树) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-8 树（Tree, UVa 548）
给一棵点带权（权值各不相同，都是小于10000的正整数）的二叉树的中序和后序遍
历，找一个叶子使得它到根的路径上的权和最小。如果有多解，该叶子本身的权应尽量小。
输入中每两行表示一棵树，其中第一行为中序遍历，第二行为后序遍历。
样例输入：
3 2 1 4 5 7 6
3 1 2 5 6 7 4
7 8 11 3 5 16 12 18
8 3 11 7 16 18 12 5
255
255
样例输出：
1
3
255
本家地址
在根据中序和后序遍历进行构造的时候，同时计算叶子的权值和，比较选择最小的权值的叶子，记录最小权值和的叶子和权值和。
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;sstream&gt; #include&lt;cstring&gt; using namespace std; int inorder[10004]; int postorder[10004]; int inindex[10004]; int min_top_value = 100000004; // 最小的权和 int loft = -1; // 叶子本身的值, /* 参数: 当前子树的 中序前,后 后序前,后 */ int calcul(int in_begin, int in_end, int post_begin, int post_end, int alculate_root_value){ // in_end - in_begin == post_end - post_begin int root_value = postorder[post_end]; // 根, 从后序 int root_in_index = inindex[root_value];//fin_inorder(in_begin, in_end, root_value); alculate_root_value = alculate_root_value &#43; root_value; // 新的累计根值, 加上自己身上的 if(in_end &lt;= in_begin){ // 叶子了 if(loft == -1 || // 第一个叶子 (alculate_root_value &lt; min_top_value) || (alculate_root_value == min_top_value &amp;&amp; inorder[in_begin] &lt; loft) ) { min_top_value = alculate_root_value; loft = inorder[in_begin]; } return 0; } int len = root_in_index-1-in_begin; if(root_in_index &gt; in_begin){ calcul(in_begin, root_in_index-1, post_begin, post_begin &#43; len, alculate_root_value); // 左枝 } len = in_end - root_in_index-1; if(root_in_index &lt; in_end){ calcul(root_in_index&#43;1, in_end, post_end-1-len , post_end-1, alculate_root_value); // 右枝 } return 0; } void init(){ memset(inorder,0,sizeof(inorder)); memset(postorder,0,sizeof(postorder)); memset(inindex,0,sizeof(inindex)); min_top_value = 100000004; // 最小的权和 loft = -1; // 叶子本身的值 } int main() { int row = 0; string line; while(getline(cin,line)){ // cout&lt;&lt;n&lt;&lt;&#34; &#34;; stringstream ss(line); int i=0; int n; if(row==0){ // 新的一组, 要初始化 // 代表是一组中的第一行,即中序遍历 init(); while(ss&gt;&gt;n){ inorder[i] = n; inindex[n] = i; i&#43;&#43;; } row = 1; }else{ // 一组中的第二行, 即后序遍历 while(ss&gt;&gt;n){ postorder[i&#43;&#43;] = n; } row = 0; calcul(0,i-1,0,i-1,0); cout&lt;&lt;loft&lt;&lt;endl; } return 0; } // AC at 2020/03/21 ps：债还清了，这个代码提交了12次数，uva因为赞助商跑路的关系（不知道也没有关系），感觉现在更加慢了。网站首页筹集代码贡献。也想做点贡献，但是C&#43;&#43;的网站。。。</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 548 - Tree(树) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-548-tree%E6%A0%91-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 572 - Oil Deposits (油田) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-12 油田（Oil Deposits, UVa 572）
输入一个m行n列的字符矩阵，统计字符“@”组成多少个八连块。如果两个字符“@”所在
的格子相邻（横、竖或者对角线方向），就说它们属于同一个八连块。例如，图6-9中有两
个八连块。
Sample Input
1 1
*
3 5
@@*
@
@@*
1 8
@@***@
5 5
****@
@@@
@**@
@@@@
@@**@
0 0
Sample Output
0
1
2
2
本家连接
恩，嘛，遍历跑呗。反正到处都有。
#include&lt;iostream&gt; using namespace std; char oil[110][110]; int sum=0; int length,width; int isOil=0; void show(){ for(int i=0;i&lt;length;i&#43;&#43;){ for(int j=0;j&lt;width;j&#43;&#43;) cout&lt;&lt;oil[i][j]; cout&lt;&lt;endl; } // cout&lt;&lt;&#34;========================&#34;&lt;&lt;endl; cout&lt;&lt;endl; } int dfs(int x,int y){ char plot = oil[x][y]; if(x&lt;0 || x&gt;=length || y&lt;0 || y&gt;=width || plot!...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 572 - Oil Deposits (油田) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-572-oil-deposits-%E6%B2%B9%E7%94%B0-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 679 - Dropping Balls (小球下落) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-6 小球下落（Dropping Balls, UVa 679）
有一棵二叉树，最大深度为D，且所有叶子的深度都相同。所有结点从上到下从左到右
编号为1, 2, 3,…, 2D-1。在结点1处放一个小球，它会往下落。每个内结点上都有一个开关，
初始全部关闭，当每次有小球落到一个开关上时，状态都会改变。当小球到达一个内结点
时，如果该结点上的开关关闭，则往左走，否则往右走，直到走到叶子结点，如图所
示。
一些小球从结点1处依次开始下落，最后一个小球将会落到哪里呢？输入叶子深度D和
小球个数I，输出第I个小球最后所在的叶子编号。假设I不超过整棵树的叶子个数。D≤20。
输入最多包含1000组数据。
样例输入：
6
4 2
3 4
10 1
2 2
8 128
16 12345
-1
样例输出：
12
7
512
3
255
36358
本家链接
最简单能想到的就是模拟，模拟球的下落，但是输入一旦大了就超时了。 所以我们可以，找规律。 首先假设有6层，我们来扔球看看情况
球数 落下位置（最后一行,第一个为0计数） 0 0 1 16 2 8 3 24 4 4 5 20 6 12 7 28 8 2 9 18 10 10 11 26 12 6 13 22 14 14 15 30 --- 16 1 17 17 18 9 19 25 20 5 21 21 22 13 23 29 24 3 25 19 26 11 27 27 28 7 29 23 30 15 31 31 ==== 第33开始轮回 === 32 0 33 16 34 8 35 24 36 4 37 20 38 12 39 28 发现规律了吧。...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 679 - Dropping Balls (小球下落) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-679-dropping-balls-%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 699 - The Falling Leaves (落叶) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-10 下落的树叶（The Falling Leaves, UVa 699）
给一棵二叉树，每个结点都有一个水平位
置：左子结点在它左边1个单位，右子结点在右
边1个单位。从左向右输出每个水平位置的所有
结点的权值之和。如图6-7所示，从左到右的3个
位置的权和分别为7，11，3。按照递归（先序）
方式输入，用-1表示空树。
样例输入：
5 7 -1 6 -1 -1 3 -1 -1
8 2 9 -1 -1 6 5 -1 -1 12 -1
-1 3 7 -1 -1 -1
-1
样例输出：
Case 1:
7 11 3
Case 2:
9 7 21 15
【注意】 一棵树的输[入可能分为多行。输出最多一行80个（代表树最多80列）
本家地址
一边输入一边记录左右结点的值，放在数组中叠加。唯一的问题就是存在左右子树，无法确定左右范围具体为多少，所以可以采用两种方法：
设定一个最大的范围，80*2-1 范围，选择最中点为root结点，然后左右放置子节点。 将左右子树分开存放，右子树包含根节点，放置一个数组，下标递增代表结点向右扩增。将左子树放置另一个数组，下标递增代表结点向左扩增。如果以根节点为坐标轴0，那么左子树放置的坐标中就是反坐标轴，只是方向相反。 我采用第2种，因为一开始不知道范围（貌似）
#include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int leftTree[100] = {0}; int rightTree[100] = {0}; /* include root */ int leftIndex = 0; int rightIndex = 0; char c; int tree(int index){ int n; cin&gt;&gt;n; if(n!...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 699 - The Falling Leaves (落叶) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-699-the-falling-leaves-%E8%90%BD%E5%8F%B6-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 816 - Abbott‘s Revenge (Abbott的复仇) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-14 Abbott的复仇（Abbott’s Revenge, ACM/ICPC World Finals 2000, UVa 816）
有一个最多包含9*9个交叉点的迷宫。输入起点、离开起点时的朝向和终点，求一条最
短路（多解时任意输出一个即可）。
图6-14 迷宫及走向
这个迷宫的特殊之处在于：进入一个交叉点
的方向（用NEWS这4个字母分别表示北东西
南，即上右左下）不同，允许出去的方向也不
同。例如，1 2 WLF NR ER 表示交叉点(1,2)
（上数第1行，左数第2列）有3个路标（字
符“”只是结束标志），如果进入该交叉点时的
朝向为W（即朝左），则可以左转（L）或者直
行（F）；如果进入时朝向为N或者E则只能右转
（R），如图6-14所示。
注意：初始状态是“刚刚离开入口”，所以即
使出口和入口重合，最短路也不为空。例如，图
6-14中的一条最短路为(3,1) (2,1) (1,1) (1,2)
(2,2) (2,3) (1,3) (1,2) (1,1) (2,1) (2,2) (1,2) (1,3) (2,3) (3,3)。
Sample Input
SAMPLE
3 1 N 3 3
1 1 WL NR *
1 2 WLF NR ER *
1 3 NL ER *
2 1 SL WR NF *...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 816 - Abbott‘s Revenge (Abbott的复仇) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-816-abbotts-revenge-abbott%E7%9A%84%E5%A4%8D%E4%BB%87-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 839 - Not so Mobile （天平）By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-9 天平（Not so Mobile, UVa 839）
输入一个树状天平，根据力矩相等原则判断是否平衡。如图6-5所示，所谓力矩相等，
就是WlDl=WrDr，其中Wl和Wr分别为左右两边砝码的重量，D为距离。
采用递归（先序）方式输入：每个天平的格式为Wl，Dl，Wr，Dr，当Wl或Wr为0时，表
示该“砝码”实际是一个子天平，接下来会描述这个子天平。当Wl=Wr=0时，会先描述左子天
平，然后是右子天平。
样例输入：
1
0 2 0 4
0 3 0 1
1 1 1 1
2 4 4 2
1 6 3 2
Sample Output
YES
【注意】 输出结果之间空一行
本家地址
递归走，一边输入每一结点，一边递归判断这个结点的左结点结果（左子树重量总和）和右结点结果（右子树重量总和）是否满足要求。
这样的话在建立树的时候也就直接计算结束了。
#include&lt;iostream&gt; using namespace std; int lair(){ int wl,dl,wr,dr; cin&gt;&gt;wl&gt;&gt;dl&gt;&gt;wr&gt;&gt;dr; if(wl == 0){ /* have left branch */ wl = lair(); } if(wr == 0){ wr = lair(); } if(wl==0 || wr==0 || wl*dl !...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 839 - Not so Mobile （天平）By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-839-not-so-mobile-%E5%A4%A9%E5%B9%B3by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVa Online Judge 西班牙Valladolid 在线判官 和 uDebug使用简单教程
    </h2>
  </header>
  <div class="entry-content">
    <p>udebug使用在后面
https://uva.onlinejudge.org/
1、这是主界面，如果你还没有账号，那么就点击图中的register。
2、然后就是填写信息，邮箱要用gmail，信息填写完成后点击下方的register
3、之后打开邮箱查看接受的邮件，并点击其中的链接完成注册确认，之后会转到uva oj，如果页面显示 your account is now active.You may now log in!则表示注册完成。
4、然后输入用户名密码登录
5、然后在左边的栏目中，点击Browse Problems 就可以找到有关刘汝佳以及其他一些著名套题了。
6、然后是关于如何答题，现在我们打开了一道题目，看图上红框住的左上角，
（1）其中我们点击PDF，会下载下来本道题的pdf格式文件
（2）我们点击submit就是提交代码了。
其中如果是用的C语言或C&#43;&#43;选择第一个c&#43;&#43;，提交结果没有ac，如果不是代码问题，那么试试选择c&#43;&#43;11吧。
参考了UVAOJ的注册和评测入门
（3）最后我想说一下在看题界面的那个Debug选项，就是旁边有个红色的甲虫的。
若果打不开udebug就挂vpn试试吧
https://www.udebug.com/UVa/1589 （当前是1589号题）
我们点进去后，一共四部分。上左边就是一些用户上传的关于本题的一些样例。点击其中一个，这些样例就会显示在右边的框中。
然后我们点击下方写着Get Accepted Output蓝格，就会在下方的左边出现这些样例的正确输出结果。我们可以把这些样例用我们的代码输出的结果粘到右边的框中。之后点击Compare Outputs 进行对比。
这样我就能很方便的知道我们的代码在处理哪一个样例上出现里问题，更改起来也更有方向性。还有如果出现了图中的情况，明明都对但还是显示不对，那是因为他的输出默认多了一个空行，这个一般和代码没有关系。默认为对就行了。
我们还可以在上面快速搜索你需要的题号。
目前支持这些oj
这是主页https://www.udebug.com/
可以去他的Twitter和Facebook上看看，网上关于udegug的信息不多。</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVa Online Judge 西班牙Valladolid 在线判官 和 uDebug使用简单教程" href="https://sucicada.github.io/blog/posts/uvaoj/uva-online-judge-%E8%A5%BF%E7%8F%AD%E7%89%99valladolid-%E5%9C%A8%E7%BA%BF%E5%88%A4%E5%AE%98-%E5%92%8C-udebug%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva1583 - Digit Generator （生成元）
    </h2>
  </header>
  <div class="entry-content">
    <p>如果x加上x的各个数字之和得到y，就说x是y的生成元。给出n（1≤n≤100000），求最小
生成元。无解输出0。例如，n=216，121，2005时的解分别为198，0，1979。
Sample Input
3
216
121
2005
Sample Output
198
0
1979
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=829&amp;page=show_problem&amp;problem=4458
//先算出所有的生成元x的原数y，以s[y]=x的形式将其存起，在求y的解x的时候，直接输出是s[y]即可 //所以为了求最小生成元也就是x，就要从尾到头的循环算y。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string.h&gt; using namespace std; int const N = 100000; int sn[N&#43;5]={0}; int main() { memset(sn,0,sizeof(sn)); for(int i=N;i&gt;=0;i--) { int n=i; int s=i; while(n&gt;0) { s&#43;=n%10; n/=10; } sn[s]=i; } //for(int i=0;i&lt;N;i&#43;&#43;) // cout&lt;&lt;sn[i]&lt;&lt;&#34; &#34;; // cout&lt;&lt;endl; int n,T; cin&gt;&gt;T; while(T--) { int i; cin&gt;&gt;n; cout&lt;&lt;sn[n]&lt;&lt;endl; } return 0; } //AC at 2017/12/7 以下算法虽然一样可以算出正确答案，但是超时，oj不通过。...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva1583 - Digit Generator （生成元）" href="https://sucicada.github.io/blog/posts/uvaoj/uva1583-digit-generator-%E7%94%9F%E6%88%90%E5%85%83/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva272 （TeX）
    </h2>
  </header>
  <div class="entry-content">
    <p>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=829&amp;page=show_problem&amp;problem=208
TEX is a typesetting language developed by Donald Knuth. It takes source text together with a few
typesetting instructions and produces, one hopes, a beautiful document. Beautiful documents use “
and ” to delimit quotations, rather than the mundane &#34; which is what is provided by most keyboards.
Keyboards typically do not have an oriented double-quote, but they do have a left-single-quote and a right-single-quote &#39;. Check your keyboard now to locate the left-single-quote key (sometimes...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva272 （TeX）" href="https://sucicada.github.io/blog/posts/uvaoj/uva272-tex/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>刘汝佳p35,2-6（123排列）算法竞赛入门经典第二版
    </h2>
  </header>
  <div class="entry-content">
    <p>算法竞赛入门经典第二版
刘汝佳p35 , 2-6
用1,2,3，….，9组成3个三位数abc，def和ghi，每个数字恰好使用一次，要求abc:def:ghi=1:2:3。输出所有解。
#include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int nn(int a,int *n) { //cout&lt;&lt;&#34;a&#34;&lt;&lt;a&lt;&lt;endl; for(int i=0;i&lt;8;i&#43;&#43;) { if(a==n[i]) { //cout&lt;&lt;n[i]&lt;&lt;endl; n[i]=-1; return 0; } } return 1; } void num(int a) { int n[9]; for(int i=0;i&lt;8;i&#43;&#43;) n[i]=i&#43;1; int b=a*2; int c=a*3; int s[9]; s[0]=a/100; s[1]=(a/10)%10; s[2]=a%10; s[3]=b/100; s[4]=(b/10)%10; s[5]=b%10; s[6]=c/100; s[7]=(c/10)%10; s[8]=c%10; for(int i=0;i&lt;8;i&#43;&#43;) { //cout&lt;&lt;&#34;si&#34;&lt;&lt;s[i]&lt;&lt;endl; if(nn(s[i],n)==1) { //cout&lt;&lt;&#34;return&#34;&lt;&lt;endl; return; } } cout&lt;&lt;a&lt;&lt;&#34; &#34;&lt;&lt;b&lt;&lt;&#34; &#34;&lt;&lt;c&lt;&lt;endl; } int main() { for(int a=100;a&lt;=333;a&#43;&#43;) { num(a); } return 0; } 所以结果是...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 刘汝佳p35,2-6（123排列）算法竞赛入门经典第二版" href="https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p352-6123%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>判断字符是否为字母或数字
    </h2>
  </header>
  <div class="entry-content">
    <p>参考：
C语言中isalnum()函数和isalpha()函数的对比使用
C语言 判断字符的大小写 isalpha()函数
#include&lt;ctype.h&gt;//或&lt;cctype&gt; int isalpha(int ch)//为英文字母时返回不一定为1的非零，否则返回零 isalnum(c)//判断c是否为英文字母或数字 isupper(c)//判断c是否为大写英文字母 islower(c)//判断c是否为小写英文字母 isdigit(c)//判断c是否为数字 以上若不是所判断字符类型则都返回零</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 判断字符是否为字母或数字" href="https://sucicada.github.io/blog/posts/soft/%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%97%E6%AF%8D%E6%88%96%E6%95%B0%E5%AD%97/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>十六进制转十进制.h
    </h2>
  </header>
  <div class="entry-content">
    <p>#include&lt;stdio.h&gt; #include&lt;ctype.h&gt; int sc(char a[])//传进来代表十六进制的字符串数组，返回十进制 { int i,n=0,t; for(i=0;a[i];i&#43;&#43;) { a[i]=toupper(a[i]); if(a[i]&gt;=&#39;A&#39;) t=a[i]-&#39;A&#39;&#43;10; else t=a[i]-&#39;0&#39;; n=n*16&#43;t; } return n; } </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 十六进制转十进制.h" href="https://sucicada.github.io/blog/posts/soft/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6.h/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>控制台光标移动(有尾迹）
    </h2>
  </header>
  <div class="entry-content">
    <p>更改了网上的代码，实现有尾迹的移动，
用键盘上的上下左右来控制
这是借鉴地址：C语言之实现控制台光标随意移动
#include &lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;conio.h&gt; HANDLE hout; //获得输入 char getInput() { int ch; //输入字符串 COORD coord; //屏幕上的坐标 CONSOLE_SCREEN_BUFFER_INFO csbi; //控制台屏幕缓冲区信息 coord.X=11; coord.Y=10; ch=getch(); csbi.dwCursorPosition.X=11; csbi.dwCursorPosition.Y=10; //0x0d表示回车，0XE0表示上下左右等键的键码 while(ch==0xE0||ch==0x0d) { GetConsoleScreenBufferInfo(hout,&amp;csbi);//读取控制台屏幕缓冲信息 coord.X=csbi.dwCursorPosition.X; //得到坐标X的值 coord.Y=csbi.dwCursorPosition.Y; //得到坐标Y的值 ch=getch(); //printf(&#34; &#34;); //上 if(ch==0x48) { if(coord.Y!=0) { coord.Y--; //printf(&#34;%c&#34;,&#39;A&#39;); } } //下 else if(ch==0x50) { coord.Y&#43;&#43;; //printf(&#34;%c&#34;,&#39;A&#39;); } //左 else if(ch==0x4b) { if(coord.X!=0){coord.X--;}//printf(&#34;%c&#34;,&#39;A&#39;);} } //右 else if(ch==0x4d) { if(coord.X!=79) { coord.X&#43;&#43;; //printf(&#34;%c&#34;,&#39;A&#39;); } } printf(&#34;%c&#34;,&#39;....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 控制台光标移动(有尾迹）" href="https://sucicada.github.io/blog/posts/soft/%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E6%9C%89%E5%B0%BE%E8%BF%B9/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>数学必知必会-导数、梯度与积分
    </h2>
  </header>
  <div class="entry-content">
    <p>(238条消息) 数学必知必会—-导数、梯度与积分_sakura小樱的博客-CSDN博客_梯度求积分 数学必知必会—-导数、梯度与积分 sakura小樱 于 2018-06-12 19:18:22 发布 3204 收藏 6
文章标签： 导数 数学 微积分
版权
一、导数 1.1常用的倒数 1.2复合函数求导 1.2.1链式法则 1.2.2多元函数求导：偏导数（偏微分） 二、积分 定积分 不定积分 拓展 三、均方误差 3.1导数应用 3.2线性回归的应用 四、梯度 4.1导入 4.2定义： 4.3事例 4.4理解方法 4.5梯度下降法定义 4.6局部极限值 4.7下降法求最小值方法 4.7.1抛小球法—momentum 4.7.2Nesterov 4.7.3自适应 4.7.4AdaDelta以及RMSprop 4.7.5选择 from sympy import * x=Symbol(&#34;x&#34;) diff(x**3 &#43; x**2) #3x**2 &#43; 2**x 一、导数 导数的实质就是曲线切线的斜率
1.1常用的倒数 1.2复合函数求导 1.2.1链式法则 1.2.2多元函数求导：偏导数（偏微分） 链式法则
多元函数求导的法则
二、积分 积分是微分的逆运算，即知道了函数的 导函数，反求原函数。在应用上，积分作用不仅如此，它被大量应用于求和，通俗的说是求 曲边三角形的面积，这巧妙的求解方法是积分特殊的性质决定的。
更多推导公式点击这里
定积分 不定积分 拓展 ● 微分的相关知识...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 数学必知必会-导数、梯度与积分" href="https://sucicada.github.io/blog/posts/math/%E6%95%B0%E5%AD%A6%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%AF%BC%E6%95%B0%E6%A2%AF%E5%BA%A6%E4%B8%8E%E7%A7%AF%E5%88%86/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>求int型的最大取值（正数）
    </h2>
  </header>
  <div class="entry-content">
    <p>用的是夹值法
#include&lt;stdio.h&gt; int main(){ int i=1,n=1,m; do { n=i; i=i*2; printf(&#34;%d\n&#34;,n); } while((i/2)==n);//n是存数，i去趟雷 putchar(&#39;\n&#39;); m=n; for(;;) { n=m; m&#43;=1; if((m-1)!=n) { printf(&#34;break&#34;); break; } else m-=1; i=1; while(1) { if(i!=1) if((n-i/2)!=m) { printf(&#34;int %d\n&#34;,m); return; } printf(&#34;!!!\n&#34;); if(i!=1) m=n;//m是存数，n去趟雷 n=n&#43;i; i*=2; printf(&#34;%d %d\n&#34;,m,n); } } getchar(); return 0; } 最大值：2147483647</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 求int型的最大取值（正数）" href="https://sucicada.github.io/blog/posts/soft/%E6%B1%82int%E5%9E%8B%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8F%96%E5%80%BC%E6%AD%A3%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>求最长回文子串
    </h2>
  </header>
  <div class="entry-content">
    <p>一段字符串中出现的正反读一样的子串
当时自己写下的泛泛之词
#include&lt;stdio.h&gt; #define N 20 int main() { char a[N]=&#34;abcb&#34;; char b[N]=&#34;0000&#34;; int i,j,m; for(i=0;i&lt;strlen(a)/2;i&#43;&#43;) { for(j=i&#43;1;j&lt;strlen(a);j&#43;&#43;) { if(a[i]==a[j]) { printf(&#34;%d %d %d &#34;,i,j ,m); for(m=i;m&lt;=j;m&#43;&#43;) { if(a[m]!=a[j&#43;i-m]) break; b[m-i]=a[m]; b[j-i-m]=a[j&#43;i-m]; if((m==j&#43;i-m)||(m==j&#43;i-m-1)) i=j; printf(&#34;%s\n&#34;,b); } } } } printf(&#34;%s\n&#34;,b); return 0; } </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 求最长回文子串" href="https://sucicada.github.io/blog/posts/soft/%E6%B1%82%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>颠倒字符串（整体，子串）
    </h2>
  </header>
  <div class="entry-content">
    <p>这是对整体的字符串镜像
#include &lt;stdio.h&gt; int main(void) { char a[9] = &#34;abcdef&#34;; int i,j;//j是最后一位，i是执行位 j=strlen(a)-1; printf(&#34;%s\n&#34;,a); for(i=0;i&lt;strlen(a)/2;i&#43;&#43;) { a[i]&#43;=a[j-i]; a[j-i]=a[i]-a[j-i]; a[i]=a[i]-a[j-i]; printf(&#34;%s\n&#34;,a); } return 0; } 这是对子串镜像
#include &lt;stdio.h&gt; int main(void) { char a[] = &#34;012 4567 910&#34;; int i,j,t;//j是最后一位，i是执行位 j=7; t=i=4;//t记录下变换部分的第一位 printf(&#34;%s\n&#34;,a); for(;i&lt;(j&#43;t&#43;1)/2;i&#43;&#43;) { a[i]&#43;=a[j-i&#43;t]; a[j-i&#43;t]=a[i]-a[j-i&#43;t]; a[i]=a[i]-a[j-i&#43;t]; printf(&#34;%s\n&#34;,a); } return 0; } </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 颠倒字符串（整体，子串）" href="https://sucicada.github.io/blog/posts/soft/%E9%A2%A0%E5%80%92%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B4%E4%BD%93%E5%AD%90%E4%B8%B2/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://sucicada.github.io/blog/posts/page/3/">
      «&nbsp;Prev&nbsp;
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://sucicada.github.io/blog">SuCicada</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
