<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | SuCicada</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - SuCicada">
<meta name="author" content="SuCicada">
<link rel="canonical" href="https://sucicada.github.io/blog/posts/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.5b5501da54f21435c8f8010d1de02123ae8d1ada696b48c6530ec4eea283e7d6.css" integrity="sha256-W1UB2lTyFDXI&#43;AENHeAhI66NGtppa0jGUw7E7qKD59Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sucicada.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sucicada.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sucicada.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sucicada.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://sucicada.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://sucicada.github.io/blog/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Posts" />
<meta property="og:description" content="SuCicada - https://github.com/SuCicada" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://sucicada.github.io/blog/posts/" /><meta property="og:image" content="https://sucicada.github.io/blog/papermod-cover.png"/>

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://sucicada.github.io/blog/papermod-cover.png"/>

<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content="SuCicada - https://github.com/SuCicada"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://sucicada.github.io/blog/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sucicada.github.io/blog" accesskey="h" title="SuCicada (Alt + H)">SuCicada</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sucicada.github.io/blog/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://sucicada.github.io/blog/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://sucicada.github.io/blog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://sucicada.github.io/blog/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://sucicada.github.io/blog">Home</a></div>
  <h1>
    Posts
    <a href="index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 213 - Message Decoding（二进制编码）
    </h2>
  </header>
  <div class="entry-content">
    <p>例题4-4 信息解码（Message Decoding, ACM/ICPC World Finals 1991, UVa 213）
考虑下面的01串序列：
0, 00, 01, 10, 000, 001, 010, 011, 100, 101, 110, 0000, 0001, …, 1101, 1110, 00000, …
首先是长度为1的串，然后是长度为2的串，依此类推。如果看成二进制，相同长度的后
一个串等于前一个串加1。注意上述序列中不存在全为1的串。
你的任务是编写一个解码程序。首先输入一个编码头（例如AB#TANCnrtXc），则上述
序列的每个串依次对应编码头的每个字符。例如，0对应A，00对应B，01对应#，…，110对
应X，0000对应c。接下来是编码文本（可能由多行组成，你应当把它们拼成一个长长的01
串）。编码文本由多个小节组成，每个小节的前3个数字代表小节中每个编码的长度（用二
进制表示，例如010代表长度为2），然后是各个字符的编码，以全1结束（例如，编码长度
为2的小节以11结束）。编码文本以编码长度为000的小节结束。
例如，编码头为$#\，编码文本为0100000101101100011100101000，应这样解码：
010(编码长度为2)00(#)00(#)10(*)11(小节结束)011(编码长度为3)000()111(小节结束)001(编码
长度为1)0($)1(小节结束)000(编码结束)。
Sample input
TNM AEIOU
0010101100011
1010001001110110011
11000
$#
0100000101101100011100101000
Sample output
TAN ME
##*$
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=832&amp;problem=149&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;20759428
/* 1、先接收字符串，因为有空格，所以我用了getline，因为我用string 2、然后我们将输入的字符串存入code这个二维数组里，code[i][j]中i代表二进制码的位数，j代表当前01码的十进制数。以此我们每次循环的j小于2^i-i即可。 3、然后我们用循环，先将三位的二进制数传入bin_dec()函数，来得出接下来代表一个字符的二进制码的位数。 4、contra()函数是用来进行每一组相同码长的字符的输出。 （1）其思路是用一个变量记录当前bcode（01码字符串）读到哪个位了。 （2）然后循环将之后的len位二进制变成一个整数，传入bin_dec()函数得出其代表的十进制数，而这个十进制数也是code数组的第二维的下标。 5、还有一点，因为二进制码在输入的过程中并不一定是在同一行,所以我用了：当前下标&#43;要接受的码长 和 当前的01码字符串长度来进行比较，若大则接收新的一行字符串，再加到原先01码字符串后面。（！注意这里用的是while循环而不是单一次的if判断，是因为可能接收一次字串后也依然不够码长，所以要一直接收到足够长为止。）*/ #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;string&gt; #include&lt;cstring&gt; using namespace std; char code[7][1&lt;&lt;7];//长度，值，来存字符 int bin_dec(int b)//二进制转十进制 { int dec=0; for(int i=0;b!...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 213 - Message Decoding（二进制编码）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-213-message-decoding%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 220 - Othello（黑白翻转棋）
    </h2>
  </header>
  <div class="entry-content">
    <p>习题4-3 黑白棋（Othello, ACM/ICPC World Finals 1992, UVa220）
你的任务是模拟黑白棋游戏的进程。黑白棋的规则为：黑白双方轮流放棋子，每次必须
让新放的棋子“夹住”至少一枚对方棋子，然后把所有被新放棋子“夹住”的对方棋子替换成己
方棋子。一段连续（横、竖或者斜向）的同色棋子被“夹住”的条件是两端都是对方棋子（不
能是空位）。如图4-6（a）所示，白棋有6个合法操作，分别为(2,3),(3,3),(3,5), (6,2),(7,3),
(7,4)。选择在(7,3)放白棋后变成如图4-6（b）所示效果（注意有竖向和斜向的共两枚黑棋变
白）。注意(4,6)的黑色棋子虽然被夹住，但不是被新放的棋子夹住，因此不变白。
（a） （b）
图4-6 黑白棋
输入一个8*8的棋盘以及当前下一次操作的游戏者，处理3种指令：
L指令打印所有合法操作，按照从上到下，从左到右的顺序排列（没有合法操作时输出No legal move）。
Mrc指令放一枚棋子在(r,c)。如果当前游戏者没有合法操作，则是先切换游戏者再操作。输入保证这个操作是合法的。输出操作完毕后黑白方的棋子总数。
Q指令退出游戏，并打印当前棋盘（格式同输入）。
Sample Input
2
-——-
-——-
-——-
—WB—
-–BW—
-——-
-——-
-——-
W
L
M35
L
Q
WWWWB—
WWWB—-
WWB—–
WB——
-——-
-——-
-——-
-——-
B
L
M25
L
Q
Sample Output
(3,5) (4,6) (5,3) (6,4)
Black - 1 White - 4
(3,4) (3,6) (5,6)
-——-...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 220 - Othello（黑白翻转棋）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-220-othello%E9%BB%91%E7%99%BD%E7%BF%BB%E8%BD%AC%E6%A3%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 221 - Urban Elevations(城市正视图) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题5-12 城市正视图（Urban Elevations, ACM/ICPC World Finals 1992, UVa221）
如图5-4所示，有n（n≤100）个建筑物。左侧是俯视图（左上角为建筑物编号，右下角
为高度），右侧是从南向北看的正视图。
图5-4 建筑俯视图与正视图
输入每个建筑物左下角坐标（即x、y坐标的最小值）、宽度（即x方向的长度）、深度
（即y方向的长度）和高度（以上数据均为实数），输出正视图中能看到的所有建筑物，按
照左下角x坐标从小到大进行排序。左下角x坐标相同时，按y坐标从小到大排序。
输入保证不同的x坐标不会很接近（即任意两个x坐标要么完全相同，要么差别足够大，
不会引起精度问题）。
Sample Input
14
160 0 30 60 30
125 0 32 28 60
95 0 27 28 40
70 35 19 55 90
0 0 60 35 80
0 40 29 20 60
35 40 25 45 80
0 67 25 20 50
0 92 90 20 80
95 38 55 12 50...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 221 - Urban Elevations(城市正视图) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-221-urban-elevations%E5%9F%8E%E5%B8%82%E6%AD%A3%E8%A7%86%E5%9B%BE-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 227 - Puzzle （迷宫中的空格）
    </h2>
  </header>
  <div class="entry-content">
    <p>习题3-5 谜题（Puzzle, ACM/ICPC World Finals 1993, UVa227）
有一个5*5的网格，其中恰好有一个格子是空的，其他格子各有一个字母。一共有4种指
令：A, B, L, R，分别表示把空格上、下、左、右的相邻字母移到空格中。输入初始网格和指
令序列（以数字0结束），输出指令执行完毕后的网格。如果有非法指令，应输出“This
puzzle has no final configuration.
还有：输入的迷宫以大写 Z 结束。输出的行与行间要有一行空行
Sample Input
TRGSJ
XDOKI
M VLN
WPABE
UQHCF
ARRBBL0
ABCDE
FGHIJ
KLMNO
PQRS
TUVWX
AAA
LLLL0
ABCDE
FGHIJ
KLMNO
PQRS
TUVWX
AAAAABBRRRLL0
Z
Sample Output
Puzzle #1:
T R G S J
X O K L I
M D V B N
W P A E
U Q H C F...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 227 - Puzzle （迷宫中的空格）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-227-puzzle-%E8%BF%B7%E5%AE%AB%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 232 - Crossword Answers（纵横迷宫）
    </h2>
  </header>
  <div class="entry-content">
    <p>习题3-6 纵横字谜的答案（Crossword Answers, ACM/ICPC World Finals 1994,
UVa232）
输入一个r行c列（1≤r，c≤10）的网格，黑格用“*”表示，每个白格都填有一个字母。如
果一个白格的左边相邻位置或者上边相邻位置没有白格（可能是黑格，也可能出了网格边
界），则称这个白格是一个起始格。
首先把所有起始格按照从上到下、从左到右的顺序编号为1, 2, 3,…，如图所示。
接下来要找出所有横向单词（Across）。这些单词必须从一个起始格开始，向右延伸到
一个黑格的左边或者整个网格的最右列。最后找出所有竖向单词（Down）。这些单词必须
从一个起始格开始，向下延伸到一个黑格的上边或者整个网格的最下行。
输出时每两行之间有空行
Sample Input
2 2
AT
O
6 7
AIMDEN
MEONE
UPONTO
SOERIN
SAOR*
IES*DEA
0
Sample Output
puzzle #1:
Across
1.AT
3.O
Down
1.A
2.TO
puzzle #2:
Across
1.AIM
4.DEN
7.ME
8.ONE
9.UPON
11.TO
12.SO
13.ERIN
15.SA
17.OR
18.IES
19.DEA
Down
1.A
2.IMPOSE
3.MEO
4.DO
5.ENTIRE
6.NEON
9.US
10.NE
14.ROD
16.AS...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 232 - Crossword Answers（纵横迷宫）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-232-crossword-answers%E7%BA%B5%E6%A8%AA%E8%BF%B7%E5%AE%AB/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 253 - Cube painting（相同骰子）
    </h2>
  </header>
  <div class="entry-content">
    <p>习题4-4 骰子涂色（Cube painting, UVa 253）
输入两个骰子，判断二者是否等价。每个骰子用6个字母表示，如图4-7所示。
图4-7 骰子涂色
例如rbgggr和rggbgr分别表示如图4-8所示的两个骰子。二者是等价的，因为图4-8（a）
所示的骰子沿着竖直轴旋转90°之后就可以得到图4-8（b）所示的骰子。
（a） （b）
图4-8 旋转前后的两个骰子
.
Sample Input
rbgggrrggbgr
rrrbbbrrbbbr
rbgrbgrrrrrg
Sample Output
TRUE
FALSE
FALSE
思路：暴力枚举，将一个骰子的所有姿态都列出来，
1、注意第一个图上的数字，那个是记录骰子面的顺序
2、先找最上面的，也就是1的位置，能排列6种（1，2，3，4，5，6）
3、然后找到了上面也就找到了与其相对的面，就是下面，就是字串中第六个元素。这个不会额外记录，因为有上就有下了。
4、然后就是中间四个的排列了，很显然，4种。
5、然后我们变换第二个骰子，看看它在这24种情况中，有没有一种的情况和第一个骰子的记录是相同的。（比较字串即可）
6、请注意骰子面的转换是否正确，虽然这个逻辑简单，但是容易写错，要好好检查，我就因为写错下标错了两次。
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; /* 1 3 2 4 5 1在顶上 6 2 3 6 4 1 2在顶上 5 3 5 6 2 1	3在顶上 4 4 2 6 5 1	4在顶上 3 5 4 6 3 1	5在顶上 2 6 3 5 4 2	6在顶上 1 */ string s1,s2;//记录两个骰子的字符串 int str_equal(string a,char s1,char s2,char s3,char s4,char s5,char s6)//比较两个字串相等吗 { string b=&#34;0000000&#34;; b[1]=s1; b[2]=s2; b[3]=s3; b[4]=s4; b[5]=s5; b[6]=s6; //cout&lt;&lt;b....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 253 - Cube painting（相同骰子）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-253-cube-painting%E7%9B%B8%E5%90%8C%E9%AA%B0%E5%AD%90/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 297 - Quadtrees （四分数） By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-11 四分树（Quadtrees, UVa 297）
如图6-8所示，可以用四分树来表示一个黑白图像，方法是用根结点表示整幅图像，然
后把行列各分成两等分，按照图中的方式编号，从左到右对应4个子结点。如果某子结点对
应的区域全黑或者全白，则直接用一个黑结点或者白结点表示；如果既有黑又有白，则用一
个灰结点表示，并且为这个区域递归建树。
图6-8 四分树
给出两棵四分树的先序遍历，求二者合并之后（黑色部分合并）黑色像素的个数。p表
示中间结点，f表示黑色（full），e表示白色（empty）。
样例输入：
3
ppeeefpffeefe
pefepeefe
peeef
peefe
peeef
peepefefe
样例输出：
There are 640 black pixels.
There are 512 black pixels.
There are 384 black pixels.
本家
构造32*32的矩阵，构建树木的时候同时给矩阵染色，由于黑色会覆盖，所以也不怕树木之间的冲突。然后最后刷一下矩阵，看看有多少个黑块块就行（即数字为1）
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;cmath&gt; using namespace std; /* 共5&#43;1层 32*32=4^5 */ int SIDE_LENGTH = 32; int quad[100][100]; int sum = 0; /* f &gt; p &gt; e */ void build(int side,int x,int y){ char c; cin&gt;&gt;c; if(c==&#39;p&#39;){ for(int xi=0;xi&lt;=1;xi&#43;&#43;){ for(int yi=0;yi&lt;=1;yi&#43;&#43;){ int nextSide = side / 2; int xx = x&#43;nextSide*xi; int yy = y&#43;nextSide*yi; build(nextSide,xx,yy); } } }else if(c==&#39;f&#39;){ /* fill $quad from $begin to $end */ for(int xi=x;xi&lt;x&#43;side;xi&#43;&#43;){ for(int yi=y;yi&lt;y&#43;side;yi&#43;&#43;){ if(quad[xi][yi]==0){ sum&#43;&#43;; quad[xi][yi] = 1; } } } } } int main(){ int T; cin&gt;&gt;T; while(T--){ // memset(quad,0,SIDE_LENGTH*SIDE_LENGTH*sizeof(int)); for(int i=0;i&lt;SIDE_LENGTH;i&#43;&#43;){ for(int j=0;j&lt;SIDE_LENGTH;j&#43;&#43;){ quad[i][j]=0; } } sum = 0; for(int i=0;i&lt;2;i&#43;&#43;){ build(SIDE_LENGTH,0,0); } cout&lt;&lt;&#34;There are &#34;&lt;&lt;sum&lt;&lt;&#34; black pixels....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 297 - Quadtrees （四分数） By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-297-quadtrees-%E5%9B%9B%E5%88%86%E6%95%B0-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 340 	Master-Mind Hints（猜数串）
    </h2>
  </header>
  <div class="entry-content">
    <p>实现一个经典&#34;猜数字&#34;游戏。给定答案序列和用户猜的序列，统计有多少数字位置正确
（A），有多少数字在两个序列都出现过但位置不对（B）。
输入包含多组数据。每组输入第一行为序列长度n，第二行是答案序列，接下来是若干
猜测序列。猜测序列全0时该组数据结束。n=0时输入结束。
样例输入：
4
1 3 5 5
1 1 2 3
4 3 3 5
6 5 5 1
6 1 3 5
1 3 5 5
0 0 0 0
10
1 2 2 2 4 5 6 6 6 9
1 2 3 4 5 6 7 8 9 1
1 1 2 2 3 3 4 4 5 5
1 2 1 3 1 5 1 6 1 9...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 340 	Master-Mind Hints（猜数串）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-340-master-mind-hints%E7%8C%9C%E6%95%B0%E4%B8%B2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 400 - Unix ls (Unixls命令)
    </h2>
  </header>
  <div class="entry-content">
    <p>例题5-8 Unixls命令（Unix ls，UVa400） 输入正整数n以及n个文件名，按照字典序排序后按列优先的方式左对齐输出。 假设最长文件名有M字符，则最右列有M字符，其他列都是M＋2字符。
Sample Input
10
tiny
2short4me
very_long_file_name
shorter
size-1
size2
size3
much_longer_name
12345678.123
mid_size_name
12
Weaser
Alfalfa
Stimey
Buckwheat
Porky
Joe
Darla
Cotton
Butch
Froggy
Mrs_Crabapple
P.D.
19
Mr._French
Jody
Buffy
Sissy
Keith
Danny
Lori
Chris
Shirley
Marsha
Jan
Cindy
Carol
Mike
Greg
Peter
Bobby
Alice
Ruben
Sample Output
------------------------------------------------------------ 12345678.123 size-1 2short4me size2 mid_size_name size3 much_longer_name tiny shorter very_long_file_name ------------------------------------------------------------ Alfalfa Cotton Joe Porky Buckwheat Darla Mrs_Crabapple Stimey Butch Froggy P....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 400 - Unix ls (Unixls命令)" href="https://sucicada.github.io/blog/posts/uvaoj/uva-400-unix-ls-unixls%E5%91%BD%E4%BB%A4/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 401（回文词）
    </h2>
  </header>
  <div class="entry-content">
    <p>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=829&amp;problem=342&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;20398535
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;string.h&gt; using namespace std; string r=&#34;A 3 HIL JM O 2TUVWXY501SE Z 8 &#34;; char *m_c=&#34;AHIMOTUVWXY018&#34;; char mir_c(char c) { if(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;) { c=r[c-&#39;A&#39;]; } else if(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;)//如果不是else if 那么变成2的S又会变回S c=r[c-&#39;0&#39;&#43;26]; return c; } int main() { string s; while(cin&gt;&gt;s) { int n=s.size(); int m1=2,m2=3,i;//先判断对称，再判断镜像 for(i=0;i&lt;n/2;i&#43;&#43;) { if(s[i]!=s[n-i-1]) m1=1; if(mir_c(s[i])!=s[n-i-1]) { //cout&lt;&lt;mir_c(s[i])&lt;&lt;&#34; &#34;&lt;&lt;s[n-i-1]; m2=1; } } if((n%2==1)&amp;&amp;strchr(m_c,s[n/2])==NULL) m2=1;//判断中间一位是不是镜像的 //cout&lt;&lt;m1&lt;&lt;&#34; &#34;&lt;&lt;m2&lt;&lt;&#34; &#34;; cout&lt;&lt;s; switch(m1*=m2) { case 1:cout&lt;&lt;&#34; -- is not a palindrome....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 401（回文词）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-401%E5%9B%9E%E6%96%87%E8%AF%8D/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 455 - Periodic Strings （找字符串周期）
    </h2>
  </header>
  <div class="entry-content">
    <p>习题3-4 周期串（Periodic Strings, UVa455）
如果一个字符串可以由某个长度为k的字符串重复多次得到，则称该串以k为周期。例
如，abcabcabcabc以3为周期（注意，它也以6和12为周期）。
输入一个长度不超过80的字符串，输出其最小周期。
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=830&amp;problem=396&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;20473859
//先找到和第一个元素相等的下一个元素，然后第一个元素位和找到的元素位依次往后过， //一直到结束，若一直一样则周期为找到的元素位。 //比如ababcababc， //1.s[0]先找到了和s[1]相等,然后分析， //2.s[0&#43;1]和s[1&#43;1]比，相等。 //3.s[0&#43;1&#43;1]再和s[1&#43;1&#43;1],不等，跳出 //4.s[0]再和s[2],s[3],s[4]比。。。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string.h&gt; using namespace std; const int N = 80; char s[N&#43;5]; int cir(int i) { int n=strlen(s); if(n%i!=0)//防止aba或abca输出2或3而不是3或4的情况 return 0; for(int j=i;j&lt;strlen(s);j&#43;&#43;)//顺次比较前后字串相等否 { if(s[j-i]!=s[j]) { return 0; } } return i; } int main () { int tt; scanf(&#34;%d&#34;,&amp;tt); while(tt--) { scanf(&#34;\n%s&#34;,s); int T=0;//周期 int i,n=strlen(s); for(i=1;i&lt;n;i&#43;&#43;) { if(s[0]==s[i]) { if((T=cir(i))==i) { break; } } } cout&lt;&lt;i&lt;&lt;endl; if(tt!...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 455 - Periodic Strings （找字符串周期）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-455-periodic-strings-%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%A8%E6%9C%9F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 489 - Hangman Judge（吊人游戏）
    </h2>
  </header>
  <div class="entry-content">
    <p>例题4-2 刽子手游戏（Hangman Judge, UVa 489）
刽子手游戏其实是一款猜单词游戏，如图4-
1所示。游戏规则是这样的：计算机想一个单词
让你猜，你每次可以猜一个字母。如果单词里有
那个字母，所有该字母会显示出来；如果没有那
个字母，则计算机会在一幅“刽子手”画上填一
笔。这幅画一共需要7笔就能完成，因此你最多
只能错6次。注意，猜一个已经猜过的字母不！算
错。
在本题中，你的任务是编写一个“裁判”程
序，输入单词和玩家的猜测，判断玩家赢了
（You win.）、输了（You lose.）还是放弃了
（You chickened out.）。每组数据包含3行，第1
行是游戏编号（-1为输入结束标记），第2行是
计算机想的单词，第3行是玩家的猜测。后两行
保证只含小写字母。
注意，猜一个已经猜过的字母不算
错。！
Sample Input
1
cheese
chese
2
cheese
abcdefg
3
cheese
abcdefgij
-1
Sample Output
Round 1
You win.
Round 2
You chickened out.
Round 3
You lose.
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=832&amp;page=show_problem&amp;problem=430
用两个整型来记录当前还允许错的次数，和原始字符串的总字符数
1，因为重复猜测不算错，所以我们先将guess字符串中的重复字符消去，用循环和string::erase()
2，外循环猜测字符串，内循环原始字符串，如果相同，就将原始字符串的此元素变成‘ * ’。
3，没猜中一次就记录，内循环结束后来更新记录。若果win或lose就return函数，否则循环都结束之后就说明是‘弃权’。
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; string orig,guess; int hang(int num,int right) { for(int i=0;i&lt;guess....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 489 - Hangman Judge（吊人游戏）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-489-hangman-judge%E5%90%8A%E4%BA%BA%E6%B8%B8%E6%88%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 508 - Morse Mismatches（摩斯码）
    </h2>
  </header>
  <div class="entry-content">
    <p>习题4-6 莫尔斯电码（Morse Mismatches, ACM/ICPC World Finals 1997, UVa508）
输入每个字母的Morse编码，一个词典以及若干个编码。对于每个编码，判断它可能是
哪个单词。如果有多个单词精确匹配，选取字典序第一个再加上“!”；如果无法精确匹
配，可以在编码尾部增加或删除一些字符以后匹配某个单词（增加或删除的字符应尽量少）。如果有多个单词可以这样匹配上，选取字典序第一个输出并且在后面加上“?”。
。
提供一个样例
Sample Input
A .-
B -…
C -.-.
D -..
E .
F ..-.
G –.
H ….
I ..
J .—
K -.-
L .-..
M –
N -.
O —
P .–.
Q –.-
R .-.
S …
T -
U ..-
V …-
W .–
X -..-
Y -.–
Z –..
0 ——...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 508 - Morse Mismatches（摩斯码）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-508-morse-mismatches%E6%91%A9%E6%96%AF%E7%A0%81/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 509 RAID!（磁盘数据）
    </h2>
  </header>
  <div class="entry-content">
    <p>习题4-7 RAID技术（RAID!, ACM/ICPC World Finals 1997, UVa509）
RAID技术用多个磁盘保存数据。每份数据在不止一个磁盘上保存，因此在某个磁盘损
坏时能通过其他磁盘恢复数据。本题讨论其中一种RAID技术。数据被划分成大小
为s（1≤s≤64）比特的数据块保存在d（2≤d≤6）个磁盘上，如图4-9所示，每d-1个数据块都
有一个校验块，使得每d个数据块的异或结果为全0（偶校验）或者全1（奇校验）。
图4-9 数据保存情况
例如，d=5，s=2，偶校验，数据6C7A79EDFC（二进制01101100 01111010 01111001
11101101 11111100）的保存方式如图4-10所示。
图4-10 数据6C7A79EDPC的保存方式
其中加粗块是校验块。输入d、s、b、校验的种类（E表示偶校验，O表示奇校验）以
及b（1≤b≤100）个数据块（其中“x”表示损坏的数据），你的任务是恢复并输出完整的数
据。如果校验错或者由于损坏数据过多无法恢复，应报告磁盘非法。
Sample Input
5 2 5
E
0001011111
0110111011
1011011111
1110101100
0010010111
3 2 5
E
0001111111
0111111011
xx11011111
3 5 1
O
11111
11xxx
x1111
0
Sample Output
Disk set 1 is valid, contents are: 6C7A79EDFC
Disk set 2 is invalid.
Disk set 3 is valid, contents are: FFC...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 509 RAID!（磁盘数据）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-509-raid%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 512 - Spreadsheet Tracking（Excel表格）
    </h2>
  </header>
  <div class="entry-content">
    <p>例题4-5 踪电子表格中的单元格（Spreadsheet Tracking, ACM/ICPC World Finals
1997, UVa512）
有一个r行c列（1≤r，c≤50）的电子表格，行从上到下编号为1～r，列从左到右编号为1
～c。如图4-2（a）所示，如果先删除第1、5行，然后删除第3, 6, 7, 9列，结果如图4-2（b）
所示。
（a） （b）
图4-2 删除行、列
接下来在第2、3、5行前各插入一个空行，然后在第3列前插入一个空列，会得到如图4-
3所示结果。
图4-3 插入行、列
你的任务是模拟这样的n个操作。具体来说一共有5种操作：
EX r1 c1 r2 c2交换单元格(r1,c1),(r2,c2)。
A x1 x2 … xA 插入或删除A行或列（DC-删除列，DR-删除行，IC-插入
列，IR-插入行，1≤A≤10）。
在插入／删除指令后，各个x值不同，且顺序任意。接下来是q个查询，每个查询格式
为“r c”，表示查询原始表格的单元格(r,c)。对于每个查询，输出操作执行完后该单元格的新
位置。输入保证在任意时刻行列数均不超过50。
Sample Input
7 9
5
DR 2 1 5
DC 4 3 6 7 9
IC 1 3
IR 2 2 4
EX 1 2 6 5
4
4 8...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 512 - Spreadsheet Tracking（Excel表格）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-512-spreadsheet-trackingexcel%E8%A1%A8%E6%A0%BC/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 514 - Rails ( 铁轨)
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-2 铁轨（Rails, ACM/ICPC CERC 1997, UVa 514）
某城市有一个火车站，铁轨铺设如图6-1所示。 有n节车厢从A方向驶入车站，按进站顺
序编号为1～n。 你的任务是判断是否能让它们按照某种特定的顺序进入B方向的铁轨并驶出
车站。 例如，出栈顺序(5 4 1 2 3)是不可能的，但(5 4 3 2 1)是可能的。
为了重组车厢，你可以借助中转站C。 这是一个可以停放任意多节车厢的车站，但由于
末端封顶，驶入C的车厢必须按照相反的顺序驶出C。 对于每个车厢，一旦从A移入C，就不
能再回到A了；一旦从C移入B，就不能回到C了。 换句话说，在任意时刻，只有两种选择：
A→C和C→B。
Sample Input
5
1 2 3 4 5
5 4 1 2 3
0
6
6 5 4 3 2 1
0
0
Sample Output
Yes
No
Yes
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=838&amp;page=show_problem&amp;problem=455
和书上的思路一样
车进入是先从1到n
我们每进入一辆,就判断一下是不是要出去的那一辆, 如果是,这辆车就走了,然后判断一下下一辆
如果不是就进入中转轨道中等的
#include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; // [注意] 最后一组输出之后要有一个空行 int fun(int N){ stack&lt;int&gt; wait; // 等待通过的火车 stack&lt;int&gt; temp; // 中转轨道 for(int i=N;i&gt;=1;i--){ wait....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 514 - Rails ( 铁轨)" href="https://sucicada.github.io/blog/posts/uvaoj/uva-514-rails-%E9%93%81%E8%BD%A8/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 540 - Team Queue（插队队列）
    </h2>
  </header>
  <div class="entry-content">
    <p>例题5-6 团体队列(Team Queue,UVa540)
有t个团队的人正在排一个长队。每次新来一个人时,如果他有队友在排队,那么这个
新人会插队到最后一个队友的身后。如果没有任何一个队友排队,则他会排到长队的队尾。
输入每个团队中所有队员的编号,要求支持如下3种指令(前两种指令可以穿插进
行)。
ENQUEUEx:编号为x的人进入长队。
DEQUEUE:长队的队首出队。
STOP:停止模拟。
对于每个DEQUEUE指令,输出出队的人的编号。
Sample Input
2
3 101 102 103
3 201 202 203
ENQUEUE 101
ENQUEUE 201
ENQUEUE 102
ENQUEUE 202
ENQUEUE 103
ENQUEUE 203
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
DEQUEUE
STOP
2
5 259001 259002 259003 259004 259005
6 260001 260002 260003 260004 260005 260006
ENQUEUE 259001
ENQUEUE 260001
ENQUEUE 259002
ENQUEUE 259003
ENQUEUE 259004
ENQUEUE 259005
DEQUEUE
DEQUEUE...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 540 - Team Queue（插队队列）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-540-team-queue%E6%8F%92%E9%98%9F%E9%98%9F%E5%88%97/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 548 - Tree(树) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-8 树（Tree, UVa 548）
给一棵点带权（权值各不相同，都是小于10000的正整数）的二叉树的中序和后序遍
历，找一个叶子使得它到根的路径上的权和最小。如果有多解，该叶子本身的权应尽量小。
输入中每两行表示一棵树，其中第一行为中序遍历，第二行为后序遍历。
样例输入：
3 2 1 4 5 7 6
3 1 2 5 6 7 4
7 8 11 3 5 16 12 18
8 3 11 7 16 18 12 5
255
255
样例输出：
1
3
255
本家地址
在根据中序和后序遍历进行构造的时候，同时计算叶子的权值和，比较选择最小的权值的叶子，记录最小权值和的叶子和权值和。
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;sstream&gt; #include&lt;cstring&gt; using namespace std; int inorder[10004]; int postorder[10004]; int inindex[10004]; int min_top_value = 100000004; // 最小的权和 int loft = -1; // 叶子本身的值, /* 参数: 当前子树的 中序前,后 后序前,后 */ int calcul(int in_begin, int in_end, int post_begin, int post_end, int alculate_root_value){ // in_end - in_begin == post_end - post_begin int root_value = postorder[post_end]; // 根, 从后序 int root_in_index = inindex[root_value];//fin_inorder(in_begin, in_end, root_value); alculate_root_value = alculate_root_value &#43; root_value; // 新的累计根值, 加上自己身上的 if(in_end &lt;= in_begin){ // 叶子了 if(loft == -1 || // 第一个叶子 (alculate_root_value &lt; min_top_value) || (alculate_root_value == min_top_value &amp;&amp; inorder[in_begin] &lt; loft) ) { min_top_value = alculate_root_value; loft = inorder[in_begin]; } return 0; } int len = root_in_index-1-in_begin; if(root_in_index &gt; in_begin){ calcul(in_begin, root_in_index-1, post_begin, post_begin &#43; len, alculate_root_value); // 左枝 } len = in_end - root_in_index-1; if(root_in_index &lt; in_end){ calcul(root_in_index&#43;1, in_end, post_end-1-len , post_end-1, alculate_root_value); // 右枝 } return 0; } void init(){ memset(inorder,0,sizeof(inorder)); memset(postorder,0,sizeof(postorder)); memset(inindex,0,sizeof(inindex)); min_top_value = 100000004; // 最小的权和 loft = -1; // 叶子本身的值 } int main() { int row = 0; string line; while(getline(cin,line)){ // cout&lt;&lt;n&lt;&lt;&#34; &#34;; stringstream ss(line); int i=0; int n; if(row==0){ // 新的一组, 要初始化 // 代表是一组中的第一行,即中序遍历 init(); while(ss&gt;&gt;n){ inorder[i] = n; inindex[n] = i; i&#43;&#43;; } row = 1; }else{ // 一组中的第二行, 即后序遍历 while(ss&gt;&gt;n){ postorder[i&#43;&#43;] = n; } row = 0; calcul(0,i-1,0,i-1,0); cout&lt;&lt;loft&lt;&lt;endl; } return 0; } // AC at 2020/03/21 ps：债还清了，这个代码提交了12次数，uva因为赞助商跑路的关系（不知道也没有关系），感觉现在更加慢了。网站首页筹集代码贡献。也想做点贡献，但是C&#43;&#43;的网站。。。</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 548 - Tree(树) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-548-tree%E6%A0%91-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 572 - Oil Deposits (油田) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-12 油田（Oil Deposits, UVa 572）
输入一个m行n列的字符矩阵，统计字符“@”组成多少个八连块。如果两个字符“@”所在
的格子相邻（横、竖或者对角线方向），就说它们属于同一个八连块。例如，图6-9中有两
个八连块。
Sample Input
1 1
*
3 5
@@*
@
@@*
1 8
@@***@
5 5
****@
@@@
@**@
@@@@
@@**@
0 0
Sample Output
0
1
2
2
本家连接
恩，嘛，遍历跑呗。反正到处都有。
#include&lt;iostream&gt; using namespace std; char oil[110][110]; int sum=0; int length,width; int isOil=0; void show(){ for(int i=0;i&lt;length;i&#43;&#43;){ for(int j=0;j&lt;width;j&#43;&#43;) cout&lt;&lt;oil[i][j]; cout&lt;&lt;endl; } // cout&lt;&lt;&#34;========================&#34;&lt;&lt;endl; cout&lt;&lt;endl; } int dfs(int x,int y){ char plot = oil[x][y]; if(x&lt;0 || x&gt;=length || y&lt;0 || y&gt;=width || plot!...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 572 - Oil Deposits (油田) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-572-oil-deposits-%E6%B2%B9%E7%94%B0-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 679 - Dropping Balls (小球下落) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-6 小球下落（Dropping Balls, UVa 679）
有一棵二叉树，最大深度为D，且所有叶子的深度都相同。所有结点从上到下从左到右
编号为1, 2, 3,…, 2D-1。在结点1处放一个小球，它会往下落。每个内结点上都有一个开关，
初始全部关闭，当每次有小球落到一个开关上时，状态都会改变。当小球到达一个内结点
时，如果该结点上的开关关闭，则往左走，否则往右走，直到走到叶子结点，如图所
示。
一些小球从结点1处依次开始下落，最后一个小球将会落到哪里呢？输入叶子深度D和
小球个数I，输出第I个小球最后所在的叶子编号。假设I不超过整棵树的叶子个数。D≤20。
输入最多包含1000组数据。
样例输入：
6
4 2
3 4
10 1
2 2
8 128
16 12345
-1
样例输出：
12
7
512
3
255
36358
本家链接
最简单能想到的就是模拟，模拟球的下落，但是输入一旦大了就超时了。 所以我们可以，找规律。 首先假设有6层，我们来扔球看看情况
球数 落下位置（最后一行,第一个为0计数） 0 0 1 16 2 8 3 24 4 4 5 20 6 12 7 28 8 2 9 18 10 10 11 26 12 6 13 22 14 14 15 30 --- 16 1 17 17 18 9 19 25 20 5 21 21 22 13 23 29 24 3 25 19 26 11 27 27 28 7 29 23 30 15 31 31 ==== 第33开始轮回 === 32 0 33 16 34 8 35 24 36 4 37 20 38 12 39 28 发现规律了吧。...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 679 - Dropping Balls (小球下落) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-679-dropping-balls-%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD-by-sucicada/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://sucicada.github.io/blog/posts/page/2/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://sucicada.github.io/blog/posts/page/4/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://sucicada.github.io/blog">SuCicada</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
