<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | SuCicada</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - SuCicada">
<meta name="author" content="SuCicada">
<link rel="canonical" href="https://sucicada.github.io/blog/posts/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.5b5501da54f21435c8f8010d1de02123ae8d1ada696b48c6530ec4eea283e7d6.css" integrity="sha256-W1UB2lTyFDXI&#43;AENHeAhI66NGtppa0jGUw7E7qKD59Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sucicada.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sucicada.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sucicada.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sucicada.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://sucicada.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://sucicada.github.io/blog/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Posts" />
<meta property="og:description" content="SuCicada - https://github.com/SuCicada" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://sucicada.github.io/blog/posts/" /><meta property="og:image" content="https://sucicada.github.io/blog/papermod-cover.png"/>

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://sucicada.github.io/blog/papermod-cover.png"/>

<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content="SuCicada - https://github.com/SuCicada"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://sucicada.github.io/blog/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sucicada.github.io/blog" accesskey="h" title="SuCicada (Alt + H)">SuCicada</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sucicada.github.io/blog/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://sucicada.github.io/blog/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://sucicada.github.io/blog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://sucicada.github.io/blog/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://sucicada.github.io/blog">Home</a></div>
  <h1>
    Posts
    <a href="index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 572 - Oil Deposits (油田) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-12 油田（Oil Deposits, UVa 572）
输入一个m行n列的字符矩阵，统计字符“@”组成多少个八连块。如果两个字符“@”所在
的格子相邻（横、竖或者对角线方向），就说它们属于同一个八连块。例如，图6-9中有两
个八连块。
Sample Input
1 1
*
3 5
@@*
@
@@*
1 8
@@***@
5 5
****@
@@@
@**@
@@@@
@@**@
0 0
Sample Output
0
1
2
2
本家连接
恩，嘛，遍历跑呗。反正到处都有。
#include&lt;iostream&gt; using namespace std; char oil[110][110]; int sum=0; int length,width; int isOil=0; void show(){ for(int i=0;i&lt;length;i&#43;&#43;){ for(int j=0;j&lt;width;j&#43;&#43;) cout&lt;&lt;oil[i][j]; cout&lt;&lt;endl; } // cout&lt;&lt;&#34;========================&#34;&lt;&lt;endl; cout&lt;&lt;endl; } int dfs(int x,int y){ char plot = oil[x][y]; if(x&lt;0 || x&gt;=length || y&lt;0 || y&gt;=width || plot!...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 572 - Oil Deposits (油田) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-572-oil-deposits-%E6%B2%B9%E7%94%B0-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 679 - Dropping Balls (小球下落) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-6 小球下落（Dropping Balls, UVa 679）
有一棵二叉树，最大深度为D，且所有叶子的深度都相同。所有结点从上到下从左到右
编号为1, 2, 3,…, 2D-1。在结点1处放一个小球，它会往下落。每个内结点上都有一个开关，
初始全部关闭，当每次有小球落到一个开关上时，状态都会改变。当小球到达一个内结点
时，如果该结点上的开关关闭，则往左走，否则往右走，直到走到叶子结点，如图所
示。
一些小球从结点1处依次开始下落，最后一个小球将会落到哪里呢？输入叶子深度D和
小球个数I，输出第I个小球最后所在的叶子编号。假设I不超过整棵树的叶子个数。D≤20。
输入最多包含1000组数据。
样例输入：
6
4 2
3 4
10 1
2 2
8 128
16 12345
-1
样例输出：
12
7
512
3
255
36358
本家链接
最简单能想到的就是模拟，模拟球的下落，但是输入一旦大了就超时了。 所以我们可以，找规律。 首先假设有6层，我们来扔球看看情况
球数 落下位置（最后一行,第一个为0计数） 0 0 1 16 2 8 3 24 4 4 5 20 6 12 7 28 8 2 9 18 10 10 11 26 12 6 13 22 14 14 15 30 --- 16 1 17 17 18 9 19 25 20 5 21 21 22 13 23 29 24 3 25 19 26 11 27 27 28 7 29 23 30 15 31 31 ==== 第33开始轮回 === 32 0 33 16 34 8 35 24 36 4 37 20 38 12 39 28 发现规律了吧。...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 679 - Dropping Balls (小球下落) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-679-dropping-balls-%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 699 - The Falling Leaves (落叶) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-10 下落的树叶（The Falling Leaves, UVa 699）
给一棵二叉树，每个结点都有一个水平位
置：左子结点在它左边1个单位，右子结点在右
边1个单位。从左向右输出每个水平位置的所有
结点的权值之和。如图6-7所示，从左到右的3个
位置的权和分别为7，11，3。按照递归（先序）
方式输入，用-1表示空树。
样例输入：
5 7 -1 6 -1 -1 3 -1 -1
8 2 9 -1 -1 6 5 -1 -1 12 -1
-1 3 7 -1 -1 -1
-1
样例输出：
Case 1:
7 11 3
Case 2:
9 7 21 15
【注意】 一棵树的输[入可能分为多行。输出最多一行80个（代表树最多80列）
本家地址
一边输入一边记录左右结点的值，放在数组中叠加。唯一的问题就是存在左右子树，无法确定左右范围具体为多少，所以可以采用两种方法：
设定一个最大的范围，80*2-1 范围，选择最中点为root结点，然后左右放置子节点。 将左右子树分开存放，右子树包含根节点，放置一个数组，下标递增代表结点向右扩增。将左子树放置另一个数组，下标递增代表结点向左扩增。如果以根节点为坐标轴0，那么左子树放置的坐标中就是反坐标轴，只是方向相反。 我采用第2种，因为一开始不知道范围（貌似）
#include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int leftTree[100] = {0}; int rightTree[100] = {0}; /* include root */ int leftIndex = 0; int rightIndex = 0; char c; int tree(int index){ int n; cin&gt;&gt;n; if(n!...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 699 - The Falling Leaves (落叶) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-699-the-falling-leaves-%E8%90%BD%E5%8F%B6-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 816 - Abbott‘s Revenge (Abbott的复仇) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-14 Abbott的复仇（Abbott’s Revenge, ACM/ICPC World Finals 2000, UVa 816）
有一个最多包含9*9个交叉点的迷宫。输入起点、离开起点时的朝向和终点，求一条最
短路（多解时任意输出一个即可）。
图6-14 迷宫及走向
这个迷宫的特殊之处在于：进入一个交叉点
的方向（用NEWS这4个字母分别表示北东西
南，即上右左下）不同，允许出去的方向也不
同。例如，1 2 WLF NR ER 表示交叉点(1,2)
（上数第1行，左数第2列）有3个路标（字
符“”只是结束标志），如果进入该交叉点时的
朝向为W（即朝左），则可以左转（L）或者直
行（F）；如果进入时朝向为N或者E则只能右转
（R），如图6-14所示。
注意：初始状态是“刚刚离开入口”，所以即
使出口和入口重合，最短路也不为空。例如，图
6-14中的一条最短路为(3,1) (2,1) (1,1) (1,2)
(2,2) (2,3) (1,3) (1,2) (1,1) (2,1) (2,2) (1,2) (1,3) (2,3) (3,3)。
Sample Input
SAMPLE
3 1 N 3 3
1 1 WL NR *
1 2 WLF NR ER *
1 3 NL ER *
2 1 SL WR NF *...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 816 - Abbott‘s Revenge (Abbott的复仇) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-816-abbotts-revenge-abbott%E7%9A%84%E5%A4%8D%E4%BB%87-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 839 - Not so Mobile （天平）By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-9 天平（Not so Mobile, UVa 839）
输入一个树状天平，根据力矩相等原则判断是否平衡。如图6-5所示，所谓力矩相等，
就是WlDl=WrDr，其中Wl和Wr分别为左右两边砝码的重量，D为距离。
采用递归（先序）方式输入：每个天平的格式为Wl，Dl，Wr，Dr，当Wl或Wr为0时，表
示该“砝码”实际是一个子天平，接下来会描述这个子天平。当Wl=Wr=0时，会先描述左子天
平，然后是右子天平。
样例输入：
1
0 2 0 4
0 3 0 1
1 1 1 1
2 4 4 2
1 6 3 2
Sample Output
YES
【注意】 输出结果之间空一行
本家地址
递归走，一边输入每一结点，一边递归判断这个结点的左结点结果（左子树重量总和）和右结点结果（右子树重量总和）是否满足要求。
这样的话在建立树的时候也就直接计算结束了。
#include&lt;iostream&gt; using namespace std; int lair(){ int wl,dl,wr,dr; cin&gt;&gt;wl&gt;&gt;dl&gt;&gt;wr&gt;&gt;dr; if(wl == 0){ /* have left branch */ wl = lair(); } if(wr == 0){ wr = lair(); } if(wl==0 || wr==0 || wl*dl !...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 839 - Not so Mobile （天平）By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-839-not-so-mobile-%E5%A4%A9%E5%B9%B3by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVa Online Judge 西班牙Valladolid 在线判官 和 uDebug使用简单教程
    </h2>
  </header>
  <div class="entry-content">
    <p>udebug使用在后面
https://uva.onlinejudge.org/
1、这是主界面，如果你还没有账号，那么就点击图中的register。
2、然后就是填写信息，邮箱要用gmail，信息填写完成后点击下方的register
3、之后打开邮箱查看接受的邮件，并点击其中的链接完成注册确认，之后会转到uva oj，如果页面显示 your account is now active.You may now log in!则表示注册完成。
4、然后输入用户名密码登录
5、然后在左边的栏目中，点击Browse Problems 就可以找到有关刘汝佳以及其他一些著名套题了。
6、然后是关于如何答题，现在我们打开了一道题目，看图上红框住的左上角，
（1）其中我们点击PDF，会下载下来本道题的pdf格式文件
（2）我们点击submit就是提交代码了。
其中如果是用的C语言或C&#43;&#43;选择第一个c&#43;&#43;，提交结果没有ac，如果不是代码问题，那么试试选择c&#43;&#43;11吧。
参考了UVAOJ的注册和评测入门
（3）最后我想说一下在看题界面的那个Debug选项，就是旁边有个红色的甲虫的。
若果打不开udebug就挂vpn试试吧
https://www.udebug.com/UVa/1589 （当前是1589号题）
我们点进去后，一共四部分。上左边就是一些用户上传的关于本题的一些样例。点击其中一个，这些样例就会显示在右边的框中。
然后我们点击下方写着Get Accepted Output蓝格，就会在下方的左边出现这些样例的正确输出结果。我们可以把这些样例用我们的代码输出的结果粘到右边的框中。之后点击Compare Outputs 进行对比。
这样我就能很方便的知道我们的代码在处理哪一个样例上出现里问题，更改起来也更有方向性。还有如果出现了图中的情况，明明都对但还是显示不对，那是因为他的输出默认多了一个空行，这个一般和代码没有关系。默认为对就行了。
我们还可以在上面快速搜索你需要的题号。
目前支持这些oj
这是主页https://www.udebug.com/
可以去他的Twitter和Facebook上看看，网上关于udegug的信息不多。</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVa Online Judge 西班牙Valladolid 在线判官 和 uDebug使用简单教程" href="https://sucicada.github.io/blog/posts/uvaoj/uva-online-judge-%E8%A5%BF%E7%8F%AD%E7%89%99valladolid-%E5%9C%A8%E7%BA%BF%E5%88%A4%E5%AE%98-%E5%92%8C-udebug%E4%BD%BF%E7%94%A8%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva1583 - Digit Generator （生成元）
    </h2>
  </header>
  <div class="entry-content">
    <p>如果x加上x的各个数字之和得到y，就说x是y的生成元。给出n（1≤n≤100000），求最小
生成元。无解输出0。例如，n=216，121，2005时的解分别为198，0，1979。
Sample Input
3
216
121
2005
Sample Output
198
0
1979
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=829&amp;page=show_problem&amp;problem=4458
//先算出所有的生成元x的原数y，以s[y]=x的形式将其存起，在求y的解x的时候，直接输出是s[y]即可 //所以为了求最小生成元也就是x，就要从尾到头的循环算y。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;string.h&gt; using namespace std; int const N = 100000; int sn[N&#43;5]={0}; int main() { memset(sn,0,sizeof(sn)); for(int i=N;i&gt;=0;i--) { int n=i; int s=i; while(n&gt;0) { s&#43;=n%10; n/=10; } sn[s]=i; } //for(int i=0;i&lt;N;i&#43;&#43;) // cout&lt;&lt;sn[i]&lt;&lt;&#34; &#34;; // cout&lt;&lt;endl; int n,T; cin&gt;&gt;T; while(T--) { int i; cin&gt;&gt;n; cout&lt;&lt;sn[n]&lt;&lt;endl; } return 0; } //AC at 2017/12/7 以下算法虽然一样可以算出正确答案，但是超时，oj不通过。...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva1583 - Digit Generator （生成元）" href="https://sucicada.github.io/blog/posts/uvaoj/uva1583-digit-generator-%E7%94%9F%E6%88%90%E5%85%83/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva272 （TeX）
    </h2>
  </header>
  <div class="entry-content">
    <p>https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=829&amp;page=show_problem&amp;problem=208
TEX is a typesetting language developed by Donald Knuth. It takes source text together with a few
typesetting instructions and produces, one hopes, a beautiful document. Beautiful documents use “
and ” to delimit quotations, rather than the mundane &#34; which is what is provided by most keyboards.
Keyboards typically do not have an oriented double-quote, but they do have a left-single-quote and a right-single-quote &#39;. Check your keyboard now to locate the left-single-quote key (sometimes...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva272 （TeX）" href="https://sucicada.github.io/blog/posts/uvaoj/uva272-tex/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>三柱体hanoi问题（C_C&#43;&#43;语言版）
    </h2>
  </header>
  <div class="entry-content">
    <p>控制台运行输入数据格式 ： xxx（程序名） 3（汉诺塔层数）
会显示出每一步的移动步骤，以及每一柱上留有的盘数
#include&lt;iostream&gt; #include&lt;sstream&gt; using namespace std; int a=0,b=0,c=0; void hno(int n,char from,char mid,char to) { if(n&gt;1) { hno(n-1,from,to,mid); hno(1,from,mid,to); hno(n-1,mid,from,to); } else { switch(from) { case &#39;A&#39;:a--;break; case &#39;B&#39;:b--;break; case &#39;C&#39;:c--;break; } switch(to) { case &#39;A&#39;:a&#43;&#43;;break; case &#39;B&#39;:b&#43;&#43;;break; case &#39;C&#39;:c&#43;&#43;;break; } cout&lt;&lt;from&lt;&lt;&#34;--&gt;&#34;&lt;&lt;to&lt;&lt;&#34; A:&#34;&lt;&lt;a&lt;&lt;&#34; B:&#34;&lt;&lt;b&lt;&lt;&#34; C:&#34;&lt;&lt;c&lt;&lt;endl; } } int main(int argc,char *argv[]) { // cout&lt;&lt;argc&lt;&lt;endl; // cout&lt;&lt;&#34;_&#34;&lt;&lt;argv[1]&lt;&lt;&#34;_&#34;&lt;&lt;endl; // return 0; stringstream s; int n;//=*argv[1]; s&lt;&lt;argv[1]; s&gt;&gt;n; //cin&gt;&gt;n; a=n; //hno(n,) hno(n,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;); return 0; } </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 三柱体hanoi问题（C_C&#43;&#43;语言版）" href="https://sucicada.github.io/blog/posts/soft/%E4%B8%89%E6%9F%B1%E4%BD%93hanoi%E9%97%AE%E9%A2%98c_c&#43;&#43;%E8%AF%AD%E8%A8%80%E7%89%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>三柱汉诺塔问题（Python版）
    </h2>
  </header>
  <div class="entry-content">
    <p>思路一样
def move(n, a, b, c): if(n&gt;1): move(n-1,a,c,b) move(1,a,b,c) move(n-1,b,a,c) else: print a,&#39;--&gt;&#39;,c n = input(&#39;input a number&#39;) #int(raw_input()) move(n, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;) </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 三柱汉诺塔问题（Python版）" href="https://sucicada.github.io/blog/posts/soft/%E4%B8%89%E6%9F%B1%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98python%E7%89%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>关于 1.0_0.0 以及 0.0_0.0 的值
    </h2>
  </header>
  <div class="entry-content">
    <p>#include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main() { printf(&#34;%d\n&#34;,1.0/0.0);//0 printf(&#34;%d\n&#34;,0.0/0.0);//0 printf(&#34;%lld\n&#34;,1.0/0.0);//9218868437227405312 printf(&#34;%lld\n&#34;,0.0/0.0);//-2251799813685248 printf(&#34;%lf\n&#34;,1.0/0.0);//1.#INF00 printf(&#34;%lf\n&#34;,0.0/0.0);//-1.#INF00 cout&lt;&lt;1.0/0.0&lt;&lt;endl;//inf cout&lt;&lt;0.0/0.0&lt;&lt;endl;//nan return 0; } </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 关于 1.0_0.0 以及 0.0_0.0 的值" href="https://sucicada.github.io/blog/posts/soft/%E5%85%B3%E4%BA%8E-1.0_0.0-%E4%BB%A5%E5%8F%8A-0.0_0.0-%E7%9A%84%E5%80%BC/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>刘汝佳p35,2-5（分数化小数）算法竞赛入门经典第二版
    </h2>
  </header>
  <div class="entry-content">
    <p>输入a，b，c，输出a/b的小数形式，精确到小数点后c位，a,b&lt;=10^6,c&lt;=100，以a=b=c=0结束，四舍五入
#include&lt;stdio.h&gt; int main() { int a,b,c,n=1; while(scanf(&#34;%d%d%d&#34;,&amp;a,&amp;b,&amp;c)&amp;&amp;(a||b||c)) { printf(&#34;Case %d: %d.&#34;,n&#43;&#43;,a/b);//整数位和小数点 for(int i=0;i&lt;c-1;i&#43;&#43;) { printf(&#34;%d&#34;,(a*10/b)%10); a=(a*10)%b;//为了不让a溢出，用a/b的余数来算并不影响结果 } printf(&#34;%d\n&#34;,((a*100/b)%100&#43;5)/10);//最后一位四舍五入 } return 0; } 已经连这种简单的算法都要上网看别人写的了，自己想出来的都是错的，浪费了一个小时又。</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 刘汝佳p35,2-5（分数化小数）算法竞赛入门经典第二版" href="https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p352-5%E5%88%86%E6%95%B0%E5%8C%96%E5%B0%8F%E6%95%B0%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>刘汝佳p35,2-6（123排列）算法竞赛入门经典第二版
    </h2>
  </header>
  <div class="entry-content">
    <p>算法竞赛入门经典第二版
刘汝佳p35 , 2-6
用1,2,3，….，9组成3个三位数abc，def和ghi，每个数字恰好使用一次，要求abc:def:ghi=1:2:3。输出所有解。
#include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int nn(int a,int *n) { //cout&lt;&lt;&#34;a&#34;&lt;&lt;a&lt;&lt;endl; for(int i=0;i&lt;8;i&#43;&#43;) { if(a==n[i]) { //cout&lt;&lt;n[i]&lt;&lt;endl; n[i]=-1; return 0; } } return 1; } void num(int a) { int n[9]; for(int i=0;i&lt;8;i&#43;&#43;) n[i]=i&#43;1; int b=a*2; int c=a*3; int s[9]; s[0]=a/100; s[1]=(a/10)%10; s[2]=a%10; s[3]=b/100; s[4]=(b/10)%10; s[5]=b%10; s[6]=c/100; s[7]=(c/10)%10; s[8]=c%10; for(int i=0;i&lt;8;i&#43;&#43;) { //cout&lt;&lt;&#34;si&#34;&lt;&lt;s[i]&lt;&lt;endl; if(nn(s[i],n)==1) { //cout&lt;&lt;&#34;return&#34;&lt;&lt;endl; return; } } cout&lt;&lt;a&lt;&lt;&#34; &#34;&lt;&lt;b&lt;&lt;&#34; &#34;&lt;&lt;c&lt;&lt;endl; } int main() { for(int a=100;a&lt;=333;a&#43;&#43;) { num(a); } return 0; } 所以结果是...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 刘汝佳p35,2-6（123排列）算法竞赛入门经典第二版" href="https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p352-6123%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>刘汝佳p39,3-2（开灯问题）算法竞赛入门经典第二版
    </h2>
  </header>
  <div class="entry-content">
    <p>有n盏灯，编号为1～n，第1个人把所有灯打开，第2个人按下所有编号为2的倍数的开关（这些灯将被关掉），第3个人按下所有编号为3的倍数的开关（其中关掉的灯被打开， 开着灯将被关闭），依此类推。一共有k个人，问最后有哪些灯开着？
输入：n和k，输出开着的灯编号。k≤n≤1000。
样例输入：7 3
样例输出：1 5 6 7
（题目描述拷贝自http://blog.csdn.net/oceaniwater/article/details/40709609）
#include&lt;stdio.h&gt; int main() { int n,k,ni,ki,nii; //n=7;k=3; scanf(&#34;%d%d&#34;,&amp;n,&amp;k); for(ni=1;ni&lt;=n;ni&#43;&#43;)//灯数 { nii=ni; for(ki=1;ki&lt;=k;ki&#43;&#43;)//每灯人数 { //printf(&#34;%%%d &#34;,nii%ki); if(nii%ki==0)//当前灯是否为当前人的倍数 { ni*=(-1);//负数为开，正数为灭 } //printf(&#34;!%d\n&#34;,ni); } if(ni&lt;0) { printf(&#34;%d &#34;,ni*=-1); } } return 0; } </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 刘汝佳p39,3-2（开灯问题）算法竞赛入门经典第二版" href="https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p393-2%E5%BC%80%E7%81%AF%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>刘汝佳p39,3-3（蛇形填数）算法竞赛入门经典第二版
    </h2>
  </header>
  <div class="entry-content">
    <p>在nn方阵里填入1,2,„,nn，要求填成蛇形。例如n=4时方阵为
10 11 12 1
9 16 13 2
8 15 14 3
7 6 5 4
上面的方阵中，多余的空格只是为了便于观察规律，不必严格输出。n≤8。
#include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; int const N=120; int main() { int n[N][N]={0}; int m,mm; cin&gt;&gt;m; mm=m; int s=1,i,j; //s=n[i=0][j=m-1]=1; while(m--) { //m--; i=mm-m-1; j=m; while(i&lt;=m-1 &amp;&amp;n[i][j]==0) n[i&#43;&#43;][j]=s&#43;&#43;;//right while(j&gt;=mm-m &amp;&amp;n[i][j]==0) n[i][j--]=s&#43;&#43;;//down while(i&gt;=mm-m &amp;&amp;n[i][j]==0) n[i--][j]=s&#43;&#43;;//left while(j&lt;=m-1 &amp;&amp;n[i][j]==0) n[i][j&#43;&#43;]=s&#43;&#43;;//up if(s==mm*mm)n[i&#43;1][j-1]=s; } for(i=0;i&lt;mm;i&#43;&#43;) { for(j=0;j&lt;mm;j&#43;&#43;) cout&lt;&lt;setw(3)&lt;&lt;n[i][j]; cout&lt;&lt;endl; } return 0; } </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 刘汝佳p39,3-3（蛇形填数）算法竞赛入门经典第二版" href="https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p393-3%E8%9B%87%E5%BD%A2%E5%A1%AB%E6%95%B0%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>刘汝佳p41,3-4（竖式问题）算法竞赛入门经典第二版
    </h2>
  </header>
  <div class="entry-content">
    <p> 题目：
找出所有形如abc*de（三位数乘以两位数）的算式，使得在完整的竖式中，所有数字都属于一个特定的数字集合。输入数字集合（相邻数字之间没有空格），输出所有竖式。每个竖式前应有编号，之后应有一个空行。最后输出解的总数。具体格式见样例输出（为了便于观察，竖式中的空格改用小数点显示，但你的程序应该输出空格，而非小数点）。
样例输入：2357
样例输出：
&lt;1&gt;
..775
X..33
.—–
.2325
.—–
25575
The number of solutions = 1
分析：
尝试所有的abc和de，判断是否满足条件。
#include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;cstdio&gt; using namespace std; int main() { char s[15],f[25]; int n=1; cin&gt;&gt;s; for(int a=100;a&lt;1000;a&#43;&#43;) { for(int b=10;b&lt;=99;b&#43;&#43;) { int o=1; int x=a*(b%10),y=a*(b/10),z=a*b; sprintf(f,&#34;%d%d%d%d%d&#34;,a,b,x,y,z);//将abxyz输入到f中 for(int i=0;i&lt;strlen(f);i&#43;&#43;) if(strchr(s,f[i])==NULL) o=0; if(o) printf(&#34;&lt;%d&gt;\n%5d\nX%4d\n-----\n%5d\n%4d \n-----\n%5d\n\n&#34;,n&#43;&#43;,a,b,x,y,z); } } cout&lt;&lt;&#34;The number of solutions = &#34;&lt;&lt;n-1&lt;&lt;endl; return 0; } </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 刘汝佳p41,3-4（竖式问题）算法竞赛入门经典第二版" href="https://sucicada.github.io/blog/posts/soft/%E5%88%98%E6%B1%9D%E4%BD%B3p413-4%E7%AB%96%E5%BC%8F%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC%E4%BA%8C%E7%89%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>判断字符是否为字母或数字
    </h2>
  </header>
  <div class="entry-content">
    <p>参考：
C语言中isalnum()函数和isalpha()函数的对比使用
C语言 判断字符的大小写 isalpha()函数
#include&lt;ctype.h&gt;//或&lt;cctype&gt; int isalpha(int ch)//为英文字母时返回不一定为1的非零，否则返回零 isalnum(c)//判断c是否为英文字母或数字 isupper(c)//判断c是否为大写英文字母 islower(c)//判断c是否为小写英文字母 isdigit(c)//判断c是否为数字 以上若不是所判断字符类型则都返回零</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 判断字符是否为字母或数字" href="https://sucicada.github.io/blog/posts/soft/%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AD%97%E6%AF%8D%E6%88%96%E6%95%B0%E5%AD%97/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>十六进制转十进制.h
    </h2>
  </header>
  <div class="entry-content">
    <p>#include&lt;stdio.h&gt; #include&lt;ctype.h&gt; int sc(char a[])//传进来代表十六进制的字符串数组，返回十进制 { int i,n=0,t; for(i=0;a[i];i&#43;&#43;) { a[i]=toupper(a[i]); if(a[i]&gt;=&#39;A&#39;) t=a[i]-&#39;A&#39;&#43;10; else t=a[i]-&#39;0&#39;; n=n*16&#43;t; } return n; } </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 十六进制转十进制.h" href="https://sucicada.github.io/blog/posts/soft/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8D%81%E8%BF%9B%E5%88%B6.h/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>控制台光标移动(有尾迹）
    </h2>
  </header>
  <div class="entry-content">
    <p>更改了网上的代码，实现有尾迹的移动，
用键盘上的上下左右来控制
这是借鉴地址：C语言之实现控制台光标随意移动
#include &lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;conio.h&gt; HANDLE hout; //获得输入 char getInput() { int ch; //输入字符串 COORD coord; //屏幕上的坐标 CONSOLE_SCREEN_BUFFER_INFO csbi; //控制台屏幕缓冲区信息 coord.X=11; coord.Y=10; ch=getch(); csbi.dwCursorPosition.X=11; csbi.dwCursorPosition.Y=10; //0x0d表示回车，0XE0表示上下左右等键的键码 while(ch==0xE0||ch==0x0d) { GetConsoleScreenBufferInfo(hout,&amp;csbi);//读取控制台屏幕缓冲信息 coord.X=csbi.dwCursorPosition.X; //得到坐标X的值 coord.Y=csbi.dwCursorPosition.Y; //得到坐标Y的值 ch=getch(); //printf(&#34; &#34;); //上 if(ch==0x48) { if(coord.Y!=0) { coord.Y--; //printf(&#34;%c&#34;,&#39;A&#39;); } } //下 else if(ch==0x50) { coord.Y&#43;&#43;; //printf(&#34;%c&#34;,&#39;A&#39;); } //左 else if(ch==0x4b) { if(coord.X!=0){coord.X--;}//printf(&#34;%c&#34;,&#39;A&#39;);} } //右 else if(ch==0x4d) { if(coord.X!=79) { coord.X&#43;&#43;; //printf(&#34;%c&#34;,&#39;A&#39;); } } printf(&#34;%c&#34;,&#39;....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 控制台光标移动(有尾迹）" href="https://sucicada.github.io/blog/posts/soft/%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E6%9C%89%E5%B0%BE%E8%BF%B9/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>数学必知必会-导数、梯度与积分
    </h2>
  </header>
  <div class="entry-content">
    <p>(238条消息) 数学必知必会—-导数、梯度与积分_sakura小樱的博客-CSDN博客_梯度求积分 数学必知必会—-导数、梯度与积分 sakura小樱 于 2018-06-12 19:18:22 发布 3204 收藏 6
文章标签： 导数 数学 微积分
版权
一、导数 1.1常用的倒数 1.2复合函数求导 1.2.1链式法则 1.2.2多元函数求导：偏导数（偏微分） 二、积分 定积分 不定积分 拓展 三、均方误差 3.1导数应用 3.2线性回归的应用 四、梯度 4.1导入 4.2定义： 4.3事例 4.4理解方法 4.5梯度下降法定义 4.6局部极限值 4.7下降法求最小值方法 4.7.1抛小球法—momentum 4.7.2Nesterov 4.7.3自适应 4.7.4AdaDelta以及RMSprop 4.7.5选择 from sympy import * x=Symbol(&#34;x&#34;) diff(x**3 &#43; x**2) #3x**2 &#43; 2**x 一、导数 导数的实质就是曲线切线的斜率
1.1常用的倒数 1.2复合函数求导 1.2.1链式法则 1.2.2多元函数求导：偏导数（偏微分） 链式法则
多元函数求导的法则
二、积分 积分是微分的逆运算，即知道了函数的 导函数，反求原函数。在应用上，积分作用不仅如此，它被大量应用于求和，通俗的说是求 曲边三角形的面积，这巧妙的求解方法是积分特殊的性质决定的。
更多推导公式点击这里
定积分 不定积分 拓展 ● 微分的相关知识...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to 数学必知必会-导数、梯度与积分" href="https://sucicada.github.io/blog/posts/math/%E6%95%B0%E5%AD%A6%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A-%E5%AF%BC%E6%95%B0%E6%A2%AF%E5%BA%A6%E4%B8%8E%E7%A7%AF%E5%88%86/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://sucicada.github.io/blog/posts/page/6/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://sucicada.github.io/blog/posts/page/8/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://sucicada.github.io/blog">SuCicada</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
