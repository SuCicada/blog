<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | SuCicada</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - SuCicada">
<meta name="author" content="SuCicada">
<link rel="canonical" href="https://sucicada.github.io/blog/posts/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.5b5501da54f21435c8f8010d1de02123ae8d1ada696b48c6530ec4eea283e7d6.css" integrity="sha256-W1UB2lTyFDXI&#43;AENHeAhI66NGtppa0jGUw7E7qKD59Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sucicada.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://sucicada.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://sucicada.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://sucicada.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://sucicada.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://sucicada.github.io/blog/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Posts" />
<meta property="og:description" content="SuCicada - https://github.com/SuCicada" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://sucicada.github.io/blog/posts/" /><meta property="og:image" content="https://sucicada.github.io/blog/papermod-cover.png"/>

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://sucicada.github.io/blog/papermod-cover.png"/>

<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content="SuCicada - https://github.com/SuCicada"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://sucicada.github.io/blog/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sucicada.github.io/blog" accesskey="h" title="SuCicada (Alt + H)">SuCicada</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sucicada.github.io/blog/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://sucicada.github.io/blog/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://sucicada.github.io/blog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://sucicada.github.io/blog/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header"><div class="breadcrumbs"><a href="https://sucicada.github.io/blog">Home</a></div>
  <h1>
    Posts
    <a href="index.xml" title="RSS" aria-label="RSS">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round" height="23">
        <path d="M4 11a9 9 0 0 1 9 9" />
        <path d="M4 4a16 16 0 0 1 16 16" />
        <circle cx="5" cy="19" r="1" />
      </svg>
    </a>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 11853 - Paintbal(战场) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-22 战场（Paintball, UVa 11853）
有一个1000×1000的正方形战场，战场西南角的坐标为(0,0)，西北角的坐标为(0,1000)。
战场上有n（0≤n≤1000）个敌人，第i个敌人的坐标为(xi
,yi
)，攻击范围为ri。为了避开敌人的
攻击，在任意时刻，你与每个敌人的距离都必须严格大于它的攻击范围。你的任务是从战场
的西边（x=0的某个点）进入，东边（x=1000的某个点）离开。如果有多个位置可以进/出，
你应当求出最靠北的位置。输入每个敌人的xi、yi、ri，输出进入战场和离开战场的坐标。
Sample Input
3
500 500 499
0 0 999
1000 1000 200
Sample Output
0.00 1000.00 1000.00 800.00
本家地址
关键在于抓住问题的本质，即问题的核心，即问题去除了表面保护层之下的那个最纯粹的那个命脉。
初看，我们发现，这是要在坐标图上画圆啊。过分可怕。
但是我们鼓起勇气再细看问题：
求最靠上的进入战场和离开战场的坐标。
解剖一下：
能否离开 若能，最上 最左边进，最后边出。 然后我们随便画几个图来看看。
怎么样就不能离开：
当有一条敌人从最上一直连通到最下。
若能，最靠上的地方是哪里：
如果我们最左边进入的地方的下方有一条敌线一直连通到最上边。
那么这条敌线就把我们包住了。
所以 敌线（从上方延伸 and 延伸到左边），就不能被我们在其上方进入。
所以我们只要求敌线的连通性和敌线范围（从上方开始的）在最左边和最右边的最下方坐标即可。
#include&lt;iostream&gt; #include&lt;map&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;cstdio&gt; using namespace std; /* 关键在于抓住问题的本质，即问题的核心，即问题去除了表面保护层之下的那个最纯粹的那个命脉。 初看，我们发现，这是要在坐标图上画圆啊。过分可怕。 但是我们鼓起勇气再细看问题： 求最靠上的进入战场和离开战场的坐标。 解剖一下： 1. 能否离开 2. 若能，最上 3....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 11853 - Paintbal(战场) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-11853-paintbal%E6%88%98%E5%9C%BA-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 12096 - The SetStack Computer（集合栈）
    </h2>
  </header>
  <div class="entry-content">
    <p>例题5-5
集合栈计算机(The
Set
Stack
Computer,ACM/ICPC
NWERC
2006,UVa12096)
有一个专门为了集合运算而设计的“集合栈”计算机。该机器有一个初始为空的栈,并且
支持以下操作。
PUSH:空集“{}”入栈。
DUP:把当前栈顶元素复制一份后再入栈。
UNION:出栈两个集合,然后把二者的并集入栈。
INTERSECT:出栈两个集合,然后把二者的交集入栈。ADD:出栈两个集合,然后把先出栈的集合加入到后出栈的集合中,把结果入栈。
每次操作后,输出栈顶集合的大小(即元素个数)。例如,栈顶元素是A={{},
{{}}},下一个元素是B={{},{{{}}}},则:
UNION操作将得到{{},{{}},{{{}}}},输出3。
INTERSECT操作将得到{{}},输出1。
ADD操作将得到{{},{{{}}},{{},{{}}}},输出3。
输入不超过2000个操作,并且保证操作均能顺利进行(不需要对空栈执行出栈操作)。
Sample Input
2
9
PUSH
DUP
ADD
PUSH
ADD
DUP
ADD
DUP
UNION
5
PUSH
PUSH
ADD
PUSH
INTERSECT
Sample Output
0
0
1
0
1
1
2
2
2
***
0
0
1
0
0
***
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=835&amp;problem=3248&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;21273791
性质：
１、set&lt; int &gt;　代表是集合
２、idcache 是集合与其编号的映射，每一个集合都有唯一的编号。
３、setcache是向量，即下标与其存的是集合的元素相映射。
４、每一个集合都只在以上容器中存在一个。
５、栈里存的只是集合的编号。
#include &lt;iostream&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;stack&gt; #include &lt;vector&gt; using namespace std; map&lt; set&lt;int&gt; ,int&gt; idcache; //每一个集合对应一个编号 vector&lt; set&lt;int&gt; &gt; setcache; //每一个编号对应一个集合 int getid(set&lt;int&gt; s) { if(idcache....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 12096 - The SetStack Computer（集合栈）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-12096-the-setstack-computer%E9%9B%86%E5%90%88%E6%A0%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 12171 - Sculpture(雕塑) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-18 雕塑（Sculpture, ACM/ICPC NWERC 2008, UVa12171）
某雕塑由n（n≤50）个边平行于坐标轴的长方体组成。每个长方体用6个整
数x0，y0，z0，x，y，z表示（均为1～500的整数），其中x0为长方体的顶点中x坐标的最小
值，x表示长方体在x方向的总长度。其他4个值类似定义。你的任务是统计这个雕像的体积
和表面积。注意，雕塑内部可能会有密闭的空间，其体积应计算在总体积中，但从“外部”看
不见的面不应计入表面积。雕塑可能会由多个连通块组成。
Sample Input
2
2
1 2 3 3 4 5
6 2 3 3 4 5
7
1 1 1 5 5 1
1 1 10 5 5 1
1 1 2 1 4 8
2 1 2 4 1 8
5 2 2 1 4 8
1 5 2 4 1 8
3 3 4 1 1 1...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 12171 - Sculpture(雕塑) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-12171-sculpture%E9%9B%95%E5%A1%91-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 122 - Trees on the level, Duke 1993 (树的层次遍历)
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-7 树的层次遍历（Trees on the level, Duke 1993, UVa 122）
输入一棵二叉树，你的任务是按从上到下、从左到右的顺序输出各个结点的值。每个结
点都按照从根结点到它的移动序列给出（L表示左，R表示右）。在输入中，每个结点的左
括号和右括号之间没有空格，相邻结点之间用一个空格隔开。每棵树的输入用一对空括
号“()”结束（这对括号本身不代表一个结点），如图6-3所示。
图6-3 一棵二叉树
注意，如果从根到某个叶结点的路径上有的结点没有在输入中给出，或者给出超过一
次，应当输出-1。结点个数不超过256。
样例输入：
(11,LL) (7,LLL) (8,R)
(5,) (4,L) (13,RL) (2,LLR) (1,RRR) (4,RR) ()
(3,L) (4,R) ()
样例输出：
5 4 8 11 13 4 7 2 1
not complete
本家地址
祭出对象大法
#include&lt;iostream&gt; #include&lt;sstream&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;cstdlib&gt; using namespace std; class Node{ public: int value; Node* left; Node* right; }; Node* queue[256]; void show(Node* root){ memset(queue,0,sizeof(queue)); int qbegin=0; int qend=0; int qlen = sizeof(queue)/sizeof(Node*); stringstream out; queue[qend] = root; qend = (qend&#43;1) % qlen; while(qbegin!...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 122 - Trees on the level, Duke 1993 (树的层次遍历)" href="https://sucicada.github.io/blog/posts/uvaoj/uva-122-trees-on-the-level-duke-1993-%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 1225 - Digit Counting（数数）
    </h2>
  </header>
  <div class="entry-content">
    <p> 把前n（n≤10000）个整数顺次写在一起：123456789101112…数一数0～9各出现多少次
（输出10个整数，分别是0，1，…，9出现的次数）。
Sample Input
2
3
13
Sample Output
0 1 1 1 0 0 0 0 0 0
1 6 2 2 1 1 1 1 1 1
（注：输出的最后一个数后面没有空格）
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=830&amp;problem=3666&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;20469369
//判断一个数各个位的数字，存于一个数组中，倒的来循环也无妨 #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int main() { int T; cin&gt;&gt;T; getchar(); while(T--) { int num[10]={0}; int N; cin&gt;&gt;N; getchar(); while(N--) { int ni=N&#43;1; while(ni) { num[ni%10]&#43;&#43;; ni/=10; } } for(int i=0;i&lt;9;i&#43;&#43;) cout&lt;&lt;num[i]&lt;&lt;&#34; &#34;; cout&lt;&lt;num[9]&lt;&lt;endl; } return 0; } //AC at 2017/12/10 </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 1225 - Digit Counting（数数）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-1225-digit-counting%E6%95%B0%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) 【后日谈】by SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>正篇以及正确解题思路和代码参见 UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) by SuCicada 此篇为后日谈 要说为什么专门开一篇来记录想法呢，主要是因为想说的太多了。首先从UVA的提交记录上来看，上一次答题是在足足1年之前了。
这么久以来都没有再好好做算法，感觉快要忘本了。而且出来之后脑子也不是那么灵光了，虽然更理性，但是却少了些抽象的想象力。
再说这道题，一开始我根本不知道什么字典序，完全是打表暴力比对的。把前40位算出来那里都是没错的。
但是之后我想的是：用map排个序，然后二分查找。但是这样会有问题，因为二分找到的可能并不是最小的，所以找到之后还需要分别找到同样匹配前缀的那一区域的数字，因为是map排过序的，所以他们都是挨着的。
但是之后在极端痛苦了两个晚上之后，我放弃了这种做法，经过测试计算，发现我电脑中g&#43;&#43;在一秒钟可以进行4亿次运算，假设有5万个40位数字需要比对，4亿除以5万除以40 有20万呢，或者保险点我们取个1000。（一直到当时我都以为这道题的时间限制是1秒）
然后我就在死灰复燃的状态下在下2天晚上把位数比对写出了（暴力）。为了减少比对量，我打表了前3位，也就是记录下前三位的数字第一次出现的序数，而且这个序数是map中的序数，map中的序数和fibo的序数可是不同的。
而且map不能随机读取，怎么办，我又创造了两个数组专门存放键和值。
后来我还发现个位数的搜索起来比较慢，因为他们要暴力比对的数是最多的，所以我又用一个map来记录已经查找过的结果。
我真的是要疯，一直到昨天晚上我把这套模型整通。本地一跑，通过，time测下来 1.2秒，我巨喜。提交，time limit exceeded。把udebug上的样例全部跑了一遍，没有超过1.5秒的。我随机生成各种5万个数的组合，2秒之内绝对能过。
但是 time limit exceeded， time limit exceeded，time limit exceeded，time limit exceeded，time limit exceeded。
”难道是表打的太小了？“我又将打表位数升到4，升到5。然而为什么更慢了。
那会已经3点钟了，我感到生命力的衰减，在极度无望的情况下，我打开百度，UVA 12333，我真特么被这道题23333了，
这道题考大数&#43;字典树
我惊住，一个新的窗子仿佛打开了，一查，全懂了，完全懂了。我缩在床上颤抖不已，脑子瞬间就明白了我该怎么做，但是身体已经无法支撑下去，为了能保持住自己的生命力。我艰难的进入睡眠。
第二天我写，真的很快，因为我已经知道了，虽然遇到了oj离奇而严厉的 runtime error错误。但是我很冷静，因为我知道这个方法肯定是没错的，这条路一定是对的。就是这种知道目的的坚定。
当Accepted出现在屏幕上，我想哭了。太痛苦了，太刺激了，太疯狂了。再加上17个小时没有进食带来的虚弱感让我恍惚，感觉我活下来了。
劫后余生的感激之情。
而现在已经5点怅然若失感时不时在席卷我，跨时两个星期，4个夜晚的崩溃，20余小时的挣扎，20多次的错误。我太弱了，我为我的弱小感到伤心，但是我又为我的成功感到高兴。
算法拯救我，算法伤害我，算法摧残我，算法安慰我。
我时尝为我的自艾感到痛苦。
但是我害怕痛苦吗，不如说我正喜欢痛苦。
附赠更快的却更错的代码：
#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;iterator&gt; #include&lt;vector&gt; #include&lt;string&gt; #include&lt;cstdio&gt; #include&lt;iomanip&gt; #include&lt;map&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; using namespace std; vector&lt;string&gt; fibonacci(100005); map&lt;string,int&gt; fiboSorted; vector&lt;string&gt; fiboName(100005); vector&lt;int&gt; fiboIndex(100005); int limitSite = 52; string add(string a,string b){ int aLen = a....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) 【后日谈】by SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-12333-revenge-of-fibonacci-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%9A%84%E5%A4%8D%E4%BB%87-%E5%90%8E%E6%97%A5%E8%B0%88by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) by SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>合适的思路 大数加法 字典树 代码 注意点 附录 后日谈 习题5-15 Fibonacci的复仇（Revenge of Fibonacci, ACM/ICPC Shanghai 2011,
UVa12333）
Fibonacci数的定义为：F(0)=F(1)=1，然后从F(2)开始，F(i)=F(i-1)&#43;F(i-2)。例如，前10
项Fibonacci数分别为1, 1, 2, 3, 5, 8, 13, 21, 34, 55……
有一天晚上，你梦到了Fibonacci，它告诉你一个有趣的Fibonacci数。醒来以后，你只记
得了它的开头几个数字。你的任务是找出以它开头的最小Fibonacci数的序号。例如以12开头
的最小Fibonacci数是F(25)。输入不超过40个数字，输出满足条件的序号。
如果序号小于100000的Fibonacci数均不满足条件，输出-1。
提示：本题有一定效率要求。如果高精度代码比较慢，可能会超时。
原题链接 合适的思路 首先想我们该怎么样能匹配前缀，首先我们不知道完整的数字是什么，所以我们要先得到符合要求的数字数据集。
然后将这些数据集放入字典树中
所以我们要做的就是
使用大数加法技巧，计算前100000个fibonacci 将每一个fibo数存入字典树中 大数加法 首先先做大数加法，使用字符串存储数字，两个字符串（数字）从最后一位即个位开始一位一位加。
问题在于：
100000个fibo数字，到后期位数是相当恐怖的，测试时发现第10万个数字有足足2万多位。这会造成在运算时时间和空间的非常糟糕的消耗。
所以我们就可以遵从题意，只关心前40位，我们只截取每个数字的前面一部分做计算。这就要引出第2个和第3个问题。 如果我们使用40位，不论后面多少位，就把第40位当作个位。这会产生一个误差的问题。 比如两个数字 11001 和88999，如果我们只取他们的前2位算出来下一个数的前2位是99，但是实际上下一个数的前2位是10。这就是误差。 在解决第1个问题的时候，我们需要考虑数字进位的情况，因为我们只能看到数字的前一部分，不知道两个相加的数字是否位数相等，比如1234和345相加，假设取前2位，那么我们只能看到12和34，这样直接相加是不对的。 解决
问题:3：先解决位数问题，我们可以将位数记录在字符串中，比如加入一个最后一位专门用来放位数。但是这样我们只能放256个无符号数字（因为使用char型元素存储）。那么换个思路，因为我们的问题在于两个数字位数不等，而不是位数究竟多少，所以可以只记录位数的奇偶即可。
（另：其他办法，因为是Fibo数，位数不等的情况下，后一个数是大的数字，位数肯定多，而且第一位肯定是1，可以用这些关键点来解决） 问题:2：为了解决误差问题，我们就不能只选取前40位，那么应该选几位呢，经过测试发现最小能保证前40位没有问题的位数是52，测试方法见附录。
不过要是不能测试的时候可以以10位为单位扩大范围，反正50和60位的差距远比50和2万的差距小。 字典树 每一个结点中存有
从根节点到此结点的最小的Fibo序数，即最小前缀数字。 一个map，存有下一位的数字到下一位所在的结点的位置映射关系。 结点之间的关系如下图
在存储的时候，存入的字符串在经过每一个结点的时候，都要比一下这个结点中存储的minIndex（FIbo最小前缀序号），并将其替换成两者中更小的。
这样就能保证按照字典树的脉络寻找，寻找到的结点中的序号，一定是前缀数所在的最小的Fibo序号。
注意点 不知道现在的UVA 编译器是怎么回事，我定义的 int型返回值函数没有给返回值，返回判我 Runtime error。我一开始压根不明觉厉，一行一行注释，然后一次次提交看看哪部分代码没有才会不报 re，以此来判断问题出在哪部分。光是这样就提交了十几次。
我愿称之为绝活。
在 线 O J ，现 场 调 试。...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 12333 - Revenge of Fibonacci (斐波那契的复仇) by SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-12333-revenge-of-fibonacci-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%9A%84%E5%A4%8D%E4%BB%87-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 133 - The Dole Queue（救济金点人）
    </h2>
  </header>
  <div class="entry-content">
    <p>例题4-3 救济金发放（The Dole Queue, UVa 133）
n(n&lt;20)个人站成一圈，逆时针编号为1～n。有两个官员，A从1开始逆时针数，B从n开
始顺时针数。在每一轮中，官员A数k个就停下来，官员B数m个就停下来（注意有可能两个
官员停在同一个人上）。接下来被官员选中的人（1个或者2个）离开队伍。
输入n，k，m输出每轮里被选中的人的编号（如果有两个人，先输出被A选中的）。例
如，n=10，k=4，m=3，输出为4 8, 9 5, 3 1, 2 6, 10, 7。注意：输出的每个数应当恰好占3格。（即setw(3)）
Sample Input
10 4 3
0 0 0
Sample Output
␣␣4␣␣8,␣␣9␣␣5,␣␣3␣␣1,␣␣2␣␣6,␣10,␣␣7
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=832&amp;page=show_problem&amp;problem=69
有一个数组来表示队列里的人，然后分别用两个循环，从头和尾开始依次过，并且记录下每一轮最后的落脚点，在下一轮中就当做是起始点了。点出来的人的位置可以直接用0代替。
#include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; int dole[25]; int n,a,b; int cycle(int j)//int n,int ab) { //int j=0; for(int i=0;i&lt;a;i&#43;&#43;) { do { j&#43;&#43;; if(j==n) j=0; continue; } while(dole[j]==0); //j&#43;&#43;; } return j; } int cycle2(int j)//int n,int b) { //int j=n-1; for(int i=0;i&lt;b;i&#43;&#43;) { do { j--; if(j&lt;0) j=n-1; continue; } while(dole[j]==0); } //cout&lt;&lt;&#34;j &#34;&lt;&lt;j&lt;&lt;endl; return j; } int main() { while(cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&amp;&amp;(n!...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 133 - The Dole Queue（救济金点人）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-133-the-dole-queue%E6%95%91%E6%B5%8E%E9%87%91%E7%82%B9%E4%BA%BA/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 1339 - Ancient Cipher（映射密码）
    </h2>
  </header>
  <div class="entry-content">
    <p>例题4-1 古老的密码（Ancient Cipher, NEERC 2004, UVa1339）
给定两个长度相同且不超过100的字符串，判断是否能把其中一个字符串的各个字母重
排，然后对26个字母做一个一一映射，使得两个字符串相同。例如，JWPUDJSTVP重排后可
以得到WJDUPSJPVT，然后把每个字母映射到它前一个字母（B-&gt;A, C-&gt;B, …, Z-&gt;Y, A-
Z），得到VICTORIOUS。输入两个字符串，输出YES或者NO。
Sample Input
JWPUDJSTVP
VICTORIOUS
MAMA
ROME
HAHA
HEHE
AAA
AAA
NEERCISTHEBEST
SECRETMESSAGES
Sample Output
YES
NO
YES
YES
NO
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=832&amp;problem=4085&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;20728592
//1、我们只需要分别记录两个字串里出现的各个字母的数量， //2、然后从小到大或从大到小排序， //3、之后进行比较，如果两个字串对应，那么他们的字母数量表相同下标的元素值（代表字母的数量）也应该相同。 #include&lt;iostream&gt; #include&lt;string&gt; using namespace std; void ssqrt(int *str) { //cout&lt;&lt;str&lt;&lt;endl; for(int i=0;i&lt;26;i&#43;&#43;) for(int j=i&#43;1;j&lt;26;j&#43;&#43;) if(str[i]&gt;str[j]) { int temp=str[i]; str[i]=str[j]; str[j]=temp; } //cout&lt;&lt;str&lt;&lt;endl; } int main() { string str,guess;//输入的两个字串 while(cin&gt;&gt;str&gt;&gt;guess) { int cha1[26]={0},cha2[26]={0};//分别记录两个字串里的各个字母的数量 for(int i=0;i&lt;str....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 1339 - Ancient Cipher（映射密码）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-1339-ancient-cipher%E6%98%A0%E5%B0%84%E5%AF%86%E7%A0%81/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 1368 - DNA Consensus String（DNA汉明距离）
    </h2>
  </header>
  <div class="entry-content">
    <p>习题3-7 DNA序列（DNA Consensus String, ACM/ICPC Seoul 2006, UVa1368）
输入m个长度均为n的DNA序列，求一个DNA序列，到所有序列的总Hamming距离尽量
小。两个等长字符串的Hamming距离等于字符不同的位置个数，例如，ACGT和GCGA的
Hamming距离为2（左数第1, 4个字符不同）。
输入整数m和n（4≤m≤50, 4≤n≤1000），以及m个长度为n的DNA序列（只包含字母
A，C，G，T），输出到m个序列的Hamming距离和最小的DNA序列和对应的距离。如有多
解，要求为字典序最小的解。例如，对于下面5个DNA序列，最优解为TAAGATAC。
TATGATAC
TAAGCTAC
AAAGATCC
TGAGATAC
TAAGATGT
（汉明距离：算出 每列与 此列最多量的字符 不同的字符的个数 ，各个列相加）
Sample Input
3
5 8
TATGATAC
TAAGCTAC
AAAGATCC
TGAGATAC
TAAGATGT
4 10
ACGTACGTAC
CCGTACGTAG
GCGTACGTAT
TCGTACGTAA
6 10
ATGTTACCAT
AAGTTACGAT
AACAAAGCAA
AAGTTACCTT
AAGTTACCAA
TACTTACCAA
Sample Output
TAAGATAC
7
ACGTACGTAA
6
AAGTTACCAA
12
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=830&amp;problem=4114&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;20524214
//能解出来就是好的，有时候略微繁琐一些是在所难免的。 //It&#39;s not necessary to tack such a toxic attitude around that it&#39;s slightly difficult....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 1368 - DNA Consensus String（DNA汉明距离）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-1368-dna-consensus-stringdna%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 156 - Ananagrams (反片语)
    </h2>
  </header>
  <div class="entry-content">
    <p>例题5-4 反片语（Ananagrams，Uva 156）
输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文
本中的另外一个单词。 在判断是否满足条件时，字母不分大小写，但在输出时应保留输入中
的大小写，按字典序进行排列（所有大写字母在所有小写字母的前面）。
Sample Input
ladder came tape soon leader acme RIDE lone Dreis peat
ScAlE orb eye Rides dealer NotE derail LaCeS drIed
noel dire Disk mace Rob dries
#
Sample Output
Disk
NotE
derail
drIed
eye
ladder
soon
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=835&amp;problem=92&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;22713249
思路和书上的一样, 先把每次的单词变成小写, 然后将其存入map的键, 值就是原单词.
如果是重复的单词, 那么就把值变成空的.
最后判断 map 里每一个迭代对象的值是不是空就行了
将不是空的结果存入一个set, set自动排序, 然后再将set遍历输出即可
#include&lt;iostream&gt; #include&lt;map&gt; #include&lt;string&gt; #include&lt;set&gt; #include&lt;algorithm&gt; using namespace std; string lower(string s){ string re; for(int i=0;i&lt;s....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 156 - Ananagrams (反片语)" href="https://sucicada.github.io/blog/posts/uvaoj/uva-156-ananagrams-%E5%8F%8D%E7%89%87%E8%AF%AD/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 1572 - Self-Assembly(自组合) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题6-19 自组合（Self-Assembly, ACM/ICPC World Finals 2013, UVa 1572）
有n（n≤40000）种边上带标号的正方形。每条边上的标号要么为一个大写字母后面跟着一个加号或减号，要么为数字00。当且仅当两条边的字母相同且符号相反时，两条边能拼在一起（00不能和任何边拼在一起，包括另一条标号为00的边）。
假设输入的每种正方形都有无穷多种，而且可以旋转和翻转，你的任务是判断能否组成一个无限大的结构。每条边要么悬空（不和任何边相邻），要么和一个上述可拼接的边相邻。如图6-17（a）所示是3个正方形，图6-17（b）所示边是它们组成的一个合法结构（但大小有限）。
Sample Input
3
A&#43;00A&#43;A&#43; 00B&#43;D&#43;A- B-C&#43;00C&#43;
1
K&#43;K-Q&#43;Q
Sample Output
bounded
unbounded
本家地址
提炼一下关键点：一共53种符号。方块数目很大，构造传统二维图会过大而超时。方块内部符号已知连通性。求方块间符号连通性。
可以抽象为52个点（00去掉），已知连通性（方块内部，不互补符号），互补符号可连通，当一段方块能够重复连接，即能够无限，即在可能的通路中求是否存在环路。
所以解决方案：使用dfs的方式，从一个符号开始，然后循环找方块内部的道路，找到之后，再递归走向下一个与其互补的符号。然后记录每一次递归通过的符号，即结点，当某一次递归走到了已经走过的符号结点上，那么就存在重复道路，即环路了。
具体看注释
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;cstring&gt; using namespace std; /* x -&gt; y : inner */ /* y -&gt; x : outer( &#43; -) */ // /* A&#43;B&#43;C&#43;D&#43;...A-B-C-D- */ /* A&#43;A-B&#43;B-C&#43;C-D&#43;D-... */ int table[55][55]; /* 1: can go 2: has gone 用于减少计算数 */ int look[55]; /* 作为标记，锁一类。作为当前一次dfs中,这个点是否已经走过了 用于判断环路存在 */ int run[55]; int getIndex(char a,char b){ return (a-&#39;A&#39;)*2 &#43; (b==&#39;-&#39;?...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 1572 - Self-Assembly(自组合) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-1572-self-assembly%E8%87%AA%E7%BB%84%E5%90%88-by-sucicada/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 1584 - Circular Sequence（环状序列）
    </h2>
  </header>
  <div class="entry-content">
    <p> 长度为n的环状串有n种表示法，分别为从某
个位置开始顺时针得到。例如，图3-4的环状串
有10种表示：
CGAGTCAGCT，GAGTCAGCTC，AGTCAGCTCG等。在这些表示法中，字典序最小的称
为&#34;最小表示&#34;。
输入一个长度为n（n≤100）的环状DNA串（只包含A、C、G、T这4种字符）的一种表
示法，你的任务是输出该环状串的最小表示。例如，CTCC的最小表示是
CCCT，CGAGTCAGCT的最小表示为AGCTCGAGTC。
Sample Input
2
CGAGTCAGCT
CTCC
Sample Output
AGCTCGAGTC
CCCT
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=829&amp;page=show_problem&amp;problem=4459
#include&lt;iostream&gt; #include&lt;string&gt; #include&lt;cstdio&gt; #include&lt;string.h&gt; using namespace std; int const N = 100; //比较从be1,和从be2开始的字串哪一个更小 int com(char *s,int be1,int be2) { int sl=strlen(s); for(int i=0;i&lt;sl;i&#43;&#43;) { //cout&lt;&lt;endl&lt;&lt;(be1&#43;i)%N&lt;&lt;endl; //cout&lt;&lt;s[(be1&#43;i)%N]&lt;&lt;&#34;_&#34;&lt;&lt;s[(be2&#43;i)%N]&lt;&lt;endl; if(s[(be1&#43;i)%sl]&gt;s[(be2&#43;i)%sl]) return be2; if(s[(be1&#43;i)%sl]&lt;s[(be2&#43;i)%sl]) return be1; } return be1; } char s[N&#43;5]; int main() { // char acgt[4]=&#34;ACGT&#34;; int T=1; cin&gt;&gt;T; while(T--) { scanf(&#34;%s&#34;,s); int j=0; int be1=0,be2; for(int i=0;i&lt;strlen(s);i&#43;&#43;)//找最小的首字符给be1 { if(s[i]&lt;s[be1]) { be1=i; } } //cout&lt;&lt;be1&lt;&lt;endl; for(int i=0;i&lt;strlen(s);i&#43;&#43;)//在最小的首字符中 找最小的字串 { if(s[i]==s[be1]) { if(com(s,be1,i)==i) be1=i; } } for(int i=0;i&lt;strlen(s);i&#43;&#43;) cout&lt;&lt;s[(be1&#43;i)%strlen(s)]; cout&lt;&lt;endl; } return 0; } ACat2017/12/9 </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 1584 - Circular Sequence（环状序列）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-1584-circular-sequence%E7%8E%AF%E7%8A%B6%E5%BA%8F%E5%88%97/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 1585 - Ancient Cipher （OX）
    </h2>
  </header>
  <div class="entry-content">
    <p> 给出一个由O和X组成的串（长度为1～80），统计得分。每个O的得分为目前连续出现
的O的个数，X的得分为0。例如，OOXXOXXOOO的得分为1&#43;2&#43;0&#43;0&#43;1&#43;0&#43;0&#43;1&#43;2&#43;3。
Sample Input
5
OOXXOXXOOO
OOXXOOXXOO
OXOXOXOXOXOXOX
OOOOOOOOOO
OOOOXOOOOXOOOOX
Sample Output
10
9
7
55
30
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=830&amp;problem=4460&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;20465648
#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int main() { int T; cin&gt;&gt;T; getchar(); while(T--) { int sum=0; int o=1; int c; while((c=getchar())!=&#39;\n&#39;) { if(c==&#39;O&#39;) { sum&#43;=o; o&#43;&#43;; } if(c==&#39;X&#39;) { o=1; } } cout&lt;&lt;sum&lt;&lt;endl; } return 0; } //AC at 2017/12/9 </p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 1585 - Ancient Cipher （OX）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-1585-ancient-cipher-ox/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 1586 - Molar mass（分子量）
    </h2>
  </header>
  <div class="entry-content">
    <p>给出一种物质的分子式（不带括号），求分子量。本题中的分子式只包含4种原子，分
别为C, H, O, N，原子量分别为12.01, 1.008, 16.00, 14.01（单位：g/mol）。例如，C6H5OH的
分子量为94.108g/mol。
Sample Input
4
C
C6H5OH
NH2CH2COOH
C12H22O11
Sample Output
12.010
94.108
75.070
342.296
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=830&amp;problem=4461&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;20466109
//通过判断下一个字符的类型来执行上一个原子的量计算 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cctype&gt; using namespace std; int main()//两个变量，一个存原子量，一个存后面的数字 { int T; cin&gt;&gt;T; getchar(); while(T--) { int c; double sum=0,mol=0; int num=0; while((c=getchar())!=&#39;\n&#39;) { if(isdigit(c)) { num=num*10&#43;c-&#39;0&#39;; //sum&#43;=mol*(c-&#39;0&#39;); //num=1; } else { if(num) { sum&#43;=mol*num;//加前一个原子*数量 mol=num=0; } else { sum&#43;=mol;//加前一个原子 } switch(c) { case &#39;C&#39;:mol=12.01;break; case &#39;H&#39;:mol=1....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 1586 - Molar mass（分子量）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-1586-molar-mass%E5%88%86%E5%AD%90%E9%87%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 1587 - Box（盒子）
    </h2>
  </header>
  <div class="entry-content">
    <p>习题3-10 盒子（Box, ACM/ICPC NEERC 2004, UVa1587）
给定6个矩形的长和宽wi和hi（1≤wi，hi≤1000），判断它们能否构成长方体的6个面。
Sample Input
1345 2584
2584 683
2584 1345
683 1345
683 1345
2584 683
1234 4567
1234 4567
4567 4321
4322 4567
4321 1234
4321 1234
Sample Output
POSSIBLE
IMPOSSIBLE
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=830&amp;problem=4462&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;20554313
1、因为长方体都有三组含四条的边，我们先将三条不同的边长度用一个数组存起，在用一个数组存各个边在六组数据中分别出现的次数。
2、输入的同时来进行存边，并记录下出现的正方形的个数（即输入的两条边相等）。
3、六组输入完成后，判断是否属于以下情况
（1）a 4 , b 4 ,c 4 ,正方面 0
（2）a 8 , b 4 ,c 0 ,正方面 2
（3）a 12 , b 0 ,c 0 ,正方面 6
（a 4：a长度的边有4条）...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 1587 - Box（盒子）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-1587-box%E7%9B%92%E5%AD%90/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 1588 - Kickdown（换低挡装置）
    </h2>
  </header>
  <div class="entry-content">
    <p>习题3-11 换低挡装置（Kickdown, ACM/ICPC NEERC 2006, UVa1588）
给出两个长度分别为n1，n2（n1，n2≤100）且每列高度只为1或2的长条。需要将它们放
入一个高度为3的容器（如图3-8所示），问能够容纳它们的最短容器长度。 Sample Input
2112112112
2212112
12121212
21212121
2211221122
21212
Sample Output
10
8
15
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=830&amp;problem=4463&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;20560401
用两个字符串数组分别存这两个块，一块作为不动的，另一块在其上移动，判断当前移动到的位置是不是和下块契合（用循环依次比较各个位置），若不是则继续移动到下一位。
需要注意的是，最短的契合方案有可能你漏想了，下面一共是三种可能的情况。所以我用一个函数来将两个块换了位置后又移动了一次。
//三种情况：bbbbb aa (|a|:ab重叠 //1.短块在长块里(bb|aa|b) //2.短块头在长块里（外），短块尾巴超出长块尾(bbbb|a|a) //3.长块头在短块尾（外），长块尾巴超出短块尾(a|a|bbbb) //不要忘记第三种情况，有时最短空间就是出自3 #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int N = 100; //int kick1[N&#43;5],kick2[N&#43;5]; int kickdown(string k1,string k2)//定k1，移k2 { //cout&lt;&lt;k1.size()&lt;&lt;&#34; &#34;&lt;&lt;k2.size()&lt;&lt;endl; for(int i=0;i&lt;k1.size();i&#43;&#43;) { int ii=i,j=0;//i就是大小块契合的那一位 //cout&lt;&lt;ii&lt;&lt;&#34; &#34;&lt;&lt;j&lt;&lt;endl; while((k1[ii]-&#39;0&#39;&#43;k2[j]-&#39;0&#39;)&lt;=3&amp;&amp;(j&lt;k2.size()&amp;&amp;ii&lt;k1.size()))//若当前位不匹配则进行for到下一位 { //cout&lt;&lt;&#34;k1 ii &#34;&lt;&lt;ii&lt;&lt;&#34; &#34;&lt;&lt;k1[ii]&lt;&lt;&#34; | k2 j&#34;&lt;&lt;j&lt;&lt;&#34; &#34;&lt;&lt;k2[j]&lt;&lt;endl; ii&#43;&#43;; j&#43;&#43;; } if(j==k2....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 1588 - Kickdown（换低挡装置）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-1588-kickdown%E6%8D%A2%E4%BD%8E%E6%8C%A1%E8%A3%85%E7%BD%AE/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 1589 - Xiangqi（象棋）
    </h2>
  </header>
  <div class="entry-content">
    <p>习题4-1 象棋（Xiangqi, ACM/ICPC Fuzhou 2011, UVa1589）
考虑一个象棋残局，其中红方有n（2≤n≤7）个棋子，黑方只有一个将。红方除了有一个
帅（G）之外还有3种可能的棋子：车（R），马（H），炮（C），并且需要考虑“蹩马
腿”（如图4-4所示）与将和帅不能照面（将、帅如果同在一条直线上，中间又不隔着任何棋
子的情况下，走子的一方获胜）的规则。
输入所有棋子的位置，保证局面合法并且红方已经将军。你的任务是判断红方是否已经
把黑方将死。
Sample Input
2 1 4
G 10 5
R 6 4
3 1 5
H 4 5
G 10 5
C 7 5
0 0 0
Sample Output
YES
NO
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=833&amp;problem=4464&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;20833399
注意：
输入的第一行第一个为红子的数量，后两个是黑将的位置。接下来的是红子类型和位置。
思路：
1、黑将有四种走法，即上下左右。我们只要判断 是否这四种走法中合理的都是死路 即可判断将是否被将死 。
2、先判断是否当前的黑将走子的位置是否合理，即当前的将子有没有超出九宫格。
3、对于车炮帅的将军，我们可以一起判断，先从将的位置开始，依次往一条路过，比如从（1，4）向（10，4）竖的过，
（1）如果路上遇到车或帅，那么就是将军了。
（2）若是非车帅的子，就计数加一。（比如我用c_iff变量记录目前非车帅的子数量）。
（3）若是炮，判断炮前是否有一个子（c_iff的值是不是一），若是，将军 。
（4）关于如何将“顺次从黑将开始分别左一行，右一行，上一列，下一列遍历格子上的子”放在一个循环条件里，见代码，我是将本应四个循环的条件写在一个循环体里用 if 处理了
4、关于马的将军，我们可以单独判断。看图,(x,y)位置为黑将，黑框位置为蹩马腿，如果此处没有子那么与其相邻的两个位置上有马的话就可以将军了。
这里的技巧1：两层循环过完四个方向，见代码
技巧2：黑框位置：（x&#43;i，y&#43;j），与其相邻的马（x&#43;i&#43;i，y&#43;j）和（x&#43;i，y&#43;j&#43;j）
5、注意：还有一点陷阱，我们还要考虑一开始黑将就和红帅对面，那样的话黑将就可以直接击杀红帅。样例：
2 1 5
G 10 5...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 1589 - Xiangqi（象棋）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-1589-xiangqi%E8%B1%A1%E6%A3%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>uva 1590 - IP Networks（IP地址）
    </h2>
  </header>
  <div class="entry-content">
    <p>习题4-5 IP网络（IP Networks, ACM/ICPC NEERC 2005, UVa1590）
可以用一个网络地址和一个子网掩码描述一个子网（即连续的IP地址范围）。其中子网
掩码包含32个二进制位，前32-n位为1，后n位为0，网络地址的前32-n位任意，后n位为0。
所有前32-n位和网络地址相同的IP都属于此网络。
例如，网络地址为194.85.160.176（二进制为11000010|01010101|10100000|10110000），
子网掩码为255.255.255.248（二进制为11111111|11111111|11111111|11111000），则该子网
的IP地址范围是194.85.160.176～194.85.160.183。输入一些IP地址，求最小的网络（即包含IP
地址最少的网络），包含所有这些输入地址。
例如，若输入3个IP地址：194.85.160.177、194.85.160.183和194.85.160.178，包含上述3
个地址的最小网络的网络地址为194.85.160.176，子网掩码为255.255.255.248。
Sample Input
3
194.85.160.177
194.85.160.183
194.85.160.178
Sample Output
194.85.160.176
255.255.255.248
【注意：他可能有很多组输入，而每组输出之间没有空行】
https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;category=833&amp;problem=4465&amp;mosmsg=Submission&#43;received&#43;with&#43;ID&#43;21184770
思路：
1、先将所有ip存起来，用数组或容器什么的。
2、转换二进制
3、从第一位开始，诸位比较所有的ip在这一位上的数字一样否
4、判断出最小网络位数，即掩码为1的位数。
5、转换十进制
（我用来存二进制的ip用的是string）
（用了下vector，当然也可以用数组存，一个32*1000的数组）
/* 110000100101010110100000_10110001 110000100101010110100000_10110111 110000100101010110100000_10110010 11000010010101011010000010110000 11111111111111111111111111111000 */ //特殊情况：只输入一个IP地址，这时掩码应该32位1 #include&lt;iostream&gt; #include&lt;stack&gt; #include&lt;string&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; using namespace std; string binary(int dec) { string str=&#34;00000000&#34;; stack&lt;int&gt; s; int bin=0; for(int i=7;i&gt;=0;i--) { //s.push(dec%2); str[i]=dec%2&#43;&#39;0&#39;; dec /= 2; } // while(!...</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to uva 1590 - IP Networks（IP地址）" href="https://sucicada.github.io/blog/posts/uvaoj/uva-1590-ip-networksip%E5%9C%B0%E5%9D%80/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>UVA 1592 - Database (数据库) By SuCicada
    </h2>
  </header>
  <div class="entry-content">
    <p>例题5-9 数据库（Database，ACM/ICPC NEERC 2009，UVa1592）
输入一个n行m列的数据库（1≤n≤10000，1≤i≤10），是否存在两个不同行r1，r2和两个
不同列c1，c2，使得这两行和这两列相同（即（r1，c1）和（r2，c1）相同，（r1，c2）和
（r2，c2）相同）。例如，对于如图5-3所示的数据库，第2、3行和第2、3列满足要求。
Sample Input
3 3
How to compete in ACM ICPC,Peter,peter@neerc.ifmo.ru
How to win ACM ICPC,Michael,michael@neerc.ifmo.ru
Notes from ACM ICPC champion,Michael,michael@neerc.ifmo.ru
2 3
1,Peter,peter@neerc.ifmo.ru
2,Michael,michael@neerc.ifmo.ru
Sample Output
NO
2 3
2 3
YES
本家地址
设计存储的结构
[ { (c1.value, c2.value) -&gt; r0.index } ] 列表中存储每一行中列列的组合（map存储）。列表的大小会是数据库的列*(列-1)/2。map的键是一个存有2个元素的列表（列表中存的是列值），map的值是对应的行下标。map的大小为总行数。
存储：
我们在存储时，针对每一行进行列的两两组合，然后对每一个组合在当前列组合下标中进行map查找，如果总排列数过完之后，有2个map匹配项，那我们就找到了。
在这里也用到了字符串索引存储的方式。类比指针，我们对每一个字符串给定一个编号，然后存在数据库中的就只是这个编号，而不用存字符串，节省了很大空间。
#include&lt;iostream&gt; #include&lt;map&gt; #include&lt;string&gt; #include&lt;vector&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; #include&lt;set&gt; using namespace std; /* [ { (c1.value, c2.value) -&gt; r0....</p>
  </div>
  <footer class="entry-footer">SuCicada</footer>
  <a class="entry-link" aria-label="post link to UVA 1592 - Database (数据库) By SuCicada" href="https://sucicada.github.io/blog/posts/uvaoj/uva-1592-database-%E6%95%B0%E6%8D%AE%E5%BA%93-by-sucicada/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://sucicada.github.io/blog/posts/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://sucicada.github.io/blog/posts/page/3/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://sucicada.github.io/blog">SuCicada</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
